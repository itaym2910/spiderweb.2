
--- File: index.html ---
<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

--- File: package.json ---
{
  "name": "spiderweb",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "start": "vite"
  },
  "dependencies": {
    "@faker-js/faker": "^9.8.0",
    "@reduxjs/toolkit": "^2.8.2",
    "@tanstack/react-virtual": "^3.13.12",
    "axios": "^1.10.0",
    "d3": "^7.9.0",
    "js-cookie": "^3.0.5",
    "lucide-react": "^0.513.0",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "react-icons": "^5.5.0",
    "react-redux": "^9.2.0",
    "react-router-dom": "^7.6.1",
    "react-tsparticles": "^2.12.2",
    "react-virtualized-auto-sizer": "^1.0.26",
    "tsparticles-slim": "^2.12.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.25.0",
    "@types/react": "^19.1.2",
    "@types/react-dom": "^19.1.2",
    "@vitejs/plugin-react": "^4.4.1",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.25.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "postcss": "^8.5.3",
    "tailwindcss": "^3.4.17",
    "vite": "^6.3.5"
  }
}

--- File: README.md ---
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.

--- File: src\App.css ---
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

--- File: src\App.jsx ---
// src/App.jsx

import React from "react";
import { Provider } from "react-redux";
import { store } from "./redux/store";
import { BrowserRouter, Routes, Route } from "react-router-dom";

// Import your components
import AppLayout from "./components/layout/AppLayout";
import LoginPage from "./pages/LoginPage";
import ProtectedRoute from "./components/auth/ProtectedRoute";
import { AppInitializer } from "./components/auth/AppInitializer";

function App() {
  return (
    <Provider store={store}>
      <BrowserRouter>
        <Routes>
          {/* Public Route: Anyone can access the login page */}
          <Route path="/login" element={<LoginPage />} />

          {/* Protected Routes: Only accessible if logged in */}
          <Route
            path="/*"
            element={
              <ProtectedRoute>
                {/* The AppInitializer now wraps the main layout */}
                <AppInitializer>
                  <AppLayout />
                </AppInitializer>
              </ProtectedRoute>
            }
          />
        </Routes>
      </BrowserRouter>
    </Provider>
  );
}

export default App;

--- File: src\index.css ---
/* src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* 
  Custom Global Scrollbar Styles
  These styles now apply to ALL scrollbars on the page, including <select> dropdowns.
*/

/* --- For WebKit browsers (Chrome, Safari, Edge) --- */

/* The entire scrollbar element */
::-webkit-scrollbar {
  width: 12px;
  height: 12px;
}

/* The track (the background) */
::-webkit-scrollbar-track {
  @apply bg-gray-100; /* Light mode track */
}
html.dark ::-webkit-scrollbar-track {
  @apply bg-gray-800; /* Dark mode track */
}

/* The draggable scrolling handle */
::-webkit-scrollbar-thumb {
  @apply bg-gray-400 rounded-lg border-2 border-solid border-gray-100; /* Light mode thumb */
}
html.dark ::-webkit-scrollbar-thumb {
  @apply bg-gray-600 rounded-lg border-2 border-solid border-gray-800; /* Dark mode thumb */
}

/* Handle on hover */
::-webkit-scrollbar-thumb:hover {
  @apply bg-gray-500;
}
html.dark ::-webkit-scrollbar-thumb:hover {
  @apply bg-gray-500;
}

/* --- For Firefox --- */
/* Firefox uses a simpler standard for scrollbar colors. */
html {
  scrollbar-width: thin;
  scrollbar-color: #9ca3af #f3f4f6; /* Light: thumb color, track color */
}
html.dark {
  scrollbar-color: #4b5563 #1f2937; /* Dark: thumb color, track color */
}

/* When the form is in a loading state, show a 'wait' cursor for the whole area */
form[data-loading="true"] {
  cursor: wait;
}

/* Even when disabled inside a loading form, input fields should show a text cursor */
form[data-loading="true"] input:disabled {
  cursor: text;
}

/* The login button should also show a 'wait' cursor when its parent form is loading */
form[data-loading="true"] button:disabled {
  cursor: wait;
}

--- File: src\main.jsx ---
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import App from "./App.jsx";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <App />
  </StrictMode>
);

--- File: src\components\auth\AppInitializer.jsx ---
import React, { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { createSelector } from "@reduxjs/toolkit";
import { fetchInitialData } from "../../redux/slices/authSlice";
import { startConnecting } from "../../redux/slices/realtimeSlice";
import { fetchAllAlerts } from "../../redux/slices/alertsSlice"; // <-- NEW: Import alert thunk
import { Loader2, AlertTriangle } from "lucide-react";

// Memoized selector to prevent unnecessary re-renders
const selectPikudimStatus = (state) => state.corePikudim.status;
const selectDevicesStatus = (state) => state.devices.status;
const selectLinksStatus = (state) => state.tenGigLinks.status;
const selectSitesStatus = (state) => state.sites.status;

const selectCoreDataStatus = createSelector(
  [
    selectPikudimStatus,
    selectDevicesStatus,
    selectLinksStatus,
    selectSitesStatus,
  ],
  (pikudim, devices, links, sites) => ({
    pikudim,
    devices,
    links,
    sites,
  })
);

export function AppInitializer({ children }) {
  const dispatch = useDispatch();
  const dataStatus = useSelector(selectCoreDataStatus);

  // Derived state to determine the overall status
  const isIdle = Object.values(dataStatus).every((s) => s === "idle");
  const isSuccessful = Object.values(dataStatus).every(
    (s) => s === "succeeded"
  );
  const isLoading = Object.values(dataStatus).some((s) => s === "loading");
  const hasFailed = Object.values(dataStatus).some((s) => s === "failed");

  // Effect for fetching initial data and starting real-time connection
  useEffect(() => {
    if (isIdle) {
      dispatch(fetchInitialData());
    }

    if (isSuccessful) {
      dispatch(startConnecting());
    }
  }, [isIdle, isSuccessful, dispatch]);

  // --- NEW: Effect for periodic alert polling ---
  useEffect(() => {
    let intervalId;

    // Start polling only when the core application data has successfully loaded.
    if (isSuccessful) {
      // Set up the interval to dispatch the fetch action every 30 seconds.
      intervalId = setInterval(() => {
        dispatch(fetchAllAlerts());
      }, 30000); // 30,000 milliseconds = 30 seconds
    }

    // This is a cleanup function. React runs it when the component unmounts
    // or when the 'isSuccessful' dependency changes before re-running the effect.
    // This prevents memory leaks and duplicate intervals.
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [isSuccessful, dispatch]); // This effect depends on the success state and dispatch function

  const handleRetry = () => {
    dispatch(fetchInitialData());
  };

  // --- RENDERING LOGIC ---

  // Display a loading screen while fetching initial data
  if (isLoading || isIdle) {
    return (
      <div className="flex h-screen w-full items-center justify-center bg-gray-100 dark:bg-gray-950">
        <div className="flex flex-col items-center gap-4 text-center p-4">
          <Loader2 className="h-16 w-16 animate-spin text-blue-500" />
          <h1 className="text-2xl font-bold text-gray-800 dark:text-gray-100 mt-4">
            Initializing Spiderweb
          </h1>
          <p className="text-gray-600 dark:text-gray-400">
            Fetching network topology and status...
          </p>
        </div>
      </div>
    );
  }

  // Display an error screen if any of the initial fetches fail
  if (hasFailed) {
    return (
      <div className="flex h-screen w-full items-center justify-center bg-gray-100 dark:bg-gray-950">
        <div className="flex flex-col items-center gap-4 text-center p-4">
          <AlertTriangle className="h-16 w-16 text-red-500" />
          <h1 className="text-2xl font-bold text-red-600 dark:text-red-400 mt-4">
            Failed to Load Application Data
          </h1>
          <p className="text-gray-600 dark:text-gray-400 max-w-md">
            An error occurred while fetching critical network information.
            Please check your connection and try again.
          </p>
          <button
            onClick={handleRetry}
            className="mt-6 px-6 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 transition-colors"
          >
            Retry
          </button>
        </div>
      </div>
    );
  }

  // Once everything is loaded, render the main application
  return children;
}

--- File: src\components\auth\ProtectedRoute.jsx ---
// src/components/auth/ProtectedRoute.jsx

import React from "react";
import { useSelector } from "react-redux";
import { Navigate, useLocation } from "react-router-dom";
import { selectAuthToken } from "../../redux/slices/authSlice";

function ProtectedRoute({ children }) {
  const token = useSelector(selectAuthToken);
  const location = useLocation();

  if (!token) {
    // Redirect them to the /login page, but save the current location they were
    // trying to go to. This allows us to send them along to that page after a
    // successful login.
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
}

export default ProtectedRoute;

--- File: src\components\chart\drawHelpers.jsx ---
export function getNodeGroups(nodes) {
  const zoneSet = new Set(nodes.map((n) => n.zone));
  const sortedZones = Array.from(zoneSet).sort();
  const ZONE_COUNT = sortedZones.length;

  const centerX = window.innerWidth / 2;
  const centerY = window.innerHeight / 2;

  const radiusX = window.innerWidth / 3;
  const radiusY = window.innerHeight / 3.5;

  return sortedZones.map((zoneId, i) => {
    const angleOffset = ZONE_COUNT % 2 === 1 ? -Math.PI / 2 : 0;

    const angle = (2 * Math.PI * i) / ZONE_COUNT + angleOffset;

    return {
      id: zoneId,
      angle,
      cx: centerX + radiusX * Math.cos(angle),
      cy: centerY + radiusY * Math.sin(angle),
    };
  });
}

export function constrainToZone(
  d,
  nodeGroups,
  nodeRadius = 60,
  zoneRadius = 150
) {
  const zone = nodeGroups.find((z) => z.id === d.zone);
  if (!zone) return;

  const dx = d.x - zone.cx;
  const dy = d.y - zone.cy;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const maxDistance = zoneRadius - nodeRadius; // adjust to keep entire node inside

  if (distance > maxDistance) {
    const angle = Math.atan2(dy, dx);
    d.x = zone.cx + maxDistance * Math.cos(angle);
    d.y = zone.cy + maxDistance * Math.sin(angle);
  }
}

export function linkPositionFromEdges(d, r = 60) {
  const dx = d.target.x - d.source.x;
  const dy = d.target.y - d.source.y;
  const angle1 = Math.atan2(dy, dx);
  const angle2 = Math.atan2(-dy, -dx);

  return {
    x1: d.source.x + r * Math.cos(angle1),
    y1: d.source.y + r * Math.sin(angle1),
    x2: d.target.x + r * Math.cos(angle2),
    y2: d.target.y + r * Math.sin(angle2),
  };
}

--- File: src\components\chart\handleInteractions.jsx ---
// src/chart/handleInteractions.js
import { linkPositionFromEdges } from "./drawHelpers";
import * as d3 from "d3";

// --- Helper function to create payload for link popups ---
function createLinkPopupPayload(linkDataObject) {
  if (!linkDataObject) return null;

  const sourceId =
    typeof linkDataObject.source === "object" && linkDataObject.source !== null
      ? linkDataObject.source.id
      : linkDataObject.source;
  const targetId =
    typeof linkDataObject.target === "object" && linkDataObject.target !== null
      ? linkDataObject.target.id
      : linkDataObject.target;

  // Ensure 'id' for the popup system is the actual link's ID if available,
  // otherwise generate one. This 'id' is for the popup instance.
  // The original link's ID will be stored in a separate property if needed, e.g., 'originalLinkId'
  // For SiteDetailPopup, detailData.id is used for aria and keys.
  const popupId =
    linkDataObject.id ||
    `${sourceId}-${targetId}-${Math.random().toString(16).slice(2)}`;

  return {
    ...linkDataObject, // Spread existing link data to retain all original properties
    type: "link", // Explicitly set type for the popup
    id: popupId, // This ID is used by usePopupManager and SiteDetailPopup for its key and aria attributes

    // Fields expected by SiteDetailPopup for type: "link"
    // Adjust these based on the actual properties available in your linkDataObject
    // and what SiteDetailPopup expects.
    linkId: linkDataObject.id, // <<< Explicitly including the original link ID
    sourceNode: sourceId,
    targetNode: targetId,
    name:
      linkDataObject.name ||
      linkDataObject.id ||
      `Link ${sourceId}-${targetId}`, // A display name
    status: linkDataObject.status || "N/A",
    linkBandwidth:
      linkDataObject.bandwidth || linkDataObject.linkBandwidth || "N/A",
    latency: linkDataObject.latency || "N/A",
    utilization: linkDataObject.utilization || "N/A",
    linkDescription:
      linkDataObject.description || linkDataObject.linkDescription || "N/A",
    sourceInterface: linkDataObject.sourceInterface || "N/A",
    targetInterface: linkDataObject.targetInterface || "N/A",
    encapsulation: linkDataObject.encapsulation || "N/A",
    lastFlap: linkDataObject.lastFlap || "N/A",
  };
}

// ===================================================================
// NEW: Helper function to get the correct color by category
// ===================================================================
function getLinkColorByCategory(linkData, palette) {
  // Default to 'issue' if category is missing, for robustness
  const category = linkData.category || "issue";
  // Return the color from the palette, or the issue color as a fallback
  return palette.status[category] || palette.status.issue;
}

function handleMouseOut(d_hovered_orig, linkSelection, tooltip, palette) {
  if (
    !d_hovered_orig ||
    typeof d_hovered_orig.source === "undefined" ||
    typeof d_hovered_orig.target === "undefined"
  ) {
    linkSelection
      .attr("stroke", palette.link)
      .attr("stroke-opacity", 0.6)
      .style("pointer-events", "auto")
      .attr("stroke-width", 2);
    d3.selectAll("circle.node")
      .attr("fill", palette.node)
      .attr("stroke", palette.stroke)
      .attr("stroke-width", 2);
    d3.selectAll("path.duplicate-link").remove();
    d3.selectAll("path.duplicate-link-hover").remove();
    tooltip.attr("opacity", 0);
    return;
  }

  const sourceId =
    typeof d_hovered_orig.source === "object" && d_hovered_orig.source !== null
      ? d_hovered_orig.source.id
      : d_hovered_orig.source;
  const targetId =
    typeof d_hovered_orig.target === "object" && d_hovered_orig.target !== null
      ? d_hovered_orig.target.id
      : d_hovered_orig.target;

  if (typeof sourceId === "undefined" || typeof targetId === "undefined") {
    linkSelection.attr("stroke-opacity", 0.6).style("pointer-events", "auto");
    d3.selectAll("circle.node")
      .attr("fill", palette.node)
      .attr("stroke", palette.stroke);
    d3.selectAll("path.duplicate-link").remove();
    d3.selectAll("path.duplicate-link-hover").remove();
    tooltip.attr("opacity", 0);
    return;
  }

  const key_unhovered = [sourceId, targetId].sort().join("--");

  linkSelection.each(function (l_straight) {
    if (
      !l_straight ||
      typeof l_straight.source === "undefined" ||
      typeof l_straight.target === "undefined"
    ) {
      return;
    }
    const s_id =
      typeof l_straight.source === "object" && l_straight.source !== null
        ? l_straight.source.id
        : l_straight.source;
    const t_id =
      typeof l_straight.target === "object" && l_straight.target !== null
        ? l_straight.target.id
        : l_straight.target;

    if (typeof s_id === "undefined" || typeof t_id === "undefined") {
      return;
    }
    const straightKey = [s_id, t_id].sort().join("--");
    if (straightKey === key_unhovered) {
      d3.select(this)
        .attr("stroke", palette.link)
        .attr("stroke-opacity", 0.6)
        .style("pointer-events", "auto")
        .attr("stroke-width", 2);
    }
  });

  d3.selectAll("circle.node")
    .filter((n) => n.id === sourceId || n.id === targetId)
    .attr("fill", palette.node)
    .attr("stroke", palette.stroke)
    .attr("stroke-width", 2);

  tooltip.attr("opacity", 0);

  d3.selectAll("path.duplicate-link").remove();
  d3.selectAll("path.duplicate-link-hover").remove();
}

function handleMouseOver(
  d_hovered_orig,
  allNodes,
  filteredLinks,
  linkSelection,
  zoomLayer,
  tooltip,
  palette,
  onLinkClick
) {
  const sourceId =
    typeof d_hovered_orig.source === "object" && d_hovered_orig.source !== null
      ? d_hovered_orig.source.id
      : d_hovered_orig.source;
  const targetId =
    typeof d_hovered_orig.target === "object" && d_hovered_orig.target !== null
      ? d_hovered_orig.target.id
      : d_hovered_orig.target;

  if (typeof sourceId === "undefined" || typeof targetId === "undefined") {
    return;
  }

  const key = [sourceId, targetId].sort().join("--");

  linkSelection.each(function (l_straight) {
    const s =
      typeof l_straight.source === "object" && l_straight.source !== null
        ? l_straight.source.id
        : l_straight.source;
    const t =
      typeof l_straight.target === "object" && l_straight.target !== null
        ? l_straight.target.id
        : l_straight.target;

    if (typeof s === "undefined" || typeof t === "undefined") {
      return;
    }
    const straightKey = [s, t].sort().join("--");
    if (straightKey === key) {
      d3.select(this).attr("stroke-opacity", 0).style("pointer-events", "none");
    }
  });

  d3.selectAll("circle.node")
    .filter((n) => n.id === sourceId || n.id === targetId)
    .attr("fill", "#fde68a")
    .attr("stroke", "#facc15")
    .attr("stroke-width", 4);

  zoomLayer.selectAll("path.duplicate-link").remove();
  zoomLayer.selectAll("path.duplicate-link-hover").remove();

  const duplicates = filteredLinks.filter((l) => {
    const s =
      typeof l.source === "object" && l.source !== null
        ? l.source.id
        : l.source;
    const t =
      typeof l.target === "object" && l.target !== null
        ? l.target.id
        : l.target;
    if (typeof s === "undefined" || typeof t === "undefined") return false;
    return [s, t].sort().join("--") === key;
  });

  const sourceNode = allNodes.find((n) => n.id === sourceId);
  const targetNode = allNodes.find((n) => n.id === targetId);

  if (!sourceNode || !targetNode) {
    return;
  }

  const nodeRadius = 60;
  const { x1, y1, x2, y2 } = linkPositionFromEdges(
    { source: sourceNode, target: targetNode },
    nodeRadius
  );

  const dx = x2 - x1;
  const dy = y2 - y1;
  const length = Math.sqrt(dx * dx + dy * dy);
  if (length === 0) {
    return;
  }

  const ux = dx / length;
  const uy = dy / length;
  const perpX = -uy;
  const perpY = ux;

  duplicates.forEach((linkData, index) => {
    const offset = 10 * (index - (duplicates.length - 1) / 2);
    const startX = x1 + perpX * offset;
    const startY = y1 + perpY * offset;
    const endX = x2 + perpX * offset;
    const endY = y2 + perpY * offset;

    zoomLayer
      .append("path")
      .datum(linkData)
      .attr("class", "duplicate-link")
      .attr("d", `M${startX},${startY} L${endX},${endY}`)
      .attr("fill", "none")
      // USE THE NEW COLOR HELPER
      .attr("stroke", getLinkColorByCategory(linkData, palette))
      .attr("stroke-width", 3)
      .style("pointer-events", "none");

    zoomLayer
      .append("path")
      .datum(linkData)
      .attr("class", "duplicate-link-hover")
      .attr("d", `M${startX},${startY} L${endX},${endY}`)
      .attr("fill", "none")
      .attr("stroke", "transparent")
      .attr("stroke-width", 12)
      .style("cursor", "pointer")
      .on("mousemove", function (event, d_mousemove) {
        tooltip
          .attr("x", event.offsetX + 10)
          .attr("y", event.offsetY - 10)
          .text(d_mousemove.id) // This shows the original link ID in tooltip
          .attr("opacity", 1);
      })
      .on("mouseout", function (event, d_curved_mouseout) {
        tooltip.attr("opacity", 0);

        const relatedTarget = event.relatedTarget;
        let shouldCleanupFromCurved = true;

        const currentCurvedSourceId =
          typeof d_curved_mouseout.source === "object" &&
          d_curved_mouseout.source !== null
            ? d_curved_mouseout.source.id
            : d_curved_mouseout.source;
        const currentCurvedTargetId =
          typeof d_curved_mouseout.target === "object" &&
          d_curved_mouseout.target !== null
            ? d_curved_mouseout.target.id
            : d_curved_mouseout.target;

        if (
          typeof currentCurvedSourceId === "undefined" ||
          typeof currentCurvedTargetId === "undefined"
        ) {
          // If IDs are missing, assume cleanup is needed
        } else {
          const currentCurvedKey = [
            currentCurvedSourceId,
            currentCurvedTargetId,
          ]
            .sort()
            .join("--");

          if (relatedTarget) {
            const rtSelection = d3.select(relatedTarget);
            const rtData = rtSelection.datum();

            if (
              rtSelection.classed("duplicate-link-hover") &&
              rtData &&
              typeof rtData.source !== "undefined" &&
              typeof rtData.target !== "undefined"
            ) {
              const relatedCurvedSourceId =
                typeof rtData.source === "object" && rtData.source !== null
                  ? rtData.source.id
                  : rtData.source;
              const relatedCurvedTargetId =
                typeof rtData.target === "object" && rtData.target !== null
                  ? rtData.target.id
                  : rtData.target;
              if (
                typeof relatedCurvedSourceId !== "undefined" &&
                typeof relatedCurvedTargetId !== "undefined"
              ) {
                const relatedCurvedKey = [
                  relatedCurvedSourceId,
                  relatedCurvedTargetId,
                ]
                  .sort()
                  .join("--");
                if (currentCurvedKey === relatedCurvedKey) {
                  shouldCleanupFromCurved = false;
                }
              }
            } else if (
              rtSelection.classed("link-hover") &&
              rtData &&
              typeof rtData.source !== "undefined" &&
              typeof rtData.target !== "undefined"
            ) {
              const relatedStraightSourceId =
                typeof rtData.source === "object" && rtData.source !== null
                  ? rtData.source.id
                  : rtData.source;
              const relatedStraightTargetId =
                typeof rtData.target === "object" && rtData.target !== null
                  ? rtData.target.id
                  : rtData.target;
              if (
                typeof relatedStraightSourceId !== "undefined" &&
                typeof relatedStraightTargetId !== "undefined"
              ) {
                const relatedStraightKey = [
                  relatedStraightSourceId,
                  relatedStraightTargetId,
                ]
                  .sort()
                  .join("--");
                if (currentCurvedKey === relatedStraightKey) {
                  shouldCleanupFromCurved = false;
                }
              }
            }
          }
        }

        if (shouldCleanupFromCurved) {
          handleMouseOut(d_curved_mouseout, linkSelection, tooltip, palette);
        }
      })
      .on("click", function (event, d_clicked_duplicate_link) {
        if (onLinkClick) {
          const payload = createLinkPopupPayload(d_clicked_duplicate_link);
          if (payload) {
            onLinkClick(payload);
          }
        }
        console.log(
          "[Link Click] Curved/Duplicate link ID:",
          d_clicked_duplicate_link.id // This is the original link ID
        );
        event.stopPropagation();
      });
  });
}

// ===================================================================
// NEW: Function to remove all dynamically drawn parallel links
// ===================================================================
export function removeAllParallelLinks(zoomLayer) {
  if (zoomLayer) {
    zoomLayer
      .selectAll("path.duplicate-link, path.duplicate-link-hover")
      .remove();
  }
}

// ===================================================================
// NEW: Function to draw all parallel links across the entire graph
// ===================================================================
export function drawAllParallelLinks({
  zoomLayer,
  allNodes,
  filteredLinks,
  tooltip,
  palette,
  onLinkClick,
}) {
  if (!zoomLayer) return;

  // 1. Group all links by the pair of nodes they connect
  const linkGroups = new Map();
  filteredLinks.forEach((link) => {
    const sourceId =
      typeof link.source === "object" ? link.source.id : link.source;
    const targetId =
      typeof link.target === "object" ? link.target.id : link.target;
    const key = [sourceId, targetId].sort().join("--");

    if (!linkGroups.has(key)) {
      linkGroups.set(key, []);
    }
    linkGroups.get(key).push(link);
  });

  // 2. Iterate over each group and draw the parallel links
  linkGroups.forEach((duplicates) => {
    if (duplicates.length < 1) return; // Or < 2 if you only want to fan out actual duplicates

    const firstLink = duplicates[0];
    const sourceId =
      typeof firstLink.source === "object"
        ? firstLink.source.id
        : firstLink.source;
    const targetId =
      typeof firstLink.target === "object"
        ? firstLink.target.id
        : firstLink.target;

    const sourceNode = allNodes.find((n) => n.id === sourceId);
    const targetNode = allNodes.find((n) => n.id === targetId);

    if (!sourceNode || !targetNode) return;

    // --- This entire drawing block is adapted from handleMouseOver ---
    const nodeRadius = 60;
    const { x1, y1, x2, y2 } = linkPositionFromEdges(
      { source: sourceNode, target: targetNode },
      nodeRadius
    );

    const dx = x2 - x1;
    const dy = y2 - y1;
    const length = Math.sqrt(dx * dx + dy * dy);
    if (length === 0) return;

    const ux = dx / length;
    const uy = dy / length;
    const perpX = -uy;
    const perpY = ux;

    duplicates.forEach((linkData, index) => {
      const offset = 10 * (index - (duplicates.length - 1) / 2);
      const startX = x1 + perpX * offset;
      const startY = y1 + perpY * offset;
      const endX = x2 + perpX * offset;
      const endY = y2 + perpY * offset;

      zoomLayer
        .append("path")
        .datum(linkData)
        .attr("class", "duplicate-link")
        .attr("d", `M${startX},${startY} L${endX},${endY}`)
        .attr("fill", "none")
        // USE THE NEW COLOR HELPER
        .attr("stroke", getLinkColorByCategory(linkData, palette))
        .attr("stroke-width", 3)
        .style("pointer-events", "none");

      zoomLayer
        .append("path")
        .datum(linkData)
        .attr("class", "duplicate-link-hover")
        .attr("d", `M${startX},${startY} L${endX},${endY}`)
        .attr("fill", "none")
        .attr("stroke", "transparent")
        .attr("stroke-width", 12)
        .style("cursor", "pointer")
        // NEW: Highlight connected nodes on mouseover
        .on("mouseover", function (event, d_mouseover) {
          const s_id = d_mouseover.source.id;
          const t_id = d_mouseover.target.id;
          d3.selectAll("circle.node")
            .filter((n) => n.id === s_id || n.id === t_id)
            .attr("fill", palette.nodeHoverLink)
            .attr("stroke", palette.nodeHoverLinkStroke)
            .attr("stroke-width", 4);
        })
        .on("mousemove", function (event, d_mousemove) {
          tooltip
            .attr("x", event.offsetX + 10)
            .attr("y", event.offsetY - 10)
            .text(d_mousemove.id)
            .attr("opacity", 1);
        })
        // MODIFIED: Un-highlight nodes on mouseout
        .on("mouseout", function (event, d_mouseout) {
          tooltip.attr("opacity", 0);
          const s_id = d_mouseout.source.id;
          const t_id = d_mouseout.target.id;
          d3.selectAll("circle.node")
            .filter((n) => n.id === s_id || n.id === t_id)
            .attr("fill", palette.node)
            .attr("stroke", palette.stroke)
            .attr("stroke-width", 2);
        })
        .on("click", function (event, d_clicked_duplicate_link) {
          if (onLinkClick) {
            const payload = createLinkPopupPayload(d_clicked_duplicate_link);
            if (payload) onLinkClick(payload);
          }
          event.stopPropagation();
        });
    });
  });
}

export function setupInteractions({
  link,
  linkHover,
  filteredLinks,
  node,
  tooltip,
  palette,
  zoomLayer,
  onLinkClick,
}) {
  if (!zoomLayer || !zoomLayer.node()) {
    console.error(
      "zoomLayer was not provided or is invalid in setupInteractions."
    );
    return;
  }
  if (!linkHover || !linkHover.size()) {
    console.error(
      "`linkHover` selection (for .link-hover) is empty or invalid in setupInteractions. Hover will not work."
    );
    return;
  }

  const allNodes = node.data();

  linkHover
    .on("mouseover", function (event, d_hovered_linkhover) {
      handleMouseOver(
        d_hovered_linkhover,
        allNodes,
        filteredLinks,
        link,
        zoomLayer,
        tooltip,
        palette,
        onLinkClick
      );
    })
    .on("mouseout", function (event, d_hovered_linkhover) {
      const relatedTarget = event.relatedTarget;
      let shouldProceedWithMouseOut = true;

      const currentOriginalSourceId =
        typeof d_hovered_linkhover.source === "object" &&
        d_hovered_linkhover.source !== null
          ? d_hovered_linkhover.source.id
          : d_hovered_linkhover.source;
      const currentOriginalTargetId =
        typeof d_hovered_linkhover.target === "object" &&
        d_hovered_linkhover.target !== null
          ? d_hovered_linkhover.target.id
          : d_hovered_linkhover.target;

      if (
        typeof currentOriginalSourceId === "undefined" ||
        typeof currentOriginalTargetId === "undefined"
      ) {
        // If IDs are missing, assume cleanup is needed
      } else {
        const currentOriginalKey = [
          currentOriginalSourceId,
          currentOriginalTargetId,
        ]
          .sort()
          .join("--");

        if (relatedTarget) {
          const rtSelection = d3.select(relatedTarget);
          const rtData = rtSelection.datum();

          if (
            rtSelection.classed("duplicate-link-hover") &&
            rtData &&
            typeof rtData.source !== "undefined" &&
            typeof rtData.target !== "undefined"
          ) {
            const relatedCurvedSourceId =
              typeof rtData.source === "object" && rtData.source !== null
                ? rtData.source.id
                : rtData.source;
            const relatedCurvedTargetId =
              typeof rtData.target === "object" && rtData.target !== null
                ? rtData.target.id
                : rtData.target;
            if (
              typeof relatedCurvedSourceId !== "undefined" &&
              typeof relatedCurvedTargetId !== "undefined"
            ) {
              const relatedCurvedKey = [
                relatedCurvedSourceId,
                relatedCurvedTargetId,
              ]
                .sort()
                .join("--");
              if (currentOriginalKey === relatedCurvedKey) {
                shouldProceedWithMouseOut = false;
              }
            }
          }
        }
      }

      if (shouldProceedWithMouseOut) {
        handleMouseOut(d_hovered_linkhover, link, tooltip, palette);
      }
    })
    .on("click", function (event, d_clicked_linkhover) {
      if (onLinkClick) {
        const payload = createLinkPopupPayload(d_clicked_linkhover);
        if (payload) {
          onLinkClick(payload);
        }
      }
      console.log(
        "[Link Click] Straight link (.link-hover) ID:",
        d_clicked_linkhover.id
      ); // This is the original link ID
      event.stopPropagation();
    });
}

--- File: src\components\chart\NetworkVisualizer.jsx ---
import React, { useEffect, useRef } from "react";
import * as d3 from "d3";
import { linkPositionFromEdges, getNodeGroups } from "./drawHelpers";
import { renderCoreDevices } from "./renderCoreDevices";
import {
  setupInteractions,
  drawAllParallelLinks,
  removeAllParallelLinks,
} from "./handleInteractions";

// +++ ADD `showDetailedLinks` TO THE PROPS
const NetworkVisualizer = ({
  theme,
  data,
  showDetailedLinks,
  onZoneClick,
  onLinkClick,
  onNodeClick,
}) => {
  const svgRef = useRef();

  // +++ ADD `showDetailedLinks` TO THE DEPENDENCY ARRAY
  useEffect(() => {
    const svgElement = svgRef.current;
    if (!svgElement) return;

    const width = svgElement.clientWidth || window.innerWidth;
    const height = svgElement.clientHeight || window.innerHeight;

    // ... (rest of the initial setup logic is unchanged)
    const nodes = structuredClone(data.nodes || []);
    const links = structuredClone(data.links || []);

    if (nodes.length === 0) {
      d3.select(svgElement).selectAll("*").remove();
      return;
    }

    // ... (palette and node/link processing is unchanged)
    const NODE_GROUPS = getNodeGroups(nodes);

    const nodeMap = {};
    NODE_GROUPS.forEach((zone) => {
      const zoneNodes = nodes.filter((n) => n.zone === zone.id);
      const baseAngle = zone.angle;
      const perpendicularAngle = baseAngle + Math.PI / 2;
      const spacing = 140;
      const radiusFromZone = 0;

      zoneNodes.forEach((node, i) => {
        const offset = (i - (zoneNodes.length - 1) / 2) * spacing;
        node.x =
          zone.cx +
          offset * Math.cos(perpendicularAngle) +
          radiusFromZone * Math.cos(baseAngle);
        node.y =
          zone.cy +
          offset * Math.sin(perpendicularAngle) +
          radiusFromZone * Math.sin(baseAngle);
        nodeMap[node.id] = node;
      });
    });

    links.forEach((link) => {
      link.source = nodeMap[link.source];
      link.target = nodeMap[link.target];
    });

    const isDark = theme === "dark";

    const palette = {
      bg: isDark ? "#1f2937" : "#ffffff",
      link: isDark ? "#94a3b8" : "#6b7280",
      node: isDark ? "#29c6e0" : "#29c6e0",
      nodeHoverDirect: isDark ? "#1d9bb4" : "#22b8d4",
      stroke: isDark ? "#60a5fa" : "#1d4ed8",
      label: isDark ? "#ffffff" : "#1f2937",
      zone: {
        fill: isDark ? "#38bdf8" : "#7dd3fc",
        opacity: isDark ? 0.12 : 0.25,
        hoverFill: isDark ? "#7dd3fc" : "#bae6fd",
        hoverOpacity: isDark ? 0.25 : 0.4,
      },
      nodeHoverLink: isDark ? "#fde68a" : "#fef08a",
      nodeHoverLinkStroke: isDark ? "#facc15" : "#f59e0b",

      status: {
        up: isDark ? "#4ade80" : "#22c55e",
        down: isDark ? "#f87171" : "#ef4444",
        issue: isDark ? "#facc15" : "#f59e0b",
      },
    };

    const svg = d3
      .select(svgElement)
      .attr("width", width)
      .attr("height", height)
      .style("background-color", palette.bg);

    svg.selectAll("*").remove();
    const zoomLayer = svg.append("g").attr("class", "main-zoom-layer");
    const tooltipLayer = svg.append("g").attr("class", "tooltip-layer-group");

    const ZOOM_THRESHOLD = 1.5;
    let parallelLinksAreVisible = false;

    const zoomBehavior = d3
      .zoom()
      .scaleExtent([0.05, 8])
      .on("zoom", (event) => {
        const { transform } = event;
        zoomLayer.attr("transform", transform);

        // +++ MODIFY THE CONDITION TO INCLUDE THE PROP
        const shouldShowDetailed =
          transform.k >= ZOOM_THRESHOLD || showDetailedLinks;

        if (shouldShowDetailed && !parallelLinksAreVisible) {
          parallelLinksAreVisible = true;
          link.style("display", "none");
          linkHover.style("display", "none");
          drawAllParallelLinks({
            zoomLayer,
            allNodes: node.data(),
            filteredLinks,
            tooltip,
            palette,
            onLinkClick,
            linkSelection: link,
          });
        } else if (!shouldShowDetailed && parallelLinksAreVisible) {
          parallelLinksAreVisible = false;
          removeAllParallelLinks(zoomLayer);
          link.style("display", null);
          linkHover.style("display", null);
        }
      });

    svg.call(zoomBehavior);

    const { link, linkHover, node, label, filteredLinks } = renderCoreDevices(
      zoomLayer,
      nodes,
      links,
      NODE_GROUPS,
      palette,
      onZoneClick,
      onNodeClick
    );

    // ... (rest of the rendering logic is unchanged)
    link.attr("stroke", palette.link);
    node.attr("fill", palette.node).attr("stroke", palette.stroke);
    label.attr("fill", palette.label);

    const tooltip = tooltipLayer
      .append("text")
      .attr("class", "svg-tooltip")
      .attr("x", 0)
      .attr("y", 0)
      .attr("text-anchor", "start")
      .attr("font-size", 14)
      .attr("fill", palette.label)
      .attr("opacity", 0)
      .style("pointer-events", "none")
      .style("user-select", "none");

    node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
    label.attr("x", (d) => d.x).attr("y", (d) => d.y);
    link
      .attr("x1", (d) => linkPositionFromEdges(d).x1)
      .attr("y1", (d) => linkPositionFromEdges(d).y1)
      .attr("x2", (d) => linkPositionFromEdges(d).x2)
      .attr("y2", (d) => linkPositionFromEdges(d).y2);
    linkHover
      .attr("x1", (d) => linkPositionFromEdges(d).x1)
      .attr("y1", (d) => linkPositionFromEdges(d).y1)
      .attr("x2", (d) => linkPositionFromEdges(d).x2)
      .attr("y2", (d) => linkPositionFromEdges(d).y2);

    if (nodes.length > 0) {
      // ... (initial transform calculation is unchanged) ...
      let minX = Infinity,
        maxX = -Infinity,
        minY = Infinity,
        maxY = -Infinity;
      nodes.forEach((n) => {
        if (n.x < minX) minX = n.x;
        if (n.x > maxX) maxX = n.x;
        if (n.y < minY) minY = n.y;
        if (n.y > maxY) maxY = n.y;
      });
      const dataWidth = maxX - minX;
      const dataHeight = maxY - minY;
      const dataCenterX = minX + dataWidth / 2;
      const dataCenterY = minY + dataHeight / 2;
      const zoomOutFactor = 0.9;
      const verticalScreenOffset = 0;
      const paddingFactor = 0.15;
      const padding = Math.min(width, height) * paddingFactor;
      const viewWidth = width - 2 * padding;
      const viewHeight = height - 2 * padding;
      let k = 1;
      if (dataWidth > 0 && dataHeight > 0) {
        k = Math.min(viewWidth / dataWidth, viewHeight / dataHeight);
      } else if (dataWidth > 0) {
        k = viewWidth / dataWidth;
      } else if (dataHeight > 0) {
        k = viewHeight / dataHeight;
      }
      k *= zoomOutFactor;
      const [minScale, maxScale] = zoomBehavior.scaleExtent();
      k = Math.max(minScale, Math.min(maxScale, k));
      let tx = width / 2 - dataCenterX * k;
      let ty = height / 2 - dataCenterY * k;
      ty += verticalScreenOffset;
      const initialTransform = d3.zoomIdentity.translate(tx, ty).scale(k);
      svg.call(zoomBehavior.transform, initialTransform);

      // +++ MODIFY THE INITIAL CHECK TO INCLUDE THE PROP
      if (k >= ZOOM_THRESHOLD || showDetailedLinks) {
        const event = { transform: initialTransform };
        zoomBehavior.on("zoom")(event);
      }
    } else {
      svg.call(zoomBehavior.transform, d3.zoomIdentity);
    }

    requestAnimationFrame(() =>
      setupInteractions({
        link,
        linkHover,
        filteredLinks,
        node,
        tooltip,
        palette,
        zoomLayer,
        onLinkClick,
      })
    );
  }, [onZoneClick, data, theme, onLinkClick, onNodeClick, showDetailedLinks]); // <<< Added prop to dependency array

  return (
    <div>
      <svg
        ref={svgRef}
        className="absolute top-0 left-0 w-full h-full bg-white dark:bg-gray-800"
      />
    </div>
  );
};

export default NetworkVisualizer;

--- File: src\components\chart\NetworkVisualizer5.jsx ---
import React, { useEffect, useRef } from "react";
import * as d3 from "d3";
import { linkPositionFromEdges, getNodeGroups } from "./drawHelpers";
import { renderCoreDevices } from "./renderCoreDevices";
import {
  setupInteractions,
  drawAllParallelLinks,
  removeAllParallelLinks,
} from "./handleInteractions";

// +++ ADD `showDetailedLinks` TO THE PROPS
const NetworkVisualizer5 = ({
  theme,
  data,
  showDetailedLinks,
  onZoneClick,
  onLinkClick,
  onNodeClick,
}) => {
  const svgRef = useRef();

  // +++ ADD `showDetailedLinks` TO THE DEPENDENCY ARRAY
  useEffect(() => {
    const svgElement = svgRef.current;
    if (!svgElement) return;

    const width = svgElement.clientWidth || window.innerWidth;
    const height = svgElement.clientHeight || window.innerHeight;

    // ... (rest of the initial setup logic is unchanged)
    const nodes = structuredClone(data.nodes || []);
    const links = structuredClone(data.links || []);

    if (nodes.length === 0) {
      d3.select(svgElement).selectAll("*").remove();
      return;
    }

    // ... (palette and node/link processing is unchanged)
    const NODE_GROUPS = getNodeGroups(nodes);

    const nodeMap = {};
    NODE_GROUPS.forEach((zone) => {
      const zoneNodes = nodes.filter((n) => n.zone === zone.id);
      const baseAngle = zone.angle;
      const perp = baseAngle + Math.PI / 2;
      const spacing = 140;
      zoneNodes.forEach((n, i) => {
        const offset = (i - (zoneNodes.length - 1) / 2) * spacing;
        n.x = zone.cx + offset * Math.cos(perp);
        n.y = zone.cy + offset * Math.sin(perp);
        nodeMap[n.id] = n;
      });
    });
    links.forEach((l) => {
      l.source = nodeMap[l.source];
      l.target = nodeMap[l.target];
    });

    const isDark = theme === "dark";

    const palette = {
      bg: isDark ? "#1f2937" : "#ffffff",
      link: isDark ? "#94a3b8" : "#6b7280",
      node: isDark ? "#29c6e0" : "#29c6e0",
      nodeHoverDirect: isDark ? "#1d9bb4" : "#22b8d4",
      stroke: isDark ? "#60a5fa" : "#1d4ed8",
      label: isDark ? "#ffffff" : "#1f2937",
      zone: {
        fill: isDark ? "#38bdf8" : "#7dd3fc",
        opacity: isDark ? 0.12 : 0.25,
        hoverFill: isDark ? "#7dd3fc" : "#bae6fd",
        hoverOpacity: isDark ? 0.25 : 0.4,
      },
      nodeHoverLink: isDark ? "#fde68a" : "#fef08a",
      nodeHoverLinkStroke: isDark ? "#facc15" : "#f59e0b",
      status: {
        up: isDark ? "#4ade80" : "#22c55e",
        down: isDark ? "#f87171" : "#ef4444",
        issue: isDark ? "#facc15" : "#f59e0b",
      },
    };

    const svg = d3
      .select(svgElement)
      .attr("width", width)
      .attr("height", height)
      .style("background-color", palette.bg);

    svg.selectAll("*").remove();
    const zoomLayer = svg.append("g").attr("class", "main-zoom-layer");
    const tooltipLayer = svg.append("g").attr("class", "tooltip-layer-group");

    const ZOOM_THRESHOLD = 1.5;
    let parallelLinksAreVisible = false;

    const zoomBehavior = d3
      .zoom()
      .scaleExtent([0.05, 8])
      .on("zoom", (event) => {
        const { transform } = event;
        zoomLayer.attr("transform", transform);

        // +++ MODIFY THE CONDITION TO INCLUDE THE PROP
        const shouldShowDetailed =
          transform.k >= ZOOM_THRESHOLD || showDetailedLinks;

        if (shouldShowDetailed && !parallelLinksAreVisible) {
          parallelLinksAreVisible = true;
          link.style("display", "none");
          linkHover.style("display", "none");
          drawAllParallelLinks({
            zoomLayer,
            allNodes: node.data(),
            filteredLinks,
            tooltip,
            palette,
            onLinkClick,
            linkSelection: link,
          });
        } else if (!shouldShowDetailed && parallelLinksAreVisible) {
          parallelLinksAreVisible = false;
          removeAllParallelLinks(zoomLayer);
          link.style("display", null);
          linkHover.style("display", null);
        }
      });

    svg.call(zoomBehavior);

    const { link, linkHover, node, label, filteredLinks } = renderCoreDevices(
      zoomLayer,
      nodes,
      links,
      NODE_GROUPS,
      palette,
      onZoneClick,
      onNodeClick
    );

    // ... (rest of the rendering logic is unchanged)
    link.attr("stroke", palette.link);
    node.attr("fill", palette.node).attr("stroke", palette.stroke);
    label.attr("fill", palette.label);

    const tooltip = tooltipLayer
      .append("text")
      .attr("class", "svg-tooltip")
      .attr("x", 0)
      .attr("y", 0)
      .attr("text-anchor", "start")
      .attr("font-size", 14)
      .attr("fill", palette.label)
      .attr("opacity", 0)
      .style("pointer-events", "none")
      .style("user-select", "none");

    node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
    label.attr("x", (d) => d.x).attr("y", (d) => d.y);
    link
      .attr("x1", (d) => linkPositionFromEdges(d).x1)
      .attr("y1", (d) => linkPositionFromEdges(d).y1)
      .attr("x2", (d) => linkPositionFromEdges(d).x2)
      .attr("y2", (d) => linkPositionFromEdges(d).y2);
    linkHover
      .attr("x1", (d) => linkPositionFromEdges(d).x1)
      .attr("y1", (d) => linkPositionFromEdges(d).y1)
      .attr("x2", (d) => linkPositionFromEdges(d).x2)
      .attr("y2", (d) => linkPositionFromEdges(d).y2);

    if (nodes.length > 0) {
      // ... (initial transform calculation is unchanged) ...
      let minX = Infinity,
        maxX = -Infinity,
        minY = Infinity,
        maxY = -Infinity;
      nodes.forEach((n) => {
        if (n.x < minX) minX = n.x;
        if (n.x > maxX) maxX = n.x;
        if (n.y < minY) minY = n.y;
        if (n.y > maxY) maxY = n.y;
      });
      const dataWidth = maxX - minX;
      const dataHeight = maxY - minY;
      const dataCenterX = minX + dataWidth / 2;
      const dataCenterY = minY + dataHeight / 2;
      const zoomOutFactor = 0.9;
      const verticalScreenOffset = 9;
      const paddingFactor = 0.15;
      const padding = Math.min(width, height) * paddingFactor;
      const viewWidth = width - 2 * padding;
      const viewHeight = height - 2 * padding;
      let k = 1;
      if (dataWidth > 0 && dataHeight > 0) {
        k = Math.min(viewWidth / dataWidth, viewHeight / dataHeight);
      } else if (dataWidth > 0) {
        k = viewWidth / dataWidth;
      } else if (dataHeight > 0) {
        k = viewHeight / dataHeight;
      }
      k *= zoomOutFactor;
      const [minScale, maxScale] = zoomBehavior.scaleExtent();
      k = Math.max(minScale, Math.min(maxScale, k));
      let tx = width / 2 - dataCenterX * k;
      let ty = height / 2 - dataCenterY * k;
      ty += verticalScreenOffset;
      const initialTransform = d3.zoomIdentity.translate(tx, ty).scale(k);
      svg.call(zoomBehavior.transform, initialTransform);

      // +++ MODIFY THE INITIAL CHECK TO INCLUDE THE PROP
      if (k >= ZOOM_THRESHOLD || showDetailedLinks) {
        const event = { transform: initialTransform };
        zoomBehavior.on("zoom")(event);
      }
    } else {
      svg.call(zoomBehavior.transform, d3.zoomIdentity);
    }

    requestAnimationFrame(() =>
      setupInteractions({
        link,
        linkHover,
        filteredLinks,
        node,
        tooltip,
        palette,
        zoomLayer,
        onLinkClick,
      })
    );
  }, [onZoneClick, data, theme, onLinkClick, onNodeClick, showDetailedLinks]); // <<< Added prop to dependency array

  return (
    <svg
      ref={svgRef}
      className="absolute top-0 left-0 w-full h-full bg-white dark:bg-gray-800"
    />
  );
};

export default NetworkVisualizer5;

--- File: src\components\chart\renderCoreDevices.jsx ---
// src/renderCoreDevices.js
import * as d3 from "d3";

export function renderCoreDevices(
  zoomLayer,
  nodes,
  links,
  NODE_GROUPS,
  palette, // palette will be passed from NetworkVisualizer.js / NetworkVisualizer5.js
  onZoneClick,
  onNodeClick
) {
  // Define default zone fill and opacity (can be overridden by palette if provided)
  const defaultZoneFill = palette.zone?.fill || "#38bdf8";
  const defaultZoneOpacity = palette.zone?.opacity || 0.12;
  const hoverZoneFill = palette.zone?.hoverFill || defaultZoneFill; // Use same fill if not specified
  const hoverZoneOpacity =
    palette.zone?.hoverOpacity || defaultZoneOpacity + 0.15; // Slightly more opaque

  zoomLayer
    .append("g")
    .selectAll("g.zone-group")
    .data(NODE_GROUPS)
    .join("g")
    .attr("class", "zone-group")
    .each(function (d_zone_group_data) {
      // Renamed 'd' to be more specific
      const screenCenterY = window.innerHeight / 2;

      // Draw the zone circle
      d3.select(this)
        .append("circle")
        .attr("class", "zone")
        .attr("r", 150)
        .attr("cx", d_zone_group_data.cx)
        .attr("cy", d_zone_group_data.cy)
        .attr("fill", defaultZoneFill) // Use defaultZoneFill from palette or fallback
        .attr("fill-opacity", defaultZoneOpacity) // Use defaultZoneOpacity
        .style("cursor", "pointer")
        .on("click", (_event, d_clicked_zone) => {
          // d_clicked_zone is the datum of the CIRCLE, which is d_zone_group_data
          // console.log("[renderCoreDevices] Zone clicked in D3. Zone data:",d_clicked_zone);
          // console.log("[renderCoreDevices] Is onZoneClick prop available? Type:", typeof onZoneClick);
          if (onZoneClick) {
            // console.log("[renderCoreDevices] Calling onZoneClick with ID:", d_clicked_zone.id);
            onZoneClick(d_clicked_zone.id);
          } else {
            // console.error("[renderCoreDevices] onZoneClick is NOT defined here!");
          }
        })
        .on("mouseover", function () {
          // 'this' refers to the circle element
          d3.select(this)
            .transition()
            .duration(150) // Smooth transition
            .attr("fill", hoverZoneFill)
            .attr("fill-opacity", hoverZoneOpacity);
        })
        .on("mouseout", function () {
          d3.select(this)
            .transition()
            .duration(150)
            .attr("fill", defaultZoneFill)
            .attr("fill-opacity", defaultZoneOpacity);
        });

      // Determine label offset
      const labelOffset = d_zone_group_data.cy < screenCenterY ? -160 : 180;

      // Draw the zone label
      d3.select(this)
        .append("text")
        .attr("x", d_zone_group_data.cx)
        .attr("y", d_zone_group_data.cy + labelOffset)
        .text(d_zone_group_data.id)
        .attr("fill", palette.label)
        .attr("font-size", "18px")
        .attr("text-anchor", "middle")
        .attr("font-weight", "bold")
        .style("pointer-events", "none");
    });

  const filteredLinks = links;
  const linkGroup = zoomLayer.append("g");

  // ... (rest of the link, node, label rendering remains the same) ...
  const link = linkGroup
    .selectAll("line.visible-link")
    .data(filteredLinks)
    .join("line")
    .attr("class", "visible-link")
    .attr("stroke", palette.link)
    .attr("stroke-opacity", 0.6)
    .attr("stroke-width", 2);

  const linkHover = linkGroup
    .selectAll("line.link-hover")
    .data(filteredLinks)
    .join("line")
    .attr("class", "link-hover")
    .attr("stroke", "transparent")
    .attr("stroke-width", 20)
    .style("cursor", "pointer");

  const node = zoomLayer
    .append("g")
    .selectAll("circle.node")
    .data(nodes)
    .join("circle")
    .attr("class", "node")
    .attr("r", 60)
    .attr("fill", palette.node)
    .attr("stroke", palette.stroke)
    .attr("stroke-width", 2)
    .style("opacity", 0.9)
    .style("cursor", "pointer")
    .on("mouseover", function () {
      const selection = d3.select(this);
      if (selection.attr("fill") !== "#fde68a") {
        // Assuming #fde68a is link hover color
        selection.attr("fill", palette.nodeHoverDirect);
      }
    })
    .on("mouseout", function () {
      const selection = d3.select(this);
      if (selection.attr("fill") === palette.nodeHoverDirect) {
        selection.attr("fill", palette.node);
      }
    })
    .on("click", function (event, d_node) {
      // console.log("Node clicked:", d_node.id, "Zone:", d_node.zone);
      event.stopPropagation();
      if (onNodeClick) {
        onNodeClick(d_node); // d_node should have id and zone
      }
    });

  const label = zoomLayer
    .append("g")
    .selectAll("text.label")
    .data(nodes)
    .join("text")
    .attr("class", "label")
    .text((d) => d.id)
    .attr("fill", palette.label)
    .attr("font-size", "18px")
    //.attr("font-weight", "bold") // Adds boldness
    .attr("text-anchor", "middle")
    .attr("dy", ".35em")
    .style("pointer-events", "none")
    .style("cursor", "default");

  return { link, linkHover, node, label, filteredLinks };
}

--- File: src\components\chart\ToggleDetailButton.jsx ---
// src/chart/ToggleDetailButton.js
import React from "react";

const ToggleDetailButton = ({ isDetailed, onToggle, theme }) => {
  const isDark = theme === "dark";

  const baseClasses =
    "absolute top-4 right-4 z-10 px-4 py-2 text-sm font-semibold rounded-md shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 transition-colors";
  const lightThemeClasses =
    "bg-white text-gray-700 hover:bg-gray-100 focus:ring-blue-500";
  const darkThemeClasses =
    "bg-gray-700 text-gray-200 hover:bg-gray-600 focus:ring-blue-400 focus:ring-offset-gray-800";

  const buttonText = isDetailed ? "Show Summary View" : "Show Detailed Links";

  return (
    <button
      onClick={onToggle}
      className={`${baseClasses} ${
        isDark ? darkThemeClasses : lightThemeClasses
      }`}
      aria-live="polite"
    >
      {buttonText}
    </button>
  );
};

export default ToggleDetailButton;

--- File: src\components\CoreDevice\LineDetailExtend.jsx ---
// LinkDetailRow.jsx
import React from "react";

const LinkDetailRow = ({ link, isParentSelectedAndDark }) => {
  // --- Check 1: Does the link object exist at all? ---
  // This should ideally be handled before even calling LinkDetailRow,
  // but a defensive check here is okay.
  if (!link) {
    // This case should ideally not happen if LinkTable filters correctly
    // or if the link object is guaranteed to exist when this component is rendered.
    return (
      <td colSpan="6" className="relative -left-[4px]">
        <div
          className={`p-4 bg-gray-100 dark:bg-gray-700 text-sm text-gray-500 dark:text-gray-400`}
        >
          Error: Link data missing.
        </div>
      </td>
    );
  }

  // --- Check 2: Determine if there's any content to display ---
  const hasAdditionalDetails =
    link.additionalDetails &&
    typeof link.additionalDetails === "object" &&
    Object.keys(link.additionalDetails).length > 0;
  const hasRelevantIssueType =
    (link.status === "issue" || link.status === "down") &&
    typeof link.issueType === "string" &&
    link.issueType.trim() !== "";

  const tdClasses = `relative -left-[4px]`;

  const detailRowBackground = isParentSelectedAndDark
    ? "bg-slate-700"
    : "bg-slate-100";
  const valueTextColorForNoDetails = isParentSelectedAndDark
    ? "text-slate-400"
    : "text-slate-600";

  if (!hasAdditionalDetails && !hasRelevantIssueType) {
    return (
      <td colSpan="6" className={tdClasses}>
        <div
          className={`p-4 ${detailRowBackground} text-sm ${valueTextColorForNoDetails}`}
        >
          No specific details available for this link.
        </div>
      </td>
    );
  }

  // --- Proceed if there is content to display ---
  const {
    mediaType = "N/A",
    cdpNeighbors = "N/A",
    containerName = "N/A",
    mtu = "N/A",
    crcErrors = "N/A",
    inputDataRate = "N/A",
    outputDataRate = "N/A",
    txPower = "N/A",
    rxPower = "N/A",
  } = link.additionalDetails || {}; // Default to empty object if additionalDetails is null/undefined

  const issueType = link.issueType || null; // Use null if not present, will be handled by hasRelevantIssueType

  const labelTextColor = isParentSelectedAndDark
    ? "text-slate-300"
    : "text-slate-700";
  const valueTextColor = isParentSelectedAndDark
    ? "text-slate-400"
    : "text-slate-600";
  const issueLabelColor = isParentSelectedAndDark
    ? "text-red-400"
    : "text-red-500";
  const issueValueColor = isParentSelectedAndDark
    ? "text-red-400 font-semibold"
    : "text-red-500 font-semibold";
  const borderColor = isParentSelectedAndDark
    ? "border-slate-600"
    : "border-slate-300";
  const detailItemClass = "py-1";

  return (
    <td colSpan="6" className={tdClasses}>
      <div
        className={`p-4 ${detailRowBackground} transition-colors duration-150`}
      >
        {hasRelevantIssueType &&
          issueType && ( // issueType check is redundant due to hasRelevantIssueType but harmless
            <div
              className={`${detailItemClass} mb-3 border-b ${borderColor} pb-2`}
            >
              <span className={`font-medium ${issueLabelColor}`}>
                Issue Type:
              </span>{" "}
              <span className={issueValueColor}>{issueType}</span>
            </div>
          )}
        {hasAdditionalDetails && (
          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-x-4 gap-y-2 text-sm">
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>
                Media Type:
              </span>{" "}
              <span className={valueTextColor}>{mediaType}</span>
            </div>
            {/* ... other detail items ... */}
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>
                CDP Neighbors:
              </span>{" "}
              <span className={valueTextColor}>{cdpNeighbors}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>
                Container:
              </span>{" "}
              <span className={valueTextColor}>{containerName}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>MTU:</span>{" "}
              <span className={valueTextColor}>{mtu}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>
                CRC Errors:
              </span>{" "}
              <span className={valueTextColor}>{crcErrors}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>
                Input Rate:
              </span>{" "}
              <span className={valueTextColor}>{inputDataRate}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>
                Output Rate:
              </span>{" "}
              <span className={valueTextColor}>{outputDataRate}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>Tx Power:</span>{" "}
              <span className={valueTextColor}>{txPower}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>Rx Power:</span>{" "}
              <span className={valueTextColor}>{rxPower}</span>
            </div>
          </div>
        )}
      </div>
    </td>
  );
};

export default LinkDetailRow;

--- File: src\components\CoreDevice\LinkTable.jsx ---
// LinkTable.jsx
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import LinkDetailRow from "./LineDetailExtend";

const StatusBulb = ({ status }) => {
  let bgColor = "bg-gray-400 dark:bg-gray-500";
  let title = "Unknown";
  if (status === "up") {
    bgColor = "bg-green-500 dark:bg-green-400";
    title = "Up";
  } else if (status === "down") {
    bgColor = "bg-red-500 dark:bg-red-400";
    title = "Down";
  } else if (status === "issue") {
    bgColor = "bg-yellow-500 dark:bg-yellow-400";
    title = "Issue";
  }
  return (
    <div
      className={`w-4 h-4 rounded-full ${bgColor} flex-shrink-0`}
      title={title}
    ></div>
  );
};

const LinkTable = ({
  coreDeviceName,
  coreSiteName = "Unknown Site",
  linksData = [],
  otherDevicesInZone = [],
  theme = "dark",
}) => {
  const navigate = useNavigate();

  const [linkTypeFilter, setLinkTypeFilter] = useState("all");
  const [statusFilter, setStatusFilter] = useState("all");
  const [filteredLinks, setFilteredLinks] = useState(linksData);
  const [expandedLinkId, setExpandedLinkId] = useState(null);

  useEffect(() => {
    let currentLinks = [...linksData];
    if (linkTypeFilter !== "all") {
      currentLinks = currentLinks.filter(
        (link) => link && link.type === linkTypeFilter
      );
    }
    if (statusFilter === "issue") {
      const problemLinks = currentLinks.filter(
        (link) => link && (link.status === "down" || link.status === "issue")
      );
      problemLinks.sort((a, b) => {
        if (a.status === "down" && b.status !== "down") return -1;
        if (a.status !== "down" && b.status === "down") return 1;
        return 0;
      });
      currentLinks = problemLinks;
    } else if (statusFilter !== "all") {
      currentLinks = currentLinks.filter(
        (link) => link && link.status === statusFilter
      );
    }
    setFilteredLinks(currentLinks);
  }, [linksData, linkTypeFilter, statusFilter]);

  const isDark = theme === "dark";

  const handleLinkRowClick = (linkId) => {
    setExpandedLinkId((prevId) => (prevId === linkId ? null : linkId));
  };

  const handleDeviceButtonClick = (device) => {
    navigate(`/l-chart/zone/${device.zoneName}/node/${device.hostname}`);
  };

  const actionButtonBaseClasses =
    "ml-2 font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-opacity-50";
  const actionButtonSizeClasses = "px-4 py-1.5 text-sm";
  const lightActionButtonClasses =
    "bg-blue-100 hover:bg-blue-200 text-blue-700 focus:ring-blue-500";
  const darkActionButtonClasses =
    "bg-blue-700 hover:bg-blue-600 text-blue-100 focus:ring-blue-400";

  return (
    // [THE FIX] - The root div now has `min-h-full` to ensure it stretches to fill the viewport,
    // which allows its parent's scrollbar to activate when this component's content is too tall.
    <div className="min-h-full">
      <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg transition-colors duration-300">
        <div className="border-b border-gray-200 dark:border-gray-700 pb-4 mb-4">
          <h1 className="text-3xl font-bold text-gray-900 dark:text-gray-100">
            {coreSiteName}
          </h1>
          <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
            Core Site Device Details
          </p>
        </div>
        <div className="flex justify-between items-center mb-6">
          <div className="flex items-center">
            <h2 className="text-2xl font-semibold text-gray-800 dark:text-gray-100 mr-2">
              Links for: {coreDeviceName || "N/A"}
            </h2>
            {otherDevicesInZone.length > 0 &&
              otherDevicesInZone.map((device) => (
                <button
                  key={device.id}
                  onClick={() => handleDeviceButtonClick(device)}
                  className={`${actionButtonBaseClasses} ${actionButtonSizeClasses} ${
                    isDark ? darkActionButtonClasses : lightActionButtonClasses
                  }`}
                  aria-label={`View details for ${device.hostname}`}
                  title={`View details for ${device.hostname}`}
                >
                  {device.hostname}
                </button>
              ))}
          </div>
        </div>

        <div className="mb-6 grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div>
            <label
              htmlFor="linkTypeFilter"
              className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
            >
              Filter by Link Type:
            </label>
            <select
              id="linkTypeFilter"
              value={linkTypeFilter}
              onChange={(e) => setLinkTypeFilter(e.target.value)}
              className="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-blue-500 focus:border-blue-500"
            >
              <option value="all">All Link Types</option>
              <option value="core-to-site">Core to Site</option>
              <option value="inter-core-different-site">
                Inter-Core (Different Site)
              </option>
              <option value="inter-core-same-site">
                Inter-Core (Same Site)
              </option>
            </select>
          </div>
          <div>
            <label
              htmlFor="statusFilter"
              className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
            >
              Filter by Status:
            </label>
            <select
              id="statusFilter"
              value={statusFilter}
              onChange={(e) => setStatusFilter(e.target.value)}
              className="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-blue-500 focus:border-blue-500"
            >
              <option value="all">All Statuses</option>
              <option value="up">Up</option>
              <option value="down">Down</option>
              <option value="issue">Issue</option>
            </select>
          </div>
        </div>

        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700 border-collapse">
            <thead className="bg-gray-50 dark:bg-gray-700">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  Status
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  Description
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  Name
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  OSPF
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  MPLS
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                  Bandwidth
                </th>
              </tr>
            </thead>
            <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
              {filteredLinks && filteredLinks.length > 0 ? (
                filteredLinks.flatMap((link) => {
                  if (!link || typeof link.id === "undefined") {
                    console.warn(
                      "Encountered an invalid link object in LinkTable:",
                      link
                    );
                    return null;
                  }
                  const isSelected = expandedLinkId === link.id;
                  const selectedRowBg = isDark
                    ? "bg-slate-700"
                    : "bg-slate-100";
                  return (
                    <React.Fragment key={link.id}>
                      <tr
                        className={`hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer transition-colors ${
                          isSelected ? selectedRowBg : ""
                        }`}
                        onClick={() => handleLinkRowClick(link.id)}
                      >
                        <td className="px-6 py-4 whitespace-nowrap">
                          <StatusBulb status={link.status} />
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700 dark:text-gray-300">
                          {link.description}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900 dark:text-gray-100">
                          {link.name}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700 dark:text-gray-300">
                          {link.ospfStatus || "N/A"}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700 dark:text-gray-300">
                          {link.mplsStatus || "N/A"}
                        </td>
                        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700 dark:text-gray-300">
                          {link.bandwidth}
                        </td>
                      </tr>
                      {isSelected && (
                        <tr className="border-l-4 border-blue-500 dark:border-blue-400">
                          <LinkDetailRow
                            link={link}
                            isParentSelectedAndDark={isDark}
                          />
                        </tr>
                      )}
                    </React.Fragment>
                  );
                })
              ) : (
                <tr>
                  <td
                    colSpan="6"
                    className="px-6 py-12 text-center text-sm text-gray-500 dark:text-gray-400"
                  >
                    No links match filters.
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
        {linksData.length > 0 && filteredLinks.length === 0 && (
          <p className="mt-4 text-center text-sm text-gray-500 dark:text-gray-400">
            No links match the current filters. Try adjusting your selection.
          </p>
        )}
        {linksData.length === 0 && (
          <p className="mt-4 text-center text-sm text-gray-500 dark:text-gray-400">
            No link data provided.
          </p>
        )}
      </div>
    </div>
  );
};

export default LinkTable;

--- File: src\components\CoreSite\CoreSiteCanvas.jsx ---
// src/components/CoreSite/CoreSiteCanvas.jsx
import React, { useEffect, useMemo } from "react";
import { drawCoreSiteChart } from "./d3CoreSiteRenderer";

export default function CoreSiteCanvas({
  svgRef,
  focusedNodeDataRef,
  focusedNodeId,
  nodes,
  links,
  centerX,
  centerY,
  width,
  height,
  theme = "dark",
  onLinkClick,
  onNodeClick,
}) {
  const themeColors = useMemo(() => {
    return {
      bgColor: theme === "dark" ? "#1f2937" : "#ffffff",
      zoneCircleFill: theme === "dark" ? "#38bdf8" : "#bae6fd",
      zoneCircleOpacity: theme === "dark" ? 0.12 : 0.4,
      linkStroke: theme === "dark" ? "#94a3b8" : "#cbd5e1",
      linkStrokeOpacity: 0.6,
      linkHoverStroke: "#f59e0b", // Used for link line itself on hover
      nodeFill: theme === "dark" ? "#29c6e0" : "#67e8f9", // Original node blue
      nodeStroke: theme === "dark" ? "#60a5fa" : "#7dd3fc",
      nodeTextFill: theme === "dark" ? "#ffffff" : "#155e75",
      nodeHoverFill: theme === "dark" ? "#fde68a" : "#fef08a", // Yellowish, used when a LINK is hovered, for connected nodes
      nodeHoverStroke: "#f59e0b", // Yellowish stroke, used when a LINK is hovered
      selectedNodePulseColor: theme === "dark" ? "#2563eb" : "#3b82f6",
      // --- NEW COLOR FOR DIRECT NODE HOVER ---
      nodeHighlightFill: theme === "dark" ? "#1d9bb4" : "#4cb9d8", // Darker blue for direct node hover
    };
  }, [theme]);

  useEffect(() => {
    // ... (rest of the useEffect remains the same)
    console.log(
      "[CoreSiteCanvas useEffect] Nodes:",
      nodes ? nodes.map((n) => n.id).join(", ") : "undefined",
      "Links count:",
      links ? links.length : "undefined"
    );
    console.log(
      "[CoreSiteCanvas useEffect] Width:",
      width,
      "Height:",
      height,
      "FocusedNodeId:",
      focusedNodeId
    );

    if (!svgRef.current || width === 0 || height === 0 || !nodes || !links) {
      console.log(
        "[CoreSiteCanvas useEffect] Skipping drawCoreSiteChart due to missing refs, dimensions, or data."
      );
      return;
    }

    console.log("[CoreSiteCanvas useEffect] Calling drawCoreSiteChart.");

    drawCoreSiteChart(svgRef.current, {
      nodesData: nodes,
      linksData: links,
      focusedNodeId,
      width,
      height,
      centerX,
      centerY,
      themeColors,
      onLinkClickCallback: onLinkClick,
      onNodeClickCallback: onNodeClick,
    });

    if (focusedNodeDataRef && nodes && nodes.length > 0 && focusedNodeId) {
      const foundNode = nodes.find((n) => n.id === focusedNodeId);
      focusedNodeDataRef.current = foundNode || null;
      if (!foundNode) {
        console.warn(
          `[CoreSiteCanvas] Node ${focusedNodeId} not found in nodes data`
        );
      }
    } else if (focusedNodeDataRef) {
      focusedNodeDataRef.current = null;
    }
  }, [
    svgRef,
    nodes,
    links,
    focusedNodeId,
    width,
    height,
    centerX,
    centerY,
    themeColors,
    onLinkClick,
    focusedNodeDataRef,
    onNodeClick,
  ]);

  return null;
}

--- File: src\components\CoreSite\CoreSiteControls.jsx ---
import React from "react";

export default function CoreSiteControls({
  theme,
  displayZoneId,
  onToggleExtendedNodes,
  showExtendedNodes,
  devicesInZoneCount,
}) {
  // --- Style Definitions ---
  const conditionalButtonBg =
    theme === "dark"
      ? "bg-indigo-600 hover:bg-indigo-700"
      : "bg-indigo-500 hover:bg-indigo-600";
  const conditionalButtonText = "text-white";
  const conditionalButtonFocusRing =
    theme === "dark"
      ? "focus:ring-indigo-400 focus:ring-offset-gray-800"
      : "focus:ring-indigo-500 focus:ring-offset-white";

  const zoneTitleColor = theme === "dark" ? "text-white" : "text-sky-800";

  // --- Dynamic Visibility & Text ---
  // The button is visible only if there are more than 4 devices, allowing for a second "page" of nodes.
  const isConditionalButtonVisible = devicesInZoneCount > 4;

  const conditionalButtonActualText = showExtendedNodes
    ? "Show First 4 Devices"
    : "Show More Devices";

  return (
    <div
      className="absolute flex flex-col items-center z-30 pointer-events-none"
      style={{
        left: `50%`,
        top: `1rem`,
        transform: "translateX(-50%)",
        width: "max-content", // Prevent wrapping on smaller screens
      }}
    >
      <div
        className={`mb-2 text-lg font-bold ${zoneTitleColor} pointer-events-auto`}
      >
        {displayZoneId}
      </div>

      {isConditionalButtonVisible && (
        <button
          type="button"
          onClick={onToggleExtendedNodes}
          className={`mb-3 px-4 py-2 rounded-md text-sm font-semibold shadow-sm 
                      focus:outline-none focus:ring-2 focus:ring-opacity-75
                      pointer-events-auto
                      ${conditionalButtonBg} ${conditionalButtonText}
                      ${conditionalButtonFocusRing}`}
        >
          {conditionalButtonActualText}
        </button>
      )}
    </div>
  );
}

--- File: src\components\CoreSite\CoreSitePage.jsx ---
// src/components/CoreSite/CoreSitePage.jsx
import React from "react";
import { useCoreSiteData } from "./useCoreSiteData";
import CoreSiteView from "./CoreSiteView";

export default function CoreSitePage({ theme = "dark", chartType }) {
  const {
    zoneId,
    containerRef,
    dimensions,
    nodes,
    links,
    centerX,
    centerY,
    selectedNodeId,
    showExtendedNodes,
    handleToggleExtendedNodes,
    sitesForFocusedNode,
    onSiteClick,
    onLinkClick,
    onNodeClickInZone,
    devicesInZoneCount,
    openDetailTabs,
    activeDetailTabId,
    setActiveDetailTabId,
    handleCloseTab,
    handleNavigateToSite,
  } = useCoreSiteData(chartType);

  return (
    <CoreSiteView
      theme={theme}
      zoneId={zoneId}
      containerRef={containerRef}
      dimensions={dimensions}
      nodes={nodes}
      links={links}
      centerX={centerX}
      centerY={centerY}
      selectedNodeId={selectedNodeId}
      showExtendedNodes={showExtendedNodes}
      onToggleExtendedNodes={handleToggleExtendedNodes}
      sites={sitesForFocusedNode}
      onSiteClick={onSiteClick}
      onLinkClick={onLinkClick}
      onNodeClick={onNodeClickInZone}
      devicesInZoneCount={devicesInZoneCount}
      openDetailTabs={openDetailTabs}
      activeDetailTabId={activeDetailTabId}
      onSetActiveTab={setActiveDetailTabId}
      onCloseTab={handleCloseTab}
      onNavigateToSite={handleNavigateToSite}
    />
  );
}

--- File: src\components\CoreSite\CoreSiteView.jsx ---
// src/components/CoreSite/CoreSiteView.jsx

import React, { useRef } from "react";
import CoreSiteCanvas from "./CoreSiteCanvas";
import SitesBar from "./SitesBar";
import LinkDetailTabs from "../shared/LinkDetailTabs"; // Import the tab component
import CoreSiteControls from "./CoreSiteControls";

export default function CoreSiteView({
  theme,
  zoneId,
  containerRef,
  dimensions,
  nodes,
  links,
  centerX,
  centerY,
  selectedNodeId,
  showExtendedNodes,
  onToggleExtendedNodes,
  sites,
  onSiteClick,
  onLinkClick,
  onNodeClick,
  devicesInZoneCount,
  openDetailTabs,
  activeDetailTabId,
  onSetActiveTab,
  onCloseTab,
  onNavigateToSite,
}) {
  const svgRef = useRef(null);
  const siteRefs = useRef([]);
  const focusedNodeDataRef = useRef(null);

  // --- Style constants for theme-awareness ---
  const pageBgColor = theme === "dark" ? "bg-gray-800" : "bg-white";
  const loadingBgColor = theme === "dark" ? "bg-slate-800" : "bg-gray-100";
  const loadingTextColor = theme === "dark" ? "text-white" : "text-gray-700";

  // --- Loading State ---
  if (dimensions.width === 0 || dimensions.height === 0) {
    return (
      <div
        ref={containerRef}
        className={`w-full h-full ${loadingBgColor} ${loadingTextColor} flex items-center justify-center`}
      >
        Loading dimensions...
      </div>
    );
  }

  // --- Dynamic positioning for Back button ---
  const displayZoneId = zoneId
    ? zoneId.startsWith("Zone ")
      ? zoneId
      : `Zone ${zoneId}`
    : "Central Zone";

  return (
    // UPDATED LAYOUT: Use flexbox column to stack the tab bar and the main content area.
    <div
      ref={containerRef}
      className={`w-full h-full ${pageBgColor} flex flex-col overflow-hidden`}
    >
      {/* 1. RENDER TABS AT THE TOP if they exist */}
      {openDetailTabs && openDetailTabs.length > 0 && (
        <div className="flex-shrink-0">
          <LinkDetailTabs
            tabs={openDetailTabs}
            activeTabId={activeDetailTabId}
            onSetActiveTab={onSetActiveTab}
            onCloseTab={onCloseTab}
            onNavigateToSite={onNavigateToSite}
            theme={theme}
          />
        </div>
      )}

      {/* 2. Main content area that grows to fill the remaining space */}
      <div className="flex-grow relative">
        {/* Back button and Controls are absolutely positioned within this main content area */}

        <CoreSiteControls
          theme={theme}
          displayZoneId={displayZoneId}
          zoneId={zoneId}
          showExtendedNodes={showExtendedNodes}
          onToggleExtendedNodes={onToggleExtendedNodes}
          devicesInZoneCount={devicesInZoneCount}
        />

        {/* The canvas and sites bar also live in this container and are sized relative to it */}
        <svg ref={svgRef} className="absolute top-0 left-0 w-full h-full z-0" />
        <CoreSiteCanvas
          svgRef={svgRef}
          focusedNodeDataRef={focusedNodeDataRef}
          focusedNodeId={selectedNodeId}
          nodes={nodes}
          links={links}
          centerX={centerX}
          centerY={centerY}
          width={dimensions.width}
          height={dimensions.height}
          theme={theme}
          onLinkClick={onLinkClick}
          onNodeClick={onNodeClick}
        />
        <SitesBar
          svgRef={svgRef}
          focusedNodeDataRef={focusedNodeDataRef}
          focusedNodeId={selectedNodeId}
          siteRefs={siteRefs}
          theme={theme}
          sites={sites}
          onSiteClick={onSiteClick}
        />
      </div>
    </div>
  );
}

--- File: src\components\CoreSite\d3CoreSiteRenderer.jsx ---
// src/components/CoreSite/d3CoreSiteRenderer.js
import * as d3 from "d3";
import { linkPositionFromEdges } from "./drawHelpers";

const ANIMATION_DURATION = 750; // ms
const PULSE_ANIMATION_NAME = "pulseEffect"; // For specifically stopping this animation

export function drawCoreSiteChart(
  svgElement,
  {
    nodesData,
    linksData,
    focusedNodeId,
    centerX,
    centerY,
    themeColors,
    onLinkClickCallback,
    onNodeClickCallback,
  }
) {
  const svg = d3.select(svgElement);
  let zoomLayer = svg.select("g.zoom-layer");

  if (zoomLayer.empty()) {
    svg.selectAll("*").remove();
    zoomLayer = svg.append("g").attr("class", "zoom-layer");

    zoomLayer
      .append("circle")
      .attr("class", "zone-visualization-circle")
      .attr("cx", centerX)
      .attr("cy", centerY)
      .attr("r", 150)
      .attr("fill", themeColors.zoneCircleFill)
      .attr("fill-opacity", themeColors.zoneCircleOpacity);

    // Create groups for drawing order - CORRECTED ORDER
    zoomLayer.append("g").attr("class", "links-group");
    zoomLayer.append("g").attr("class", "link-hover-group"); // MOVED UP
    zoomLayer.append("g").attr("class", "pulse-group");
    zoomLayer.append("g").attr("class", "nodes-group");
    zoomLayer.append("g").attr("class", "node-labels-group");
  }

  const pulseGroup = zoomLayer.select("g.pulse-group");
  const linksGroup = zoomLayer.select("g.links-group");
  const nodesGroup = zoomLayer.select("g.nodes-group");
  const linkHoverGroup = zoomLayer.select("g.link-hover-group");
  const nodeLabelsGroup = zoomLayer.select("g.node-labels-group");

  // --- Pulsing Circle for Selected Node ---
  const selectedNodeDataArray = focusedNodeId
    ? nodesData.filter((n) => n.id === focusedNodeId)
    : [];

  const pulseCircles = pulseGroup
    .selectAll("circle.node-pulse")
    .data(selectedNodeDataArray, (d) => d.id);

  pulseCircles
    .exit()
    .interrupt(PULSE_ANIMATION_NAME)
    .transition("pulseExit")
    .duration(ANIMATION_DURATION / 2)
    .attr("r", 0)
    .style("opacity", 0)
    .remove();

  const pulseEnter = pulseCircles
    .enter()
    .append("circle")
    .attr("class", "node-pulse")
    .attr("r", 0)
    .style("opacity", 0)
    .attr("fill", themeColors.selectedNodePulseColor)
    .attr("stroke", themeColors.selectedNodePulseColor)
    .attr("stroke-width", 2);

  pulseEnter
    .merge(pulseCircles)
    .interrupt(PULSE_ANIMATION_NAME)
    .attr("cx", (d) => d.x)
    .attr("cy", (d) => d.y)
    .transition("pulseMoveAppear")
    .duration(ANIMATION_DURATION)
    .attr("cx", (d) => d.x)
    .attr("cy", (d) => d.y)
    .attr("r", 60)
    .style("opacity", 0.7)
    .on("end.startPulseEffect", function (d) {
      const circle = d3.select(this);
      function continuousPulse() {
        if (circle.empty() || focusedNodeId !== d.id) {
          circle.interrupt(PULSE_ANIMATION_NAME);
          return;
        }
        circle
          .transition(PULSE_ANIMATION_NAME)
          .duration(1000)
          .attr("r", 60 + 10)
          .style("opacity", 0.3)
          .transition(PULSE_ANIMATION_NAME)
          .duration(1000)
          .attr("r", 60)
          .style("opacity", 0.7)
          .on("end.continuousPulse", continuousPulse);
      }
      continuousPulse();
    });

  // ----- Links -----
  const visibleLinks = linksGroup
    .selectAll("line.link")
    .data(linksData, (d) => d.id);

  visibleLinks
    .exit()
    .transition("linkExit")
    .duration(ANIMATION_DURATION / 2)
    .style("opacity", 0)
    .remove();

  visibleLinks
    .enter()
    .append("line")
    .attr("class", "link")
    .attr("x1", (d) =>
      d.source && nodesData.find((n) => n.id === d.source.id)
        ? linkPositionFromEdges(d, 60).x1
        : (d.source && d.source.x) || 0
    )
    .attr("y1", (d) =>
      d.source && nodesData.find((n) => n.id === d.source.id)
        ? linkPositionFromEdges(d, 60).y1
        : (d.source && d.source.y) || 0
    )
    .attr("x2", (d) =>
      d.target && nodesData.find((n) => n.id === d.target.id)
        ? linkPositionFromEdges(d, 60).x2
        : (d.target && d.target.x) || 0
    )
    .attr("y2", (d) =>
      d.target && nodesData.find((n) => n.id === d.target.id)
        ? linkPositionFromEdges(d, 60).y2
        : (d.target && d.target.y) || 0
    )
    .attr("stroke", themeColors.linkStroke)
    .style("opacity", 0)
    .merge(visibleLinks)
    .transition("linkUpdate")
    .duration(ANIMATION_DURATION)
    .attr("x1", (d) => linkPositionFromEdges(d, 60).x1)
    .attr("y1", (d) => linkPositionFromEdges(d, 60).y1)
    .attr("x2", (d) => linkPositionFromEdges(d, 60).x2)
    .attr("y2", (d) => linkPositionFromEdges(d, 60).y2)
    .style("opacity", themeColors.linkStrokeOpacity)
    .attr("stroke-width", 2);

  // ----- Nodes (Circles) -----
  const nodeCircles = nodesGroup
    .selectAll("circle.node")
    .data(nodesData, (d) => d.id);

  nodeCircles
    .exit()
    .transition("nodeExit")
    .duration(ANIMATION_DURATION / 2)
    .attr("r", 0)
    .style("opacity", 0)
    .remove();

  nodeCircles
    .enter()
    .append("circle")
    .attr("class", "node")
    .attr("cx", (d) => d.x)
    .attr("cy", (d) => d.y)
    .attr("r", 0)
    .style("opacity", 0)
    .merge(nodeCircles)
    .transition("nodeUpdate")
    .duration(ANIMATION_DURATION)
    .attr("cx", (d) => d.x)
    .attr("cy", (d) => d.y)
    .attr("r", 60)
    .style("opacity", 1)
    .attr("fill", themeColors.nodeFill)
    .attr("stroke", (d) =>
      d.id === focusedNodeId
        ? themeColors.selectedNodePulseColor
        : themeColors.nodeStroke
    )
    .attr("stroke-width", (d) => (d.id === focusedNodeId ? 3 : 2));

  nodesGroup
    .selectAll("circle.node")
    .style("cursor", "pointer")
    .on("mouseover.nodehighlight", function () {
      const currentNodeSelection = d3.select(this);
      const currentFill = currentNodeSelection.attr("fill");
      if (currentFill !== themeColors.nodeHoverFill) {
        currentNodeSelection.attr("fill", themeColors.nodeHighlightFill);
      }
    })
    .on("mouseout.nodehighlight", function () {
      const currentNodeSelection = d3.select(this);
      const currentFill = currentNodeSelection.attr("fill");
      if (currentFill === themeColors.nodeHighlightFill) {
        currentNodeSelection.attr("fill", themeColors.nodeFill);
      }
    })
    .on("click.nodeaction", function (event, d_clicked_node) {
      if (onNodeClickCallback) {
        onNodeClickCallback(d_clicked_node); // Just pass the node data
      }
      event.stopPropagation();
    });

  // ----- Link Hover Areas -----
  const linkHovers = linkHoverGroup
    .selectAll("line.link-hover")
    .data(linksData, (d) => d.id);

  linkHovers.exit().remove();

  linkHovers
    .enter()
    .append("line")
    .attr("class", "link-hover")
    .style("cursor", "pointer")
    .merge(linkHovers)
    .attr("x1", (d) => d.source.x)
    .attr("y1", (d) => d.source.y)
    .attr("x2", (d) => d.target.x)
    .attr("y2", (d) => d.target.y)
    .attr("stroke", "transparent")
    .attr("stroke-width", 20)
    .on("mouseover", function (event, d_hovered_link) {
      // Highlight the link itself
      linksGroup
        .selectAll("line.link")
        .filter((l) => l.id === d_hovered_link.id)
        .attr("stroke", themeColors.linkHoverStroke)
        .attr("stroke-width", 4);
      // Highlight connected nodes with yellowish color
      nodesGroup
        .selectAll("circle.node")
        .filter(
          (n) =>
            n.id === d_hovered_link.source.id ||
            n.id === d_hovered_link.target.id
        )
        .attr("fill", themeColors.nodeHoverFill) // Yellowish for link-connected nodes
        .attr("stroke", themeColors.nodeHoverStroke);
    })
    .on("mouseout", function (event, d_hovered_link) {
      // Reset the link itself
      linksGroup
        .selectAll("line.link")
        .filter((l) => l.id === d_hovered_link.id)
        .attr("stroke", themeColors.linkStroke)
        .style("opacity", themeColors.linkStrokeOpacity)
        .attr("stroke-width", 2);

      // Reset connected nodes
      nodesGroup
        .selectAll("circle.node")
        .filter(
          (n) =>
            n.id === d_hovered_link.source.id ||
            n.id === d_hovered_link.target.id
        )
        .each(function () {
          const nodeElement = d3.select(this);
          // If the mouse is now directly over this node, the node's own mouseover
          // will handle its highlight (darker blue). Otherwise, revert to default.
          // A simple way is to check if relatedTarget is this node.
          // For now, let's unconditionally revert from yellow. Node's own mouseover will take over if needed.
          if (nodeElement.attr("fill") === themeColors.nodeHoverFill) {
            // Only revert if it was yellow
            nodeElement.attr("fill", themeColors.nodeFill); // Default blue
          }
        })
        .attr(
          "stroke",
          (
            n // Also reset stroke
          ) =>
            n.id === focusedNodeId
              ? themeColors.selectedNodePulseColor
              : themeColors.nodeStroke
        )
        .attr("stroke-width", (n) => (n.id === focusedNodeId ? 3 : 2));
    })
    .on("click", function (event, d_clicked_link) {
      if (onLinkClickCallback) {
        onLinkClickCallback(d_clicked_link);
      }
      event.stopPropagation(); // Good practice for clickable items in a zoomable area
    });

  // ----- Node Labels (Text) -----
  const nodeLabels = nodeLabelsGroup
    .selectAll("text.node-label")
    .data(nodesData, (d) => d.id);

  nodeLabels
    .exit()
    .transition("labelExit")
    .duration(ANIMATION_DURATION / 2)
    .style("opacity", 0)
    .remove();

  nodeLabels
    .enter()
    .append("text")
    .attr("class", "node-label")
    .attr("x", (d) => d.x)
    .attr("y", (d) => d.y)
    .style("opacity", 0)
    .attr("text-anchor", "middle")
    .attr("dy", ".35em")
    .style("pointer-events", "none") // Prevent labels from interfering
    .merge(nodeLabels)
    .transition("labelUpdate")
    .duration(ANIMATION_DURATION)
    .attr("x", (d) => d.x)
    .attr("y", (d) => d.y)
    .text((d) => d.id)
    .style("opacity", 1)
    .attr("fill", themeColors.nodeTextFill)
    .attr("font-size", (d) => (d.id === focusedNodeId ? "18px" : "14px"))
    .attr("font-weight", (d) => (d.id === focusedNodeId ? "bold" : "normal"));
}

--- File: src\components\CoreSite\drawHelpers.jsx ---
export function linkPositionFromEdges(d, r = 60) {
  const dx = d.target.x - d.source.x;
  const dy = d.target.y - d.source.y;
  const angle1 = Math.atan2(dy, dx);
  const angle2 = Math.atan2(-dy, -dx);

  return {
    x1: d.source.x + r * Math.cos(angle1),
    y1: d.source.y + r * Math.sin(angle1),
    x2: d.target.x + r * Math.cos(angle2),
    y2: d.target.y + r * Math.sin(angle2),
  };
}

export function getEdgePoint(fromX, fromY, toX, toY, radius = 60) {
  const dx = toX - fromX;
  const dy = toY - fromY;
  const angle = Math.atan2(dy, dx);
  return {
    x: fromX + radius * Math.cos(angle),
    y: fromY + radius * Math.sin(angle),
  };
}

--- File: src\components\CoreSite\SitesBar.jsx ---
// SitesBar.jsx
import React from "react";
import * as d3 from "d3";
import { getEdgePoint } from "./drawHelpers";

export default function SitesBar({
  svgRef,
  focusedNodeDataRef, // Renamed from node4Ref, this is the ref object to READ from
  focusedNodeId, // ID of the currently focused node
  siteRefs,
  sites = [],
  theme = "dark",
  onSiteClick,
  // nodes prop might not be needed if focusedNodeDataRef is sufficient
}) {
  const buttonDefaultBg = theme === "dark" ? "#29c6e0" : "#e0f2fe";
  const buttonDefaultBorder = theme === "dark" ? "#60a5fa" : "#7dd3fc";
  const buttonDefaultText = theme === "dark" ? "text-white" : "text-sky-700";

  const buttonHoverBg = theme === "dark" ? "#fde68a" : "#fef9c3";
  const buttonHoverBorder = theme === "dark" ? "#facc15" : "#fde047";
  const buttonHoverText =
    theme === "dark" ? "text-slate-800" : "text-yellow-700";

  const connectorLineStroke = theme === "dark" ? "#facc15" : "#f59e0b";

  const handleHover = (hovered, targetButton) => {
    const nodeDefaultFill = theme === "dark" ? "#29c6e0" : "#67e8f9";
    const nodeDefaultStroke = theme === "dark" ? "#60a5fa" : "#7dd3fc";
    const nodeHoverFill = theme === "dark" ? "#fde68a" : "#fef08a";
    const nodeHoverStroke = theme === "dark" ? "#facc15" : "#f59e0b";

    // Highlight the currently focused node
    if (focusedNodeId) {
      d3.select(svgRef.current)
        .selectAll("circle.node")
        .filter((d) => d.id === focusedNodeId) // Use focusedNodeId
        .attr("fill", hovered ? nodeHoverFill : nodeDefaultFill)
        .attr("stroke", hovered ? nodeHoverStroke : nodeDefaultStroke)
        .attr("stroke-width", hovered ? 4 : 2);
    }

    if (targetButton) {
      targetButton.style.backgroundColor = hovered
        ? buttonHoverBg
        : buttonDefaultBg;
      targetButton.style.borderColor = hovered
        ? buttonHoverBorder
        : buttonDefaultBorder;

      const defaultTextClass = buttonDefaultText.split(" ")[0];
      const hoverTextClass = buttonHoverText.split(" ")[0];

      if (hovered) {
        if (
          defaultTextClass &&
          targetButton.classList.contains(defaultTextClass)
        ) {
          targetButton.classList.remove(defaultTextClass);
        }
        if (
          hoverTextClass &&
          !targetButton.classList.contains(hoverTextClass)
        ) {
          targetButton.classList.add(hoverTextClass);
        }
      } else {
        if (hoverTextClass && targetButton.classList.contains(hoverTextClass)) {
          targetButton.classList.remove(hoverTextClass);
        }
        if (
          defaultTextClass &&
          !targetButton.classList.contains(defaultTextClass)
        ) {
          targetButton.classList.add(defaultTextClass);
        }
      }
    }
  };

  return (
    <div
      className={`absolute bottom-12 left-0 w-full px-4 py-4 flex flex-wrap justify-center items-center gap-3 bg-transparent z-10 shadow-upwards`}
    >
      {sites.map((site, i) => (
        <button
          key={site.id}
          ref={(el) => (siteRefs.current[i] = el)}
          // --- THIS IS THE MODIFIED SECTION ---
          onClick={(e) => {
            // 1. Manually trigger the cleanup logic to remove hover effects IMMEDIATELY.
            //    We pass `false` to revert the styles and provide the button element.
            handleHover(false, e.currentTarget);
            d3.select("#active-connector-line").remove();

            // 2. Perform the original action: open the detail tab.
            if (onSiteClick) {
              onSiteClick(site); // Pass the entire site object to the handler
            }
          }}
          // --- END OF MODIFICATION ---
          onMouseEnter={(e) => {
            handleHover(true, e.currentTarget);
            const svg = d3.select(svgRef.current);
            const btnBox = e.currentTarget.getBoundingClientRect();
            const svgBox = svgRef.current.getBoundingClientRect();

            const btnX = btnBox.left + btnBox.width / 2 - svgBox.left;
            const btnY = btnBox.top + btnBox.height / 2 - svgBox.top;

            if (!focusedNodeDataRef.current) {
              console.warn(
                "[SitesBar] focusedNodeDataRef.current is not set on hover."
              );
              return;
            }

            const nodeData = focusedNodeDataRef.current;
            const edge = getEdgePoint(nodeData.x, nodeData.y, btnX, btnY, 60);

            svg
              .append("line")
              .attr("id", "active-connector-line")
              .attr("x1", btnX)
              .attr("y1", btnY)
              .attr("x2", edge.x)
              .attr("y2", edge.y)
              .attr("stroke", connectorLineStroke)
              .attr("stroke-width", 3)
              .lower();
          }}
          onMouseLeave={(e) => {
            // This remains to handle cases where the user hovers but does NOT click.
            handleHover(false, e.currentTarget);
            d3.select("#active-connector-line").remove();
          }}
          className={`px-4 py-2 rounded ${buttonDefaultText} text-sm font-medium transition-all duration-150 shadow-md focus:outline-none focus:ring-2 focus:ring-opacity-50 ${
            theme === "dark" ? "focus:ring-yellow-400" : "focus:ring-amber-500"
          }`}
          style={{
            backgroundColor: buttonDefaultBg,
            border: `2px solid ${buttonDefaultBorder}`,
          }}
        >
          {site.site_name_english}
        </button>
      ))}
    </div>
  );
}

--- File: src\components\CoreSite\useCoreSiteData.jsx ---
import {
  useState,
  useEffect,
  useLayoutEffect,
  useRef,
  useCallback,
  useMemo,
} from "react";
import { useSelector } from "react-redux";
import { useParams, useNavigate } from "react-router-dom";
import { useNodeLayout } from "./useNodeLayout";
import { selectAllSites } from "../../redux/slices/sitesSlice";
import { selectLinksByTypeId } from "../../redux/slices/tenGigLinksSlice";
import { selectAllDevices } from "../../redux/slices/devicesSlice";
import { selectAllPikudim } from "../../redux/slices/corePikudimSlice";

export function useCoreSiteData(chartType) {
  const { zoneId, nodeId: nodeIdFromUrl } = useParams();
  const navigate = useNavigate();
  const containerRef = useRef(null);

  const allPikudim = useSelector(selectAllPikudim);
  const allDevices = useSelector(selectAllDevices);
  const allSites = useSelector(selectAllSites);
  const allLinksForChart = useSelector((state) =>
    selectLinksByTypeId(state, chartType === "P" ? 2 : 1)
  );

  const devicesForZone = useMemo(() => {
    if (!zoneId || !allPikudim.length || !allDevices.length) return [];
    const currentPikud = allPikudim.find((p) => p.core_site_name === zoneId);
    if (!currentPikud) return [];
    return allDevices.filter((d) => d.core_pikudim_site_id === currentPikud.id);
  }, [zoneId, allDevices, allPikudim]);

  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  const [selectedNodeId, setSelectedNodeId] = useState(null);
  const [showExtendedNodes, setShowExtendedNodes] = useState(false);
  const [animateExtendedLayoutUp, setAnimateExtendedLayoutUp] = useState(false);
  const [previousSelectedNodeId, setPreviousSelectedNodeId] = useState(null);
  const [openDetailTabs, setOpenDetailTabs] = useState([]);
  const [activeDetailTabId, setActiveDetailTabId] = useState(null);

  const sitesForFocusedNode = useMemo(() => {
    // This logic will only re-run if allDevices, selectedNodeId, or allSites changes.
    if (!selectedNodeId || !allDevices.length || !allSites.length) {
      return [];
    }

    // 1. Find the full device object for the selectedNodeId (which is a hostname)
    const focusedDevice = allDevices.find((d) => d.hostname === selectedNodeId);

    // 2. If we found the device, use its real ID to filter the sites
    if (focusedDevice) {
      return allSites.filter((site) => site.device_id === focusedDevice.id);
    }

    // 3. Otherwise, return an empty array
    return [];
  }, [allDevices, selectedNodeId, allSites]);

  useEffect(() => {
    if (devicesForZone.length > 0 && !selectedNodeId) {
      const initialNodeId = nodeIdFromUrl || devicesForZone[0].hostname;
      setSelectedNodeId(initialNodeId);
      setPreviousSelectedNodeId(initialNodeId);
    }
  }, [devicesForZone, nodeIdFromUrl, selectedNodeId]);

  useEffect(() => {
    if (showExtendedNodes) {
      setAnimateExtendedLayoutUp(false);
      const timer = setTimeout(() => setAnimateExtendedLayoutUp(true), 100);
      return () => clearTimeout(timer);
    } else {
      setAnimateExtendedLayoutUp(false);
    }
  }, [showExtendedNodes]);

  useLayoutEffect(() => {
    // This effect can be simplified or removed if not strictly needed
    setShowExtendedNodes(false);
  }, [zoneId]);

  useLayoutEffect(() => {
    const updateDimensions = () => {
      if (containerRef.current) {
        setDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight,
        });
      }
    };
    if (containerRef.current) updateDimensions();
    window.addEventListener("resize", updateDimensions);
    return () => window.removeEventListener("resize", updateDimensions);
  }, []);

  const {
    nodes: layoutNodes,
    links: layoutLinks,
    centerX,
    centerY,
  } = useNodeLayout(
    dimensions.width,
    dimensions.height,
    showExtendedNodes,
    animateExtendedLayoutUp,
    devicesForZone,
    allLinksForChart
  );

  const nodes = layoutNodes.filter((node) => node.id !== "None");
  const links = layoutLinks.filter(
    (link) => link.source.id !== "None" && link.target.id !== "None"
  );

  const handleToggleExtendedNodes = () => {
    setShowExtendedNodes((prevShowExtended) => {
      const nextShowExtended = !prevShowExtended;
      if (nextShowExtended) {
        // Switching to extended view
        setPreviousSelectedNodeId(selectedNodeId);
        // Select the first visible node in the new layout (device at index 2)
        const newSelected = devicesForZone[2]?.hostname;
        if (newSelected) setSelectedNodeId(newSelected);
      } else {
        // Switching back to initial view
        // Restore previous selection or default to first device
        setSelectedNodeId(
          previousSelectedNodeId || devicesForZone[0]?.hostname
        );
      }
      return nextShowExtended;
    });
  };

  const onNodeClickInZone = (clickedNodeData) => {
    if (!clickedNodeData || !clickedNodeData.id) {
      console.warn("Node data incomplete for action:", clickedNodeData);
      return;
    }

    // --- THIS IS THE CORE LOGIC ---
    if (clickedNodeData.id === selectedNodeId) {
      // The user clicked on the node that is ALREADY focused.
      // This is our trigger to navigate.
      console.log(
        `Navigating to details for already-focused node: ${clickedNodeData.id}`
      );
      navigate(`node/${clickedNodeData.id}`);
    } else {
      // The user clicked on a DIFFERENT node.
      // The action is to change the focus.
      console.log(`Setting focus to ${clickedNodeData.id}`);
      setSelectedNodeId(clickedNodeData.id);
    }
  };

  const addOrActivateTab = useCallback((payload) => {
    const { id, type } = payload;
    const tabId = `${type}-${id}`;

    setOpenDetailTabs((prevTabs) => {
      const tabExists = prevTabs.some((tab) => tab.id === tabId);
      if (tabExists) {
        return prevTabs;
      }
      let title = "Details";
      if (type === "link") {
        title = `${payload.sourceNode} - ${payload.targetNode}`;
      } else if (type === "site") {
        title = payload.name;
      }
      return [...prevTabs, { id: tabId, type, title, data: payload }];
    });
    setActiveDetailTabId(tabId);
  }, []);

  const handleCloseTab = useCallback(
    (tabIdToClose) => {
      setOpenDetailTabs((prevTabs) => {
        const remainingTabs = prevTabs.filter((tab) => tab.id !== tabIdToClose);
        if (activeDetailTabId === tabIdToClose) {
          setActiveDetailTabId(
            remainingTabs.length > 0
              ? remainingTabs[remainingTabs.length - 1].id
              : null
          );
        }
        return remainingTabs;
      });
    },
    [activeDetailTabId]
  );

  // REPLACE THE OLD FUNCTION WITH THIS NEW ONE:

  const handleNavigateToSite = useCallback(
    (clickedSiteData) => {
      // `clickedSiteData` is the single site object from the tab.
      // It contains the `name` property (e.g., "Site West Pasquale").
      if (!clickedSiteData || !clickedSiteData.name) {
        console.error("Navigation failed: No site data provided.");
        return;
      }

      // 1. Get the English name of the site. This is our unique key to find the group.
      const targetSiteName = clickedSiteData.name;

      // 2. Search through the `allSites` array (which you already have in this hook)
      //    to find every connection that matches this name. This rebuilds the "group".
      const siteGroup = allSites.filter(
        (site) => site.site_name_english === targetSiteName
      );

      // 3. If we found at least one matching site, we can navigate.
      if (siteGroup.length > 0) {
        // Create a URL-friendly version of the name.
        const navId = encodeURIComponent(targetSiteName);

        // 4. THIS IS THE CRITICAL FIX:
        //    Navigate with the data in the CORRECT format. The router expects an
        //    object with a `siteGroupData` key, and its value is the array we just built.
        navigate(`/sites/site/${navId}`, {
          state: { siteGroupData: siteGroup },
        });
      } else {
        // Optional: Handle the case where for some reason the site couldn't be found.
        console.error(
          "Could not find a matching site group for:",
          targetSiteName
        );
      }
    },
    [navigate, allSites]
  ); // <-- Add `allSites` to the dependency array

  const handleSiteClick = (siteData) => {
    // Modified to accept the whole site object
    const siteDetailPayload = {
      id: siteData.id, // Use the real ID
      navId: `site-${siteData.id}`,
      name: siteData.site_name_english, // Use the real name
      type: "site",
      zone: zoneId,
      // You can add more real data from the site object here if needed
      description: `Details for ${siteData.site_name_english}`,
    };
    addOrActivateTab(siteDetailPayload);
  };

  const handleLinkClick = (linkData) => {
    const newLinkPayload = {
      id: linkData.id || `link-${linkData.source.id}-${linkData.target.id}`,
      type: "link",
      sourceNode: linkData.source.id,
      targetNode: linkData.target.id,
      name: `Link: ${linkData.source.id} ↔ ${linkData.target.id}`,
      linkBandwidth: `${Math.floor(Math.random() * 1000) + 100} Gbps`,
      latency: `${Math.floor(Math.random() * 50) + 1} ms`,
      utilization: `${Math.floor(Math.random() * 100)}%`,
      status: Math.random() > 0.15 ? "up" : "down",
      linkId: linkData.id,
      linkDescription: "Core fiber optic interconnect.",
    };
    addOrActivateTab(newLinkPayload);
  };

  return {
    zoneId,
    containerRef,
    dimensions,
    nodes,
    links,
    centerX,
    centerY,
    selectedNodeId,
    showExtendedNodes,
    handleToggleExtendedNodes,
    devicesInZoneCount: devicesForZone.length,
    sitesForFocusedNode,
    onSiteClick: handleSiteClick,
    onLinkClick: handleLinkClick,
    onNodeClickInZone: onNodeClickInZone,
    openDetailTabs,
    activeDetailTabId,
    setActiveDetailTabId,
    handleCloseTab,
    handleNavigateToSite,
  };
}

--- File: src\components\CoreSite\useNodeLayout.jsx ---
export function useNodeLayout(
  width,
  height,
  showExtendedNodes,
  animateExtendedLayoutUp,
  devicesForZone = [],
  allLinksForChart = []
) {
  const centerX = width / 2;
  const mainZoneCenterY = height / 3;
  const spacing = 100;

  // --- Define X positions (consistent for both layouts) ---
  const upperLeftX = centerX - spacing;
  const upperRightX = centerX + spacing;
  const lowerLeftX = centerX - spacing;
  const lowerRightX = centerX + spacing;

  // --- Define Y positions for the initial 4-node layout ---
  const layout1_UpperPairY = mainZoneCenterY - spacing;
  const layout1_LowerPairY = mainZoneCenterY + spacing;

  // --- Y positions for the extended 6-node layout (animation targets) ---
  const layout2_Target_UpperPairY = mainZoneCenterY - spacing;
  const layout2_Target_LowerPairY = mainZoneCenterY + spacing;

  // --- Initial Y positions for the extended layout (before upward animation) ---
  const layout2_Initial_UpperPairY = layout1_LowerPairY;
  const layout2_Initial_LowerPairY = layout1_LowerPairY + spacing * 1.5;

  let nodePositions = [];
  let currentDevices = [];
  let currentNodes = [];

  if (showExtendedNodes) {
    // --- EXTENDED LAYOUT ---
    // This layout shows devices from index 2 to 5.
    currentDevices = devicesForZone.slice(2, 6);

    // Calculate the positions for the 4 slots in this view
    const p1_X = upperLeftX;
    const p2_X = upperRightX;
    const p3_X = lowerLeftX;
    const p4_X = lowerRightX;

    let p1_Y, p2_Y, p3_Y, p4_Y;

    if (animateExtendedLayoutUp) {
      // Final animated positions
      p1_Y = p2_Y = layout2_Target_UpperPairY;
      p3_Y = p4_Y = layout2_Target_LowerPairY;
    } else {
      // Initial positions (lower on the screen)
      p1_Y = p2_Y = layout2_Initial_UpperPairY;
      p3_Y = p4_Y = layout2_Initial_LowerPairY;
    }
    nodePositions = [
      { x: p1_X, y: p1_Y },
      { x: p2_X, y: p2_Y },
      { x: p3_X, y: p3_Y },
      { x: p4_X, y: p4_Y },
    ];
  } else {
    // --- INITIAL LAYOUT ---
    // This layout shows devices from index 0 to 3.
    currentDevices = devicesForZone.slice(0, 4);

    // Define the 4 fixed positions for this view
    nodePositions = [
      { x: upperLeftX, y: layout1_UpperPairY },
      { x: upperRightX, y: layout1_UpperPairY },
      { x: lowerLeftX, y: layout1_LowerPairY },
      { x: lowerRightX, y: layout1_LowerPairY },
    ];
  }

  // Map the selected devices to the calculated positions
  currentNodes = nodePositions.map((pos, i) => {
    const device = currentDevices[i] || null;
    return {
      id: device ? device.hostname : "None",
      x: pos.x,
      y: pos.y,
    };
  });

  // --- NEW LOGIC: Filter the real links instead of creating them ---
  // 1. Create a Set of the hostnames for the currently visible nodes for fast lookups.
  const visibleNodeIds = new Set(
    currentNodes.filter((n) => n.id !== "None").map((n) => n.id)
  );

  // 2. Filter the master list of all links.
  const visibleLinks = allLinksForChart.filter(
    (link) => visibleNodeIds.has(link.source) && visibleNodeIds.has(link.target)
  );

  // 3. Map the filtered links to the D3 format, replacing string IDs with full node objects.
  const nodeMap = new Map(currentNodes.map((node) => [node.id, node]));
  const finalLinks = visibleLinks.map((link) => ({
    ...link,
    source: nodeMap.get(link.source),
    target: nodeMap.get(link.target),
  }));

  return {
    nodes: currentNodes,
    links: finalLinks, // <-- Return the filtered and mapped real links
    centerX: centerX,
    centerY: mainZoneCenterY,
  };
}

--- File: src\components\end-site\EndSiteIndexPage.jsx ---
import React, { useState, useMemo, useRef, useEffect } from "react";
import { useSelector } from "react-redux";
import { useNavigate } from "react-router-dom";
import { useVirtualizer } from "@tanstack/react-virtual";

// --- Data & Slices ---
import { selectAllSites } from "../../redux/slices/sitesSlice";
import { selectAllDevices } from "../../redux/slices/devicesSlice";
import { selectAllPikudim } from "../../redux/slices/corePikudimSlice";

// --- UI & Feedback Components ---
import { GridSkeleton } from "../ui/feedback/GridSkeleton";
import { ErrorMessage } from "../ui/feedback/ErrorMessage";

// SiteCard component remains unchanged
const SiteCard = ({ siteGroup, deviceMap, pikudMap, onClick }) => {
  const primarySite = siteGroup[0];
  return (
    <div
      onClick={onClick}
      className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-xl hover:-translate-y-1 transition-all duration-200 cursor-pointer border border-transparent dark:hover:border-blue-500 hover:border-blue-400 flex flex-col h-full"
    >
      <div className="flex-grow">
        <h3 className="text-lg font-semibold text-blue-600 dark:text-blue-400 truncate">
          {primarySite.site_name_english}
        </h3>
        <p
          className="text-sm text-gray-500 dark:text-gray-400 truncate"
          title={primarySite.site_name_hebrew}
        >
          {primarySite.site_name_hebrew}
        </p>
      </div>
      <div className="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700 text-xs text-gray-600 dark:text-gray-300 space-y-3">
        {siteGroup.map((site) => {
          const device = deviceMap.get(site.device_id);
          const pikud = device
            ? pikudMap.get(device.core_pikudim_site_id)
            : null;
          return (
            <div key={site.id}>
              <p>
                <strong>Device:</strong> {device?.hostname || "N/A"}
              </p>
              <p>
                <strong>Core Site:</strong> {pikud?.core_site_name || "N/A"}
              </p>
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default function EndSiteIndexPage() {
  const navigate = useNavigate();
  const [searchTerm, setSearchTerm] = useState("");
  const parentRef = useRef(null);

  // --- Get Data and Status from Redux ---
  const allSites = useSelector(selectAllSites);
  const sitesStatus = useSelector((state) => state.sites.status);
  const allDevices = useSelector(selectAllDevices);
  const allPikudim = useSelector(selectAllPikudim);

  // --- Memoized data processing ---
  const deviceMap = useMemo(
    () => new Map(allDevices.map((d) => [d.id, d])),
    [allDevices]
  );
  const pikudMap = useMemo(
    () => new Map(allPikudim.map((p) => [p.id, p])),
    [allPikudim]
  );

  const groupedSites = useMemo(() => {
    return allSites.reduce((acc, site) => {
      const key = site.site_name_english;
      if (!acc[key]) acc[key] = [];
      acc[key].push(site);
      return acc;
    }, {});
  }, [allSites]);

  const filteredSiteGroups = useMemo(() => {
    const allGroups = Object.values(groupedSites);
    if (!searchTerm) return allGroups;
    const lowercasedFilter = searchTerm.toLowerCase();
    return allGroups.filter((siteGroup) => {
      const representativeSite = siteGroup[0];
      return (
        representativeSite.site_name_english
          .toLowerCase()
          .includes(lowercasedFilter) ||
        representativeSite.site_name_hebrew.includes(lowercasedFilter)
      );
    });
  }, [groupedSites, searchTerm]);

  const handleSiteClick = (siteGroup) => {
    const navId = encodeURIComponent(siteGroup[0].site_name_english);
    navigate(`/sites/site/${navId}`, { state: { siteGroupData: siteGroup } });
  };

  // --- VIRTUALIZATION LOGIC: Row-based approach ---
  const [columnCount, setColumnCount] = useState(5);

  useEffect(() => {
    const updateColumnCount = () => {
      if (window.innerWidth >= 1280)
        setColumnCount(5); // Corresponds to Tailwind's xl
      else if (window.innerWidth >= 1024) setColumnCount(4); // lg
      else if (window.innerWidth >= 768) setColumnCount(3); // md
      else if (window.innerWidth >= 640) setColumnCount(2); // sm
      else setColumnCount(1);
    };

    updateColumnCount();
    window.addEventListener("resize", updateColumnCount);
    return () => window.removeEventListener("resize", updateColumnCount);
  }, []);

  const rowVirtualizer = useVirtualizer({
    count: Math.ceil(filteredSiteGroups.length / columnCount),
    getScrollElement: () => parentRef.current,
    estimateSize: () => 200, // Still important for initial render and scrollbar size
    overscan: 5,
    // Add measurement options for more stable measuring
    measureElement: (element) => element.getBoundingClientRect().height,
  });

  const renderContent = () => {
    if (sitesStatus === "loading") {
      return <GridSkeleton count={15} />;
    }
    if (sitesStatus === "failed") {
      return <ErrorMessage message="Failed to load site data." />;
    }
    if (filteredSiteGroups.length === 0) {
      return (
        <div className="text-center py-16">
          <p className="text-lg text-gray-500 dark:text-gray-400">
            No sites found matching your search.
          </p>
        </div>
      );
    }

    return (
      <div ref={parentRef} className="w-full h-full overflow-y-auto pr-2">
        <div
          key={columnCount}
          className="relative w-full"
          style={{ height: `${rowVirtualizer.getTotalSize()}px` }}
        >
          {rowVirtualizer.getVirtualItems().map((virtualRow) => {
            const cardsInRow = [];
            const startIndex = virtualRow.index * columnCount;
            const endIndex = Math.min(
              startIndex + columnCount,
              filteredSiteGroups.length
            );

            for (let i = startIndex; i < endIndex; i++) {
              const siteGroup = filteredSiteGroups[i];
              cardsInRow.push(
                <SiteCard
                  key={siteGroup[0].site_name_english}
                  siteGroup={siteGroup}
                  deviceMap={deviceMap}
                  pikudMap={pikudMap}
                  onClick={() => handleSiteClick(siteGroup)}
                />
              );
            }

            return (
              // --- THIS IS THE CORRECTED STRUCTURE ---
              <div
                key={virtualRow.key}
                ref={rowVirtualizer.measureElement}
                data-index={virtualRow.index}
                className="absolute top-0 left-0 w-full"
                style={{
                  transform: `translateY(${virtualRow.start}px)`,
                }}
              >
                {/* This inner div handles the grid layout and its height determines the parent's height */}
                <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-5 p-1">
                  {cardsInRow}
                </div>
              </div>
            );
          })}
        </div>
      </div>
    );
  };

  return (
    <div className="p-6 bg-gray-50 dark:bg-gray-900 h-full flex flex-col">
      <header className="mb-6 flex-shrink-0">
        <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-100">
          All End-Sites
        </h1>
        <p className="text-md text-gray-600 dark:text-gray-400 mt-1">
          Browse and search for a specific site to view its details.
        </p>
      </header>

      <div className="mb-8 flex-shrink-0">
        <input
          type="text"
          placeholder="Search by English or Hebrew name..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="w-full max-w-lg p-3 border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none"
        />
      </div>

      <div className="flex-grow min-h-0">{renderContent()}</div>
    </div>
  );
}

--- File: src\components\end-site\LineDetailExtend.jsx ---
const LinkDetailRow = ({ link, isParentSelectedAndDark }) => {
  const hasAdditionalDetails =
    link.additionalDetails && Object.keys(link.additionalDetails).length > 0;
  const hasRelevantIssueType =
    (link.status === "issue" || link.status === "down") && link.issueType;

  const tdClasses = `relative -left-[4px]`;

  // Determine background based on whether the parent selected row is dark or light
  // This ensures the detail row visually merges with the selected row above it.
  const detailRowBackground = isParentSelectedAndDark
    ? "bg-slate-700"
    : "bg-slate-100";

  // Text colors need to contrast with the detailRowBackground
  const labelTextColor = isParentSelectedAndDark
    ? "text-slate-300"
    : "text-slate-700";
  const valueTextColor = isParentSelectedAndDark
    ? "text-slate-400"
    : "text-slate-600";
  const issueLabelColor = isParentSelectedAndDark
    ? "text-red-400"
    : "text-red-500"; // Adjusted red for better contrast on slate
  const issueValueColor = isParentSelectedAndDark
    ? "text-red-400 font-semibold"
    : "text-red-500 font-semibold";
  const borderColor = isParentSelectedAndDark
    ? "border-slate-600"
    : "border-slate-300";

  if (!hasAdditionalDetails && !hasRelevantIssueType) {
    return (
      <td colSpan="6" className={tdClasses}>
        <div className={`p-4 ${detailRowBackground} text-sm ${valueTextColor}`}>
          {" "}
          {/* Use valueTextColor for consistency */}
          No specific details available for this link.
        </div>
      </td>
    );
  }

  const {
    mediaType = "N/A",
    cdpNeighbors = "N/A",
    containerName = "N/A",
    mtu = "N/A",
    crcErrors = "N/A",
    inputDataRate = "N/A",
    outputDataRate = "N/A",
    txPower = "N/A",
    rxPower = "N/A",
  } = link.additionalDetails || {};
  const issueType = link.issueType || null;

  const detailItemClass = "py-1"; // Base class for items

  return (
    <td colSpan="6" className={tdClasses}>
      <div
        className={`p-4 ${detailRowBackground} transition-colors duration-150`}
      >
        {hasRelevantIssueType && issueType && (
          <div
            className={`${detailItemClass} mb-3 border-b ${borderColor} pb-2`}
          >
            <span className={`font-medium ${issueLabelColor}`}>
              Issue Type:
            </span>{" "}
            <span className={issueValueColor}>{issueType}</span>
          </div>
        )}
        {hasAdditionalDetails && (
          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-x-4 gap-y-2 text-sm">
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>
                Media Type:
              </span>{" "}
              <span className={valueTextColor}>{mediaType}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>
                CDP Neighbors:
              </span>{" "}
              <span className={valueTextColor}>{cdpNeighbors}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>
                Container:
              </span>{" "}
              <span className={valueTextColor}>{containerName}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>MTU:</span>{" "}
              <span className={valueTextColor}>{mtu}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>
                CRC Errors:
              </span>{" "}
              <span className={valueTextColor}>{crcErrors}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>
                Input Rate:
              </span>{" "}
              <span className={valueTextColor}>{inputDataRate}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>
                Output Rate:
              </span>{" "}
              <span className={valueTextColor}>{outputDataRate}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>Tx Power:</span>{" "}
              <span className={valueTextColor}>{txPower}</span>
            </div>
            <div className={detailItemClass}>
              <span className={`font-medium ${labelTextColor}`}>Rx Power:</span>{" "}
              <span className={valueTextColor}>{rxPower}</span>
            </div>
          </div>
        )}
      </div>
    </td>
  );
};

export default LinkDetailRow;

--- File: src\components\end-site\SiteDetailPage.jsx ---
import React, { useState, useEffect, useMemo } from "react";
import { useSelector } from "react-redux";
import LinkDetailRow from "./LineDetailExtend";
import StatusBulb from "../shared/StatusBulb";
import { selectAllDevices } from "../../redux/slices/devicesSlice";
//import { api } from "../../services/api";

// Helper function for generating a complex site topology (NO CHANGES)
const createSiteInternalTopology = () => {
  const nodes = [];
  const links = [];
  const nodeTypes = ["Firewall", "Router", "Switch", "Server"];
  const width = 400;
  const height = 300;
  const numNodes = Math.floor(Math.random() * 3) + 4;

  for (let i = 0; i < numNodes; i++) {
    const type = nodeTypes[Math.floor(Math.random() * nodeTypes.length)];
    nodes.push({
      id: `internal-node-${i}`,
      name: `${type}-${i + 1}`,
      type: type,
      x: Math.random() * (width - 80) + 40,
      y: Math.random() * (height - 80) + 40,
    });
  }

  for (let i = 0; i < numNodes - 1; i++) {
    links.push({
      id: `link-${i}`,
      source: `internal-node-${i}`,
      target: `internal-node-${i + 1}`,
      status: Math.random() > 0.1 ? "up" : "down",
    });
  }

  const extraLinks = Math.floor(Math.random() * 2) + 1;
  for (let i = 0; i < extraLinks; i++) {
    const sourceNode = nodes[Math.floor(Math.random() * numNodes)];
    const targetNode = nodes[Math.floor(Math.random() * numNodes)];
    const linkExists = links.some(
      (l) =>
        (l.source === sourceNode.id && l.target === targetNode.id) ||
        (l.source === targetNode.id && l.target === sourceNode.id)
    );
    if (sourceNode.id !== targetNode.id && !linkExists) {
      links.push({
        id: `extra-link-${i}`,
        source: sourceNode.id,
        target: targetNode.id,
        status: Math.random() > 0.1 ? "up" : "down",
      });
    }
  }

  return { nodes, links };
};

const TopologyLoader = () => (
  <div className="flex flex-col items-center justify-center h-full text-gray-500 dark:text-gray-400">
    <svg
      className="animate-spin h-8 w-8 text-blue-500"
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
    >
      <circle
        className="opacity-25"
        cx="12"
        cy="12"
        r="10"
        stroke="currentColor"
        strokeWidth="4"
      ></circle>
      <path
        className="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      ></path>
    </svg>
    <p className="mt-2 text-sm">Loading Topology...</p>
  </div>
);

const SiteDetailPage = ({ siteGroup, initialTheme = "light" }) => {
  // All state and memoization hooks remain unchanged
  const [theme, setTheme] = useState(initialTheme);
  const [expandedLinkId, setExpandedLinkId] = useState(null);
  const allDevices = useSelector(selectAllDevices);

  const [topologyData, setTopologyData] = useState({ nodes: [], links: [] });
  const [topologyStatus, setTopologyStatus] = useState("loading"); // 'loading', 'succeeded', 'failed'

  const deviceMap = useMemo(
    () => new Map(allDevices.map((d) => [d.id, d])),
    [allDevices]
  );

  useEffect(() => {
    const rootHtmlElement = document.documentElement;
    const observer = new MutationObserver(() => {
      setTheme(rootHtmlElement.classList.contains("dark") ? "dark" : "light");
    });
    observer.observe(rootHtmlElement, {
      attributes: true,
      attributeFilter: ["class"],
    });
    return () => observer.disconnect();
  }, []);

  useEffect(() => {
    if (!siteGroup || siteGroup.length === 0) {
      setTopologyStatus("idle"); // Not loading if there's no site data
      return;
    }

    const fetchTopology = async () => {
      setTopologyStatus("loading");
      try {
        const primarySite = siteGroup[0];
        const device = deviceMap.get(primarySite.device_id);

        // IMPORTANT: The backend needs `management_segment` and `sda_site_id`.
        // You must source `management_segment` from your data. Here we assume
        // it's a property on the device object. Adjust if needed.
        const networkData = {
          sda_site_id: primarySite.id,
          // TODO: Replace this with the actual management segment from your device data
          management_segment: device?.management_segment || "default-segment",
        };

        // eslint-disable-next-line no-undef
        const data = await api.getWanConnection(networkData);
        // Assuming the API returns an object with { nodes: [], links: [] }
        setTopologyData(data);
        setTopologyStatus("succeeded");
      } catch (error) {
        console.error("Failed to fetch site topology:", error);
        setTopologyStatus("failed");
        // As a fallback on error, we can use the mock data function
        setTopologyData(createSiteInternalTopology());
      }
    };

    fetchTopology();
  }, [siteGroup, deviceMap]);

  const siteTopology = useMemo(() => createSiteInternalTopology(), []);

  const siteConnectionsData = useMemo(() => {
    if (!siteGroup || siteGroup.length === 0) return [];
    return siteGroup.map((connection) => {
      const device = deviceMap.get(connection.device_id);
      return {
        id: connection.id,
        name: `Connection to ${device?.hostname || "Unknown Device"}`,
        description: `Interface ID: ${connection.interface_id}`,
        status: "up",
        ospfStatus: "N/A",
        mplsStatus: "N/A",
        bandwidth: "1 Gbps",
        additionalDetails: {
          mediaType: "Fiber/Copper",
          siteId: connection.id,
          deviceId: connection.device_id,
          deviceName: device?.hostname,
          interfaceId: connection.interface_id,
        },
      };
    });
  }, [siteGroup, deviceMap]);

  if (!siteGroup || siteGroup.length === 0) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-white dark:bg-gray-800">
        <p className="text-xl text-gray-700 dark:text-gray-300">
          Site data not found. Please select a site from the list.
        </p>
      </div>
    );
  }

  const primarySite = siteGroup[0];
  const isDark = theme === "dark";

  const handleLinkRowClick = (linkId) => {
    setExpandedLinkId((prevId) => (prevId === linkId ? null : linkId));
  };

  const nodeMap = new Map(siteTopology.nodes.map((node) => [node.id, node]));
  const nodeColorMap = {
    Router: isDark ? "fill-blue-400" : "fill-blue-500",
    Switch: isDark ? "fill-teal-400" : "fill-teal-500",
    Firewall: isDark ? "fill-red-400" : "fill-red-500",
    Server: isDark ? "fill-purple-400" : "fill-purple-500",
  };

  return (
    <div className="bg-white dark:bg-gray-800 min-h-screen transition-colors duration-300">
      <div className="p-6">
        {/* --- TOP HEADER AREA (Two columns) --- */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8 pb-8 border-b border-gray-200 dark:border-gray-700">
          {/* Left Side: Main Title and Description */}
          <header className="md:col-span-2">
            <h1 className="text-4xl font-bold text-gray-800 dark:text-gray-100">
              {primarySite.site_name_english}
            </h1>
            <p className="text-xl text-gray-500 dark:text-gray-400 mt-1">
              {primarySite.site_name_hebrew}
            </p>
            <p className="mt-4 text-sm text-gray-600 dark:text-gray-400 max-w-prose">
              This location serves as a key point of presence, hosting critical
              infrastructure for regional operations. It is engineered for high
              availability with fully redundant connections to the core network,
              ensuring uninterrupted service delivery and robust performance
              under all conditions.
            </p>
          </header>

          <section className="md:col-span-1">
            <h2 className="text-lg font-semibold text-gray-700 dark:text-gray-200 mb-2 text-center md:text-left">
              Site Topology
              {topologyStatus === "failed" && (
                <span className="text-xs text-amber-500 ml-2">(Fallback)</span>
              )}
            </h2>
            <div className="bg-gray-100 dark:bg-gray-700 p-2 rounded-lg shadow-md flex items-center justify-center min-h-[200px]">
              {topologyStatus === "loading" && <TopologyLoader />}

              {(topologyStatus === "succeeded" ||
                topologyStatus === "failed") && (
                <svg
                  viewBox="0 0 400 300"
                  className="w-full h-auto"
                  role="img"
                  aria-label={`Internal topology diagram for ${primarySite.site_name_english}`}
                >
                  {/* Use topologyData from state */}
                  {topologyData.links.map((link) => {
                    const sourceNode = nodeMap.get(link.source);
                    const targetNode = nodeMap.get(link.target);
                    if (!sourceNode || !targetNode) return null;
                    const strokeColor =
                      link.status === "up"
                        ? isDark
                          ? "stroke-green-400"
                          : "stroke-green-500"
                        : isDark
                        ? "stroke-red-400"
                        : "stroke-red-500";
                    return (
                      <line
                        key={link.id}
                        x1={sourceNode.x}
                        y1={sourceNode.y}
                        x2={targetNode.x}
                        y2={targetNode.y}
                        className={`${strokeColor} transition-colors`}
                        strokeWidth="2"
                      />
                    );
                  })}
                  {/* Use topologyData from state */}
                  {topologyData.nodes.map((node) => (
                    <g
                      key={node.id}
                      transform={`translate(${node.x}, ${node.y})`}
                    >
                      <circle
                        r="15"
                        className={`${
                          nodeColorMap[node.type] || "fill-gray-400"
                        } stroke-2 ${
                          isDark ? "stroke-gray-200" : "stroke-gray-900"
                        } transition-colors`}
                      />
                      <text
                        textAnchor="middle"
                        y="5"
                        className={`text-xs font-semibold ${
                          isDark ? "fill-gray-900" : "fill-white"
                        }`}
                      >
                        {node.name.split("-")[0].substring(0, 2)}
                      </text>
                    </g>
                  ))}
                </svg>
              )}
            </div>
          </section>
        </div>

        {/* --- MAIN CONTENT: Site Connections Table (Full Width) --- */}
        <section className="mt-12">
          <h2 className="text-2xl font-semibold text-gray-700 dark:text-gray-200 mb-4">
            Site Connections ({siteConnectionsData.length})
          </h2>
          <div className="overflow-x-auto shadow-md rounded-lg">
            <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700 border-collapse">
              <thead className="bg-gray-50 dark:bg-gray-700">
                <tr>
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    Status
                  </th>
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    Name
                  </th>
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    Description
                  </th>
                  <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                    Bandwidth
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                {siteConnectionsData.length > 0 ? (
                  siteConnectionsData.flatMap((connection) => {
                    const isSelected = expandedLinkId === connection.id;
                    return (
                      <React.Fragment key={connection.id}>
                        <tr
                          className={`hover:bg-gray-50 dark:hover:bg-gray-600 cursor-pointer transition-colors ${
                            isSelected
                              ? isDark
                                ? "bg-slate-700"
                                : "bg-slate-100"
                              : ""
                          }`}
                          onClick={() => handleLinkRowClick(connection.id)}
                        >
                          <td className="px-4 py-3">
                            <StatusBulb status={connection.status} />
                          </td>
                          <td className="px-4 py-3 font-medium text-gray-900 dark:text-gray-100">
                            {connection.name}
                          </td>
                          <td className="px-4 py-3 text-sm text-gray-700 dark:text-gray-300">
                            {connection.description}
                          </td>
                          <td className="px-4 py-3 text-sm text-gray-700 dark:text-gray-300">
                            {connection.bandwidth}
                          </td>
                        </tr>
                        {isSelected && (
                          <tr className="border-l-4 border-blue-500 dark:border-blue-400">
                            <LinkDetailRow
                              link={connection}
                              isParentSelectedAndDark={isDark}
                            />
                          </tr>
                        )}
                      </React.Fragment>
                    );
                  })
                ) : (
                  <tr>
                    <td colSpan="4" className="py-10 text-center">
                      No connections found.
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>
        </section>
      </div>
    </div>
  );
};

export default SiteDetailPage;

--- File: src\components\layout\AppLayout.jsx ---
import React, { useState, useEffect, useMemo } from "react";
import { Routes, Route, useLocation, useNavigate } from "react-router-dom";
import { useDispatch, useSelector } from "react-redux";
import { Star, LogOut } from "lucide-react";

// --- Redux Imports ---
import { logout } from "../../redux/slices/authSlice";
import {
  disconnect,
  selectRealtimeStatus,
} from "../../redux/slices/realtimeSlice";

// --- Helper Components & Hooks ---
import { useDashboardLogic } from "../../pages/useDashboardLogic";
import { Tabs, TabsList, TabsTrigger } from "../ui/tabs";
import { Sidebar } from "../ui/sidebar";

// --- Page Components ---
import { DashboardPage } from "../../pages/DashboardPage";
import { AdminPanelPage } from "../../pages/AdminPanelPage";
import { AlertsPage } from "../../pages/AlertsPage";
import SearchPage from "../../pages/SearchPage";

// --- Local Helper Components for this Layout ---

// Icons used for the fullscreen toggle in the header.
export const FullscreenIcon = ({ className = "w-5 h-5" }) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth={1.5}
    stroke="currentColor"
    className={className}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9.75 9.75M20.25 3.75v4.5m0-4.5h-4.5m4.5 0L14.25 9.75M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9.75 14.25m10.5 6.05v-4.5m0 4.5h-4.5m4.5 0L14.25 14.25"
    />
  </svg>
);

export const ExitFullscreenIcon = ({ className = "w-5 h-5" }) => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    strokeWidth={1.5}
    stroke="currentColor"
    className={className}
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9V4.5M15 9h4.5M15 9l5.25-5.25M15 15v4.5M15 15h4.5M15 15l5.25 5.25"
    />
  </svg>
);

// Real-time status indicator component
const RealtimeStatusIndicator = () => {
  const status = useSelector(selectRealtimeStatus);

  const config = {
    connected: { color: "bg-green-500", text: "Live" },
    connecting: { color: "bg-yellow-500", text: "Connecting" },
    disconnected: { color: "bg-red-500", text: "Offline" },
  }[status] || { color: "bg-gray-500", text: "Unknown" };

  return (
    <div
      className="flex items-center gap-2"
      title={`Real-time updates: ${config.text}`}
    >
      <div className={`w-2.5 h-2.5 rounded-full ${config.color} relative`}>
        {status === "connected" && (
          <div
            className={`absolute inset-0 w-full h-full rounded-full ${config.color} animate-ping`}
          ></div>
        )}
      </div>
      <span className="text-xs font-medium text-gray-500 dark:text-gray-400 hidden sm:inline">
        {config.text}
      </span>
    </div>
  );
};

// --- Main AppLayout Component ---

function AppLayout() {
  const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const location = useLocation();
  const dispatch = useDispatch();
  const navigate = useNavigate();

  const [theme, setTheme] = useState(
    document.documentElement.classList.contains("dark") ? "dark" : "light"
  );

  useEffect(() => {
    const observer = new MutationObserver(() => {
      setTheme(
        document.documentElement.classList.contains("dark") ? "dark" : "light"
      );
    });
    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });
    return () => observer.disconnect();
  }, []);

  const activePageLabel = useMemo(() => {
    const path = location.pathname;
    if (path.startsWith("/admin")) return "Admin Panel";
    if (path.startsWith("/search")) return "Search";
    if (path.startsWith("/notifications")) return "Alerts";
    if (path.startsWith("/help")) return "Help";
    if (path.startsWith("/settings")) return "Settings";
    return "Dashboard";
  }, [location.pathname]);

  const isDashboardActive = activePageLabel === "Dashboard";

  const dashboardLogic = useDashboardLogic({
    isAppFullscreen: isFullscreen,
    isSidebarCollapsed,
  });
  const { activeTabValue, handleTabChangeForNavigation } = dashboardLogic;

  const toggleFullscreen = () => {
    if (!isDashboardActive) return;
    setIsFullscreen(!isFullscreen);
  };

  const handleLogout = () => {
    // First, disconnect the real-time service to clean up the interval.
    dispatch(disconnect());
    // Then, clear the user's session data.
    dispatch(logout());
    // Finally, navigate back to the login page.
    navigate("/login", { replace: true });
  };

  const renderFullscreenToggleButton = () => {
    if (!isDashboardActive) return null;

    const ButtonIcon = isFullscreen ? ExitFullscreenIcon : FullscreenIcon;
    const buttonTitle = isFullscreen ? "Exit Fullscreen" : "Fullscreen";

    return (
      <button
        onClick={toggleFullscreen}
        title={buttonTitle}
        aria-label={buttonTitle}
        className="h-10 w-10 flex-shrink-0 flex items-center justify-center rounded-lg text-gray-500 hover:bg-gray-200 hover:text-gray-800 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-gray-200 transition-colors"
      >
        <ButtonIcon className="w-5 h-5" />
      </button>
    );
  };

  return (
    <div className="flex h-screen bg-gray-100 dark:bg-gray-950 text-gray-800 dark:text-gray-100 transition-colors overflow-hidden">
      {!isFullscreen && (
        <Sidebar
          currentPage={activePageLabel}
          collapsed={isSidebarCollapsed}
          setCollapsed={setIsSidebarCollapsed}
        />
      )}
      <main className="flex-1 flex flex-col relative">
        <header
          className={`bg-white dark:bg-gray-800 shrink-0 flex items-center gap-4 ${
            isFullscreen ? "p-4 border-b dark:border-gray-700" : "p-4 shadow-sm"
          }`}
        >
          <h1
            className={`text-2xl shrink-0 ${
              isFullscreen
                ? "font-extrabold text-white tracking-wide" // <-- This line is changed
                : "font-semibold text-gray-900 dark:text-white"
            }`}
          >
            {isFullscreen ? "SPIDERWEB" : activePageLabel}
          </h1>

          {isDashboardActive && (
            <div className="flex-1 flex justify-center">
              <Tabs
                value={activeTabValue}
                onValueChange={handleTabChangeForNavigation}
                className="w-full md:w-[750px] lg:w-[800px]"
              >
                <TabsList className="grid-cols-5">
                  <TabsTrigger
                    value="favorites"
                    className="flex items-center gap-1.5"
                  >
                    <Star className="h-4 w-4 text-yellow-500" /> Favorites
                  </TabsTrigger>
                  <TabsTrigger value="all_interfaces">
                    All Interfaces
                  </TabsTrigger>
                  <TabsTrigger value="l_network">L-chart</TabsTrigger>
                  <TabsTrigger value="p_network">P-chart</TabsTrigger>
                  <TabsTrigger value="site">Site</TabsTrigger>
                </TabsList>
              </Tabs>
            </div>
          )}

          {/* Wrapper for right-side action buttons */}
          <div className="flex items-center gap-4 ml-auto">
            <RealtimeStatusIndicator />
            {renderFullscreenToggleButton()}
            <button
              onClick={handleLogout}
              title="Log Out"
              aria-label="Log Out"
              className="h-10 w-10 flex-shrink-0 flex items-center justify-center rounded-lg text-gray-500 hover:bg-red-100 hover:text-red-600 dark:text-gray-400 dark:hover:bg-red-900/50 dark:hover:text-red-400 transition-colors"
            >
              <LogOut className="w-5 h-5" />
            </button>
          </div>
        </header>

        {/* Scrollable main content area */}
        <div
          className={`flex-1 min-h-0 overflow-y-auto ${
            theme === "dark"
              ? "dark-scrollbar dark-scrollbar-firefox"
              : "light-scrollbar light-scrollbar-firefox"
          } ${!isFullscreen && "p-4 md:p-6"}`}
        >
          <Routes>
            <Route path="/admin" element={<AdminPanelPage />} />
            <Route path="/search" element={<SearchPage />} />
            <Route path="/notifications" element={<AlertsPage />} />
            <Route
              path="/help"
              element={
                <div className="p-6 bg-white dark:bg-gray-800 rounded-lg shadow">
                  Help Page Content
                </div>
              }
            />
            <Route
              path="/settings"
              element={
                <div className="p-6 bg-white dark:bg-gray-800 rounded-lg shadow">
                  Settings Page Content
                </div>
              }
            />
            <Route
              path="/*"
              element={
                <DashboardPage
                  isAppFullscreen={isFullscreen}
                  activeTabValue={activeTabValue}
                  theme={theme}
                  popupAnchorCoords={dashboardLogic.popupAnchorCoords}
                  chartKeySuffix={dashboardLogic.chartKeySuffix}
                />
              }
            />
          </Routes>
        </div>
      </main>
    </div>
  );
}

export default AppLayout;

--- File: src\components\shared\LinkDetailTabs.jsx ---
import React, { useState, useEffect } from "react";
import { MdClose, MdArrowForward } from "react-icons/md";

/**
 * A reusable status indicator bulb.
 * @param {{ status: 'up' | 'down' | 'issue' | string }} props
 */
const StatusBulb = ({ status }) => {
  let bgColor = "bg-gray-400 dark:bg-gray-500";
  if (status === "up") bgColor = "bg-green-500 dark:bg-green-400";
  else if (status === "down") bgColor = "bg-red-500 dark:bg-red-400";
  else if (status === "issue") bgColor = "bg-yellow-500 dark:bg-yellow-400";

  return (
    <div className={`w-3.5 h-3.5 rounded-full ${bgColor} flex-shrink-0`}></div>
  );
};

// This helper component is kept for potential future use.
const DetailItem = ({ label, value, isDark }) => (
  <div>
    <p
      className={`text-xs uppercase tracking-wider ${
        isDark ? "text-gray-400" : "text-gray-500"
      }`}
    >
      {label}
    </p>
    <p className={`text-base ${isDark ? "text-gray-100" : "text-gray-800"}`}>
      {value || "N/A"}
    </p>
  </div>
);

/**
 * A tabbed interface with a bigger, bolder, modern style.
 * All functionality remains the same.
 */
const LinkDetailTabs = ({
  tabs,
  activeTabId,
  onSetActiveTab,
  onCloseTab,
  onNavigateToSite,
  theme,
}) => {
  const [isDetailExpanded, setIsDetailExpanded] = useState(false);

  const activeTab = tabs.find((tab) => tab.id === activeTabId);

  useEffect(() => {
    setIsDetailExpanded(false);
  }, [activeTabId]);

  if (!activeTab) {
    return null;
  }

  const handleClose = (e, tabId) => {
    e.stopPropagation();
    onCloseTab(tabId);
  };

  const handleNavigate = (e) => {
    e.stopPropagation();
    if (onNavigateToSite && activeTab.type === "site") {
      onNavigateToSite(activeTab.data);
    }
  };

  const isDark = theme === "dark";
  const itemData = activeTab.data;
  const itemType = activeTab.type;

  return (
    <div className="relative bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 shadow-sm z-20">
      {/* 1. Tab Bar - Updated with new styling */}
      <div className="flex items-end space-x-1 px-2 pt-2">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            onClick={() => onSetActiveTab(tab.id)}
            // START: STYLE CHANGE
            className={`flex items-center py-3 px-4 text-base font-bold border-b-4 rounded-t-lg transition-all duration-200
              ${
                activeTabId === tab.id
                  ? "bg-blue-100 dark:bg-gray-700 border-blue-500 text-blue-700 dark:text-blue-300"
                  : "border-transparent text-gray-500 dark:text-gray-400 hover:bg-gray-200/60 dark:hover:bg-gray-700/60 hover:border-gray-300 dark:hover:border-gray-600"
              }`}
            // END: STYLE CHANGE
          >
            <span>{tab.title}</span>
            <span
              onClick={(e) => handleClose(e, tab.id)}
              className="ml-4 p-1 rounded-full text-gray-400 hover:bg-gray-300/80 hover:text-gray-700 dark:hover:bg-gray-600 dark:hover:text-gray-200"
            >
              <MdClose size={18} />
            </span>
          </button>
        ))}
      </div>

      {/* 2. Content for the Active Tab (All internal logic and layout remains the same) */}
      <div className="p-4">
        {/* --- A. LINK TYPE CONTENT --- */}
        {itemType === "link" && itemData && (
          <>
            <div
              className={`flex items-center justify-between p-3 rounded-md cursor-pointer transition-colors ${
                isDark ? "hover:bg-gray-700" : "hover:bg-gray-100"
              } ${
                isDetailExpanded ? (isDark ? "bg-gray-700" : "bg-gray-100") : ""
              }`}
              onClick={() => setIsDetailExpanded(!isDetailExpanded)}
            >
              <div className="flex items-center space-x-4">
                <StatusBulb status={itemData.status} />
                <p className="text-lg font-semibold text-gray-800 dark:text-gray-100">
                  {itemData.name || "Unnamed Link"}
                </p>
              </div>
              <p className="text-base text-gray-600 dark:text-gray-400">
                Physical:{" "}
                <span className="font-medium text-gray-800 dark:text-gray-200">
                  Up
                </span>
              </p>
              <p className="text-base text-gray-600 dark:text-gray-400">
                Protocol:{" "}
                <span className="font-medium text-gray-800 dark:text-gray-200">
                  Up
                </span>
              </p>
              <p className="text-base text-gray-600 dark:text-gray-400">
                MPLS:{" "}
                <span className="font-medium text-gray-800 dark:text-gray-200">
                  Enabled
                </span>
              </p>
              <p className="text-base text-gray-600 dark:text-gray-400">
                OSPF:{" "}
                <span className="font-medium text-gray-800 dark:text-gray-200">
                  Full
                </span>
              </p>
              <p className="text-base text-gray-600 dark:text-gray-400">
                Bandwidth:{" "}
                <span className="font-medium text-gray-800 dark:text-gray-200">
                  10 Gbps
                </span>
              </p>
            </div>
            {isDetailExpanded && (
              <div className="flex flex-row flex-wrap justify-between items-center gap-y-2 p-4 mt-2 border-t border-gray-200 dark:border-gray-600">
                <div>
                  <span className="text-base text-gray-500 dark:text-gray-400 mr-2">
                    Description:
                  </span>
                  <span className="text-lg font-medium text-gray-800 dark:text-gray-100">
                    Core fiber link
                  </span>
                </div>
                <div>
                  <span className="text-base text-gray-500 dark:text-gray-400 mr-2">
                    Media Type:
                  </span>
                  <span className="text-lg font-medium text-gray-800 dark:text-gray-100">
                    Fiber Optic
                  </span>
                </div>
                <div>
                  <span className="text-base text-gray-500 dark:text-gray-400 mr-2">
                    CDP Neighbors:
                  </span>
                  <span className="text-lg font-medium text-gray-800 dark:text-gray-100">
                    2
                  </span>
                </div>
                <div>
                  <span className="text-base text-gray-500 dark:text-gray-400 mr-2">
                    TX:
                  </span>
                  <span className="text-lg font-medium text-gray-800 dark:text-gray-100">
                    8.2 Gbps
                  </span>
                </div>
                <div>
                  <span className="text-base text-gray-500 dark:text-gray-400 mr-2">
                    RX:
                  </span>
                  <span className="text-lg font-medium text-gray-800 dark:text-gray-100">
                    7.1 Gbps
                  </span>
                </div>
              </div>
            )}
          </>
        )}

        {/* --- B. SITE TYPE CONTENT --- */}
        {itemType === "site" && itemData && (
          <>
            <div
              className={`flex items-center justify-between p-3 rounded-md cursor-pointer transition-colors ${
                isDark ? "hover:bg-gray-700" : "hover:bg-gray-100"
              } ${
                isDetailExpanded ? (isDark ? "bg-gray-700" : "bg-gray-100") : ""
              }`}
              onClick={() => setIsDetailExpanded(!isDetailExpanded)}
            >
              <div className="flex items-center space-x-4">
                <StatusBulb
                  status={itemData.protocolStatus === "Up" ? "up" : "down"}
                />
                <p className="text-lg font-semibold text-gray-800 dark:text-gray-100">
                  {itemData.name || "Unnamed Site"}
                </p>
              </div>
              <p className="text-base text-gray-600 dark:text-gray-400">
                Physical:{" "}
                <span className="font-medium text-gray-800 dark:text-gray-200">
                  Up
                </span>
              </p>
              <p className="text-base text-gray-600 dark:text-gray-400">
                Protocol:{" "}
                <span className="font-medium text-gray-800 dark:text-gray-200">
                  {itemData.protocolStatus}
                </span>
              </p>
              <p className="text-base text-gray-600 dark:text-gray-400">
                MPLS:{" "}
                <span className="font-medium text-gray-800 dark:text-gray-200">
                  {itemData.mplsStatus}
                </span>
              </p>
              <p className="text-base text-gray-600 dark:text-gray-400">
                OSPF:{" "}
                <span className="font-medium text-gray-800 dark:text-gray-200">
                  {itemData.ospfStatus}
                </span>
              </p>
              <p className="text-base text-gray-600 dark:text-gray-400">
                Bandwidth:{" "}
                <span className="font-medium text-gray-800 dark:text-gray-200">
                  100 Gbps
                </span>
              </p>
              <button
                onClick={handleNavigate}
                className="flex items-center gap-2 px-4 py-2 text-sm font-semibold text-white bg-blue-600 rounded-md shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75"
              >
                Go to Site Details
                <MdArrowForward />
              </button>
            </div>
            {isDetailExpanded && (
              <div className="flex flex-row flex-wrap justify-between items-center gap-y-2 p-4 mt-2 border-t border-gray-200 dark:border-gray-600">
                <div>
                  <span className="text-base text-gray-500 dark:text-gray-400 mr-2">
                    Description:
                  </span>
                  <span className="text-lg font-medium text-gray-800 dark:text-gray-100">
                    {itemData.description || "N/A"}
                  </span>
                </div>
                <div>
                  <span className="text-base text-gray-500 dark:text-gray-400 mr-2">
                    Media Type:
                  </span>
                  <span className="text-lg font-medium text-gray-800 dark:text-gray-100">
                    {itemData.mediaType || "N/A"}
                  </span>
                </div>
                <div>
                  <span className="text-base text-gray-500 dark:text-gray-400 mr-2">
                    CDP Neighbors:
                  </span>
                  <span className="text-lg font-medium text-gray-800 dark:text-gray-100">
                    {itemData.cdpNeighbors || "N/A"}
                  </span>
                </div>
                <div>
                  <span className="text-base text-gray-500 dark:text-gray-400 mr-2">
                    TX:
                  </span>
                  <span className="text-lg font-medium text-gray-800 dark:text-gray-100">
                    98.5 Gbps
                  </span>
                </div>
                <div>
                  <span className="text-base text-gray-500 dark:text-gray-400 mr-2">
                    RX:
                  </span>
                  <span className="text-lg font-medium text-gray-800 dark:text-gray-100">
                    95.1 Gbps
                  </span>
                </div>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
};

export default LinkDetailTabs;

--- File: src\components\shared\StatusBulb.jsx ---
// src/components/StatusBulb.jsx (or similar path)
import React from "react";

const StatusBulb = ({ status }) => {
  let bgColor = "bg-gray-400 dark:bg-gray-500";
  let title = "Unknown";

  if (status === "up") {
    bgColor = "bg-green-500 dark:bg-green-400";
    title = "Up";
  } else if (status === "down") {
    bgColor = "bg-red-500 dark:bg-red-400";
    title = "Down";
  } else if (status === "issue") {
    bgColor = "bg-yellow-500 dark:bg-yellow-400";
    title = "Issue";
  }

  return (
    <div
      className={`w-4 h-4 rounded-full ${bgColor} flex-shrink-0`}
      title={title}
    ></div>
  );
};

export default StatusBulb;

--- File: src\components\ui\button.jsx ---
import React from "react";

export function Button({ children, onClick, type = "button", className = "" }) {
  return (
    <button
      type={type}
      onClick={onClick}
      className={`px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors ${className}`}
    >
      {children}
    </button>
  );
}

--- File: src\components\ui\card.jsx ---
import React from "react";

export function Card({ children, className = "" }) {
  return (
    <div
      className={`bg-white dark:bg-gray-800 shadow-md rounded-xl border dark:border-gray-700 p-4 ${className}`}
    >
      {children}
    </div>
  );
}

export function CardContent({ children, className = "" }) {
  return <div className={`p-2 ${className}`}>{children}</div>;
}

--- File: src\components\ui\dark-mode-toggle.jsx ---
import React, { useEffect, useState } from "react";
import { MdDarkMode, MdLightMode } from "react-icons/md";

export function DarkModeToggle({ collapsed }) {
  const [isDark, setIsDark] = useState(false);

  useEffect(() => {
    setIsDark(document.documentElement.classList.contains("dark"));
  }, []);

  const toggleDark = () => {
    const isNowDark = !isDark;
    document.documentElement.classList.toggle("dark", isNowDark);
    setIsDark(isNowDark);
  };

  const Icon = isDark ? <MdLightMode size={20} /> : <MdDarkMode size={20} />;
  const label = isDark ? "Light Mode" : "Dark Mode";

  return (
    <button
      onClick={toggleDark}
      className="flex items-center gap-3 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800 px-3 py-2 rounded-md w-full transition"
    >
      <span className="text-xl">{Icon}</span>
      {!collapsed && <span>{label}</span>}
    </button>
  );
}

--- File: src\components\ui\sidebar.jsx ---
import React from "react";
import { Link } from "react-router-dom";
import {
  MdDashboard,
  MdAdminPanelSettings,
  MdSearch,
  MdNotifications,
  MdHelp,
  MdSettings,
  MdChevronLeft,
  MdChevronRight,
} from "react-icons/md";
import { DarkModeToggle } from "../ui/dark-mode-toggle";

// Map labels to URL paths for clean routing
const navLinks = {
  Dashboard: "/",
  Search: "/search",
  "Admin Panel": "/admin",
  Notifications: "/notifications",
  Help: "/help",
  Settings: "/settings",
};

// NavItem component remains unchanged
function NavItem({ label, icon, collapsed, active }) {
  return (
    <Link
      to={navLinks[label] || "/"}
      className={`flex items-center gap-3 text-sm px-3 py-2 rounded-md w-full transition
    ${
      active
        ? "bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-white font-semibold"
        : "text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800"
    }`}
    >
      <span className="text-xl">{icon}</span>
      {!collapsed && <span className="truncate">{label}</span>}
    </Link>
  );
}

// Main Sidebar component with the updated title style
export function Sidebar({ currentPage, collapsed, setCollapsed }) {
  const navItems = [
    { label: "Dashboard", icon: <MdDashboard size={20} /> },
    { label: "Search", icon: <MdSearch size={20} /> },
    { label: "Admin Panel", icon: <MdAdminPanelSettings size={20} /> },
    { label: "Notifications", icon: <MdNotifications size={20} /> },
  ];

  const footerItems = [
    { label: "Help", icon: <MdHelp size={20} /> },
    { label: "Settings", icon: <MdSettings size={20} /> },
  ];

  return (
    <div
      className={`h-screen ${
        collapsed ? "w-16" : "w-60"
      } bg-white dark:bg-gray-900 border-r dark:border-gray-700 shadow-sm flex flex-col transition-all duration-300`}
    >
      {/* --- HEADER SECTION (THIS IS WHERE THE CHANGE IS) --- */}
      <div className="flex items-center justify-between p-4 border-b dark:border-gray-700 shrink-0">
        {!collapsed && (
          // The plain text div is replaced with this styled h1
          <h1 className="text-2xl font-extrabold text-white tracking-wide">
            SPIDERWEB
          </h1>
        )}
        <button
          onClick={() => setCollapsed(!collapsed)}
          className="text-gray-500 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white"
        >
          {collapsed ? (
            <MdChevronRight size={24} />
          ) : (
            <MdChevronLeft size={24} />
          )}
        </button>
      </div>

      {/* Main Navigation (unchanged) */}
      <nav className="flex-1 flex flex-col space-y-1 p-2 overflow-y-auto">
        {navItems.map((item) => (
          <NavItem
            key={item.label}
            label={item.label}
            icon={item.icon}
            collapsed={collapsed}
            active={currentPage === item.label}
          />
        ))}
      </nav>

      {/* Footer Navigation (unchanged) */}
      <div className="px-2 py-2 border-t dark:border-gray-700 shrink-0">
        {footerItems.map((item) => (
          <NavItem
            key={item.label}
            label={item.label}
            icon={item.icon}
            collapsed={collapsed}
            active={currentPage === item.label}
          />
        ))}
        <div className="mt-2">
          <DarkModeToggle collapsed={collapsed} />
        </div>
      </div>
    </div>
  );
}

--- File: src\components\ui\table.jsx ---
import React from "react";

export function Table({ children, className = "" }) {
  return (
    <table className={`min-w-full text-sm text-left ${className}`}>
      {children}
    </table>
  );
}

export function TableHeader({ children, className = "" }) {
  return (
    <thead className={`bg-gray-100 dark:bg-gray-800 ${className}`}>
      {children}
    </thead>
  );
}

export function TableHead({ children, className = "" }) {
  return (
    <th
      className={`px-4 py-2 font-semibold text-gray-700 dark:text-gray-200 ${className}`}
    >
      {children}
    </th>
  );
}

export function TableBody({ children, className = "" }) {
  return <tbody className={className}>{children}</tbody>;
}

export function TableRow({ children, className = "" }) {
  return (
    <tr
      className={`border-b dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800 ${className}`}
    >
      {children}
    </tr>
  );
}

export function TableCell({ children, className = "" }) {
  return (
    <td className={`px-4 py-2 text-gray-700 dark:text-gray-200 ${className}`}>
      {children}
    </td>
  );
}

--- File: src\components\ui\tabs.jsx ---
import React, { useContext, createContext } from "react";

// The main Tabs component logic for controlled/uncontrolled state remains the same.
const TabsContext = createContext(undefined);

export function Tabs({
  children,
  value,
  defaultValue,
  onValueChange,
  className = "",
}) {
  const isControlled = value !== undefined;
  const [internalActiveTab, setInternalActiveTab] =
    React.useState(defaultValue);
  const activeTab = isControlled ? value : internalActiveTab;

  const handleTabChange = (newTabValue) => {
    if (!isControlled) {
      setInternalActiveTab(newTabValue);
    }
    if (onValueChange) {
      onValueChange(newTabValue);
    }
  };

  const contextValue = { activeTab, setActiveTab: handleTabChange };

  return (
    <TabsContext.Provider value={contextValue}>
      <div className={className}>{children}</div>
    </TabsContext.Provider>
  );
}

export function TabsList({ children, className = "" }) {
  return (
    <div
      className={`grid items-center justify-center rounded-lg bg-gray-100 p-1 text-gray-500 dark:bg-gray-800 ${className}`}
      role="tablist"
    >
      {children}
    </div>
  );
}

export function TabsTrigger({ value, children, className = "" }) {
  const context = useContext(TabsContext);
  if (context === undefined) {
    throw new Error("TabsTrigger must be used within a Tabs component");
  }
  const { activeTab, setActiveTab: contextSetActiveTab } = context;
  const isActive = activeTab === value;

  return (
    <button
      onClick={() => contextSetActiveTab(value)}
      className={`inline-flex items-center justify-center whitespace-nowrap rounded-md px-4 py-2 text-base font-medium
      ring-offset-white dark:ring-offset-gray-950
      focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2
      disabled:pointer-events-none disabled:opacity-50
      transition-all duration-200 ease-in-out
      ${
        isActive
          ? "bg-white dark:bg-gray-950 text-gray-900 dark:text-gray-50 shadow-sm"
          : "hover:text-gray-800 dark:hover:text-gray-200"
      }
      ${className}`}
      data-state={isActive ? "active" : "inactive"}
      role="tab"
      aria-selected={isActive}
    >
      {children}
    </button>
  );
}

export function TabsContent({ value, children, className = "" }) {
  const context = useContext(TabsContext);
  if (context === undefined) {
    throw new Error("TabsContent must be used within a TabsProvider");
  }
  const { activeTab } = context;

  if (activeTab !== value) return null;

  return (
    <div className={`mt-4 ${className}`} role="tabpanel">
      {children}
    </div>
  );
}

--- File: src\components\ui\VirtualizedTable.jsx ---
import React, { useRef } from "react";
import { useVirtualizer } from "@tanstack/react-virtual";
import { TableSkeleton } from "./feedback/TableSkeleton"; // We'll reuse our skeleton loader

/**
 * A reusable, high-performance virtualized table component.
 * It uses divs with ARIA roles for maximum rendering flexibility and performance.
 *
 * @param {object[]} data - The array of data to render.
 * @param {object[]} columns - An array of column definitions.
 *   Each column object should have:
 *   - `header`: The string or JSX for the column header.
 *   - `accessorKey`: The key in the data object for this column.
 *   - `cell`: A render function for the cell: (info) => JSX.
 *   - `size`: The flex-grow proportion for the column (e.g., 1, 2, 3).
 * @param {boolean} isLoading - If true, shows a skeleton loader.
 * @param {React.ReactNode} emptyMessage - JSX to display when data is empty.
 */
export function VirtualizedTable({ data, columns, isLoading, emptyMessage }) {
  const parentRef = useRef(null);

  const rowVirtualizer = useVirtualizer({
    count: data.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 64,
    overscan: 5,
  });

  if (isLoading) {
    return <TableSkeleton rows={10} cols={columns.length} />;
  }

  if (!data.length) {
    return <div className="p-4">{emptyMessage}</div>;
  }

  return (
    <div
      ref={parentRef}
      role="grid"
      className="h-full w-full overflow-auto border dark:border-gray-700/50 rounded-lg"
    >
      {/* Header */}
      <div
        role="rowheader"
        className="flex sticky top-0 z-10 bg-gray-100/80 dark:bg-gray-800/80 backdrop-blur-sm border-b dark:border-gray-700/50"
      >
        {columns.map((column) => (
          <div
            key={column.accessorKey}
            role="columnheader"
            className="px-4 py-3 font-semibold text-left text-gray-600 dark:text-gray-300"
            // 👇 CHANGE HERE: Use flex-basis: 0% to ensure columns align perfectly
            style={{ flex: `${column.size} 0 0%` }}
          >
            {column.header}
          </div>
        ))}
      </div>

      {/* Body */}
      <div
        className="relative w-full"
        style={{
          height: `${rowVirtualizer.getTotalSize()}px`,
        }}
      >
        {rowVirtualizer.getVirtualItems().map((virtualRow) => {
          const row = data[virtualRow.index];
          return (
            <div
              key={virtualRow.key}
              role="row"
              className="flex absolute top-0 left-0 w-full items-center border-b dark:border-gray-800/50 hover:bg-gray-50 dark:hover:bg-gray-800/20"
              style={{
                height: `${virtualRow.size}px`,
                transform: `translateY(${virtualRow.start}px)`,
              }}
            >
              {columns.map((column) => (
                <div
                  key={column.accessorKey}
                  role="gridcell"
                  className="px-4 py-2 truncate"
                  // 👇 CHANGE HERE: Use flex-basis: 0% to ensure columns align perfectly
                  style={{ flex: `${column.size} 0 0%` }}
                >
                  {column.cell({ row })}
                </div>
              ))}
            </div>
          );
        })}
      </div>
    </div>
  );
}

--- File: src\components\ui\feedback\ErrorMessage.jsx ---
import React from "react";
import { AlertTriangle } from "lucide-react";

export const ErrorMessage = ({
  onRetry,
  message = "An error occurred while fetching data.",
}) => (
  <div className="flex flex-col items-center justify-center h-full w-full p-8 text-center">
    <AlertTriangle className="h-12 w-12 text-red-500" />
    <p className="mt-4 text-lg font-semibold text-red-600 dark:text-red-400">
      Loading Failed
    </p>
    <p className="mt-2 text-gray-600 dark:text-gray-400 max-w-md">
      {message} Please check your network connection and try again.
    </p>
    {onRetry && (
      <button
        onClick={onRetry}
        className="mt-6 px-6 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 transition-colors"
      >
        Retry
      </button>
    )}
  </div>
);

--- File: src\components\ui\feedback\GridSkeleton.jsx ---
import React from "react";

const SkeletonCard = () => (
  <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md border border-gray-200 dark:border-gray-700/50">
    <div className="h-5 w-3/4 bg-gray-300 dark:bg-gray-600 rounded"></div>
    <div className="h-4 w-1/2 bg-gray-200 dark:bg-gray-700 rounded mt-2"></div>
    <div className="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700 space-y-3">
      <div className="h-4 w-5/6 bg-gray-200 dark:bg-gray-700 rounded"></div>
      <div className="h-4 w-4/6 bg-gray-200 dark:bg-gray-700 rounded"></div>
    </div>
  </div>
);

export const GridSkeleton = ({ count = 10 }) => (
  <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-5 animate-pulse">
    {Array.from({ length: count }).map((_, i) => (
      <SkeletonCard key={i} />
    ))}
  </div>
);

--- File: src\components\ui\feedback\LoadingSpinner.jsx ---
import React from "react";
import { Loader2 } from "lucide-react";

export const LoadingSpinner = ({ text = "Loading..." }) => (
  <div className="flex flex-col items-center justify-center h-full w-full p-8 text-center">
    <Loader2 className="h-10 w-10 animate-spin text-blue-500" />
    <p className="mt-4 text-lg font-semibold text-gray-700 dark:text-gray-300">
      {text}
    </p>
  </div>
);

--- File: src\components\ui\feedback\TableSkeleton.jsx ---
import React from "react";

export const TableSkeleton = ({ rows = 5, cols = 5 }) => {
  return (
    <div className="w-full space-y-3 animate-pulse">
      {/* Header */}
      <div className="h-10 bg-gray-200 dark:bg-gray-700/50 rounded-md"></div>
      {/* Body Rows */}
      <div className="space-y-2">
        {Array.from({ length: rows }).map((_, i) => (
          <div key={i} className="grid grid-cols-5 gap-4">
            {Array.from({ length: cols }).map((_, j) => (
              <div
                key={j}
                className={`h-8 bg-gray-200 dark:bg-gray-700 rounded-md ${
                  j === 0 ? "col-span-2" : ""
                }`}
              ></div>
            ))}
          </div>
        ))}
      </div>
    </div>
  );
};

--- File: src\hooks\useBreakpoint.jsx ---
import { useState, useEffect } from "react";
import resolveConfig from "tailwindcss/resolveConfig";
import tailwindConfig from "../../tailwind.config.js"; // Adjust path if your tailwind.config.js is elsewhere

const fullConfig = resolveConfig(tailwindConfig);

const getBreakpointValue = (value) =>
  +fullConfig.theme.screens[value].slice(0, -2);

const getCurrentBreakpoint = () => {
  let currentBreakpoint = "sm";
  let biggestBreakpointValue = 0;
  for (const breakpoint of Object.keys(fullConfig.theme.screens)) {
    const breakpointValue = getBreakpointValue(breakpoint);
    if (
      breakpointValue > biggestBreakpointValue &&
      window.innerWidth >= breakpointValue
    ) {
      biggestBreakpointValue = breakpointValue;
      currentBreakpoint = breakpoint;
    }
  }
  return currentBreakpoint;
};

export function useBreakpoint() {
  const [breakpoint, setBreakpoint] = useState("sm");

  useEffect(() => {
    setBreakpoint(getCurrentBreakpoint());
    const calcInnerWidth = () => {
      setBreakpoint(getCurrentBreakpoint());
    };
    window.addEventListener("resize", calcInnerWidth);
    return () => window.removeEventListener("resize", calcInnerWidth);
  }, []);

  return breakpoint;
}

--- File: src\hooks\useRelatedDevices.jsx ---
import { useMemo } from "react";
import { useSelector } from "react-redux";
import { selectAllDevices } from "../redux/slices/devicesSlice";
import { selectAllPikudim } from "../redux/slices/corePikudimSlice";

export function useRelatedDevices(currentDeviceName, currentZoneName) {
  const allDevices = useSelector(selectAllDevices);
  const allPikudim = useSelector(selectAllPikudim);

  const relatedDevices = useMemo(() => {
    // This console.log is great for debugging
    // console.log("Hook called with:", { currentDeviceName, currentZoneName });

    if (
      !currentDeviceName ||
      !currentZoneName ||
      !allDevices.length ||
      !allPikudim.length
    ) {
      return [];
    }

    const currentPikud = allPikudim.find(
      (p) => p.core_site_name === currentZoneName
    );
    if (!currentPikud) {
      // console.log("Could not find Pikud for zone:", currentZoneName);
      return [];
    }
    const currentPikudId = currentPikud.id;
    // console.log("Found Pikud ID:", currentPikudId);

    const devicesInSamePikud = allDevices.filter(
      // --- THIS IS THE FIX ---
      // Corrected 'core_pukudim_site_id' to 'core_pikudim_site_id'
      (device) => device.core_pikudim_site_id === currentPikudId
    );
    // console.log("Found devices in same Pikud:", devicesInSamePikud);

    const otherDevices = devicesInSamePikud.filter(
      (device) => device.hostname !== currentDeviceName
    );
    // console.log("Found OTHER devices:", otherDevices);

    return otherDevices.map((device) => ({
      ...device,
      zoneName: currentZoneName,
    }));
  }, [currentDeviceName, currentZoneName, allDevices, allPikudim]);

  return relatedDevices;
}

--- File: src\pages\AdminPanelPage.jsx ---
import React, { useState } from "react";
import { useDispatch, useSelector } from "react-redux";
// Assuming you have updated your slices to export the async thunks
import {
  addCoreDevice,
  deleteCoreDevice,
  selectAllDevices,
} from "../redux/slices/devicesSlice";
import {
  addCoreSite,
  deleteCoreSite,
  selectAllPikudim,
} from "../redux/slices/corePikudimSlice";
import {
  addNetType,
  deleteNetType,
  selectAllNetTypes,
} from "../redux/slices/netTypesSlice";
import { MdSettings, MdDelete } from "react-icons/md";

// Reusable Input Field Component (Unchanged)
const InputField = ({
  label,
  id,
  type = "text",
  value,
  onChange,
  placeholder,
  required = false,
}) => (
  <div className="mb-4">
    <label
      htmlFor={id}
      className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
    >
      {label} {required && <span className="text-red-500">*</span>}
    </label>
    <input
      type={type}
      id={id}
      name={id}
      value={value}
      onChange={onChange}
      placeholder={placeholder}
      required={required}
      className="mt-1 block w-full px-3 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 sm:text-sm text-gray-900 dark:text-gray-100"
    />
  </div>
);

// Reusable Select Field Component (Unchanged)
const SelectField = ({
  label,
  id,
  value,
  onChange,
  options,
  required = false,
}) => (
  <div className="mb-4">
    <label
      htmlFor={id}
      className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
    >
      {label} {required && <span className="text-red-500">*</span>}
    </label>
    <select
      id={id}
      name={id}
      value={value}
      onChange={onChange}
      required={required}
      className="mt-1 block w-full px-3 py-2 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 sm:text-sm text-gray-900 dark:text-gray-100"
    >
      <option value="">-- Select --</option>
      {options.map((option) => (
        <option key={option.value} value={option.value}>
          {option.label}
        </option>
      ))}
    </select>
  </div>
);

export function AdminPanelPage() {
  const dispatch = useDispatch();
  const allCoreSites = useSelector(selectAllPikudim);
  const allDevices = useSelector(selectAllDevices);
  const allNetTypes = useSelector(selectAllNetTypes);

  const [isSubmitting, setIsSubmitting] = useState(false);
  const [activeAddSection, setActiveAddSection] = useState(null);
  const [activeDeleteSection, setActiveDeleteSection] = useState(null);
  const [itemToDelete, setItemToDelete] = useState("");

  const [coreSiteData, setCoreSiteData] = useState({
    name: "",
    type_id: "",
  });
  const [coreDeviceData, setCoreDeviceData] = useState({
    hostname: "",
    ip_address: "",
    network_type_id: "",
    core_pikudim_site_id: "",
  });
  const [netTypeData, setNetTypeData] = useState({ name: "" });

  const coreSiteOptions = allCoreSites.map((site) => ({
    value: site.id,
    label: site.core_site_name,
  }));
  const deviceOptions = allDevices.map((d) => ({
    value: d.id,
    label: d.hostname,
  }));
  const netTypeOptions = allNetTypes.map((nt) => ({
    value: nt.id,
    label: nt.name,
  }));

  // --- ASYNC EVENT HANDLERS ---
  const handleSubmit = async (
    e,
    thunk,
    payload,
    successMessage,
    formResetCallback
  ) => {
    e.preventDefault();
    setIsSubmitting(true);
    try {
      await dispatch(thunk(payload)).unwrap();
      alert(successMessage);
      formResetCallback();
    } catch (error) {
      alert(`Error: ${error.message || "An unknown error occurred."}`);
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleDelete = async (deleteThunk, entityName) => {
    if (!itemToDelete) {
      alert(`Please select a ${entityName} to delete.`);
      return;
    }
    if (
      !window.confirm(
        `Are you sure you want to delete this ${entityName}? This action is irreversible.`
      )
    ) {
      return;
    }
    setIsSubmitting(true);
    try {
      await dispatch(deleteThunk(parseInt(itemToDelete, 10))).unwrap();
      alert(`${entityName} deleted successfully!`);
      setItemToDelete("");
    } catch (error) {
      alert(
        `Error deleting ${entityName}: ${
          error.message || "An unknown error occurred."
        }`
      );
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleSetDeleteSection = (section) => {
    setActiveDeleteSection(section);
    setItemToDelete("");
  };

  const renderAddSectionForm = () => {
    switch (activeAddSection) {
      case "coreSite":
        return (
          <form
            onSubmit={(e) =>
              handleSubmit(
                e,
                addCoreSite,
                {
                  name: coreSiteData.name, // Changed from core_site_name
                  site_type_id: parseInt(coreSiteData.type_id, 10), // Changed from type_id
                  // "location" is removed as it's not in the backend spec
                },
                `Core Site "${coreSiteData.name}" submitted!`,
                () => setCoreSiteData({ name: "", type_id: "" })
              )
            }
            className="mt-6 space-y-4 p-6 bg-gray-50 dark:bg-gray-800/50 border border-gray-200 dark:border-gray-700 rounded-lg"
          >
            <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200">
              Add New Core Site
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-x-6">
              <InputField
                label="Site Name"
                id="name"
                value={coreSiteData.name}
                onChange={(e) =>
                  setCoreSiteData({ ...coreSiteData, name: e.target.value })
                }
                required
              />
              <SelectField
                label="Type"
                id="type_id"
                value={coreSiteData.type_id}
                onChange={(e) =>
                  setCoreSiteData({ ...coreSiteData, type_id: e.target.value })
                }
                options={[
                  { value: 1, label: "L-Chart" },
                  { value: 2, label: "P-Chart" },
                ]}
                required
              />
            </div>
            <button
              type="submit"
              disabled={isSubmitting}
              className="w-full sm:w-auto px-6 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isSubmitting ? "Submitting..." : "Add Core Site"}
            </button>
          </form>
        );
      case "coreDevice":
        return (
          <form
            onSubmit={(e) =>
              handleSubmit(
                e,
                addCoreDevice,
                {
                  hostname: coreDeviceData.hostname,
                  ip: coreDeviceData.ip_address, // Changed from ip_address
                  device_net_type: parseInt(coreDeviceData.network_type_id, 10), // Changed from network_type_id
                  site_id: parseInt(coreDeviceData.core_pikudim_site_id, 10), // Changed from core_pikudim_site_id
                },
                `Device "${coreDeviceData.hostname}" submitted!`,
                () =>
                  setCoreDeviceData({
                    hostname: "",
                    ip_address: "",
                    network_type_id: "",
                    core_pikudim_site_id: "",
                  })
              )
            }
            className="mt-6 space-y-4 p-6 bg-gray-50 dark:bg-gray-800/50 border border-gray-200 dark:border-gray-700 rounded-lg"
          >
            <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200">
              Add New Core Device
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-x-6">
              <InputField
                label="Hostname"
                id="hostname"
                value={coreDeviceData.hostname}
                onChange={(e) =>
                  setCoreDeviceData({
                    ...coreDeviceData,
                    hostname: e.target.value,
                  })
                }
                required
              />
              <InputField
                label="IP Address"
                id="ip_address"
                value={coreDeviceData.ip_address}
                onChange={(e) =>
                  setCoreDeviceData({
                    ...coreDeviceData,
                    ip_address: e.target.value,
                  })
                }
                required
              />
              <SelectField
                label="Associated Core Site"
                id="core_pikudim_site_id"
                value={coreDeviceData.core_pikudim_site_id}
                onChange={(e) =>
                  setCoreDeviceData({
                    ...coreDeviceData,
                    core_pikudim_site_id: e.target.value,
                  })
                }
                options={coreSiteOptions}
                required
              />
              <SelectField
                label="Network Type"
                id="network_type_id"
                value={coreDeviceData.network_type_id}
                onChange={(e) =>
                  setCoreDeviceData({
                    ...coreDeviceData,
                    network_type_id: e.target.value,
                  })
                }
                options={netTypeOptions}
                required
              />
            </div>
            <button
              type="submit"
              disabled={isSubmitting}
              className="w-full sm:w-auto px-6 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isSubmitting ? "Submitting..." : "Add Core Device"}
            </button>
          </form>
        );
      case "netType":
        return (
          <form
            onSubmit={(e) =>
              handleSubmit(
                e,
                addNetType,
                { name: netTypeData.name },
                `Net Type "${netTypeData.name}" submitted!`,
                () => setNetTypeData({ name: "" })
              )
            }
            className="mt-6 space-y-4 p-6 bg-gray-50 dark:bg-gray-800/50 border border-gray-200 dark:border-gray-700 rounded-lg"
          >
            <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200">
              Add New Net Type
            </h3>
            <div>
              <InputField
                label="Net Type Name"
                id="netTypeName"
                value={netTypeData.name}
                onChange={(e) =>
                  setNetTypeData({ ...netTypeData, name: e.target.value })
                }
                required
              />
            </div>
            <button
              type="submit"
              disabled={isSubmitting}
              className="w-full sm:w-auto px-6 py-2 bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isSubmitting ? "Submitting..." : "Add Net Type"}
            </button>
          </form>
        );
      default:
        return (
          <div className="text-center py-16 px-4 mt-6 border-2 border-dashed border-gray-300 dark:border-gray-700 rounded-lg">
            <MdSettings
              size={56}
              className="mx-auto text-gray-400 dark:text-gray-500 mb-4"
            />
            <p className="text-xl font-semibold text-gray-600 dark:text-gray-400">
              Admin Control
            </p>
            <p className="text-md text-gray-500 dark:text-gray-500 mt-2">
              Select an action above to manage system entities.
            </p>
          </div>
        );
    }
  };

  const renderDeleteSectionForm = () => {
    switch (activeDeleteSection) {
      case "deleteCoreSite":
        return (
          <form
            onSubmit={(e) => e.preventDefault()}
            className="mt-6 space-y-4 p-6 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800/50 rounded-lg"
          >
            <h3 className="text-xl font-semibold text-red-800 dark:text-red-200">
              Delete Core Site
            </h3>
            <SelectField
              label="Select Core Site to Delete"
              id="delete_site_id"
              value={itemToDelete}
              onChange={(e) => setItemToDelete(e.target.value)}
              options={coreSiteOptions}
              required
            />
            <button
              onClick={() => handleDelete(deleteCoreSite, "Core Site")}
              disabled={isSubmitting || !itemToDelete}
              className="w-full sm:w-auto px-6 py-2 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isSubmitting ? "Deleting..." : "Delete Core Site"}
            </button>
          </form>
        );
      case "deleteDevice":
        return (
          <form
            onSubmit={(e) => e.preventDefault()}
            className="mt-6 space-y-4 p-6 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800/50 rounded-lg"
          >
            <h3 className="text-xl font-semibold text-red-800 dark:text-red-200">
              Delete Core Device
            </h3>
            <SelectField
              label="Select Device to Delete"
              id="delete_device_id"
              value={itemToDelete}
              onChange={(e) => setItemToDelete(e.target.value)}
              options={deviceOptions}
              required
            />
            <button
              onClick={() => handleDelete(deleteCoreDevice, "Device")}
              disabled={isSubmitting || !itemToDelete}
              className="w-full sm:w-auto px-6 py-2 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isSubmitting ? "Deleting..." : "Delete Core Device"}
            </button>
          </form>
        );
      case "deleteNetType":
        return (
          <form
            onSubmit={(e) => e.preventDefault()}
            className="mt-6 space-y-4 p-6 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800/50 rounded-lg"
          >
            <h3 className="text-xl font-semibold text-red-800 dark:text-red-200">
              Delete Net Type
            </h3>
            <SelectField
              label="Select Net Type to Delete"
              id="delete_nettype_id"
              value={itemToDelete}
              onChange={(e) => setItemToDelete(e.target.value)}
              options={netTypeOptions}
              required
            />
            <button
              onClick={() => handleDelete(deleteNetType, "Net Type")}
              disabled={isSubmitting || !itemToDelete}
              className="w-full sm:w-auto px-6 py-2 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isSubmitting ? "Deleting..." : "Delete Net Type"}
            </button>
          </form>
        );
      default:
        return (
          <div className="text-center py-16 px-4 mt-6 border-2 border-dashed border-gray-300 dark:border-gray-700 rounded-lg">
            <MdDelete
              size={56}
              className="mx-auto text-gray-400 dark:text-gray-500 mb-4"
            />
            <p className="text-xl font-semibold text-gray-600 dark:text-gray-400">
              Deletion Zone
            </p>
            <p className="text-md text-gray-500 dark:text-gray-500 mt-2">
              Select an item type above to delete an entity. This action is
              irreversible.
            </p>
          </div>
        );
    }
  };

  return (
    <div className="p-6 bg-gray-50 dark:bg-gray-900 min-h-full space-y-8">
      <header className="mb-6">
        <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-100">
          Admin Panel
        </h1>
        <p className="text-md text-gray-600 dark:text-gray-400 mt-1">
          Manage core system entities like Core Sites, Devices, and Net Types.
        </p>
      </header>
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6">
        <h2 className="text-2xl font-bold text-gray-700 dark:text-gray-200 mb-4">
          Add Entities
        </h2>
        <div className="flex flex-wrap gap-3">
          <button
            onClick={() => setActiveAddSection("coreSite")}
            className={`px-5 py-2 text-sm font-semibold rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800 focus:ring-blue-500 ${
              activeAddSection === "coreSite"
                ? "bg-blue-600 text-white shadow"
                : "bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600"
            }`}
          >
            Add Core Site
          </button>
          <button
            onClick={() => setActiveAddSection("coreDevice")}
            className={`px-5 py-2 text-sm font-semibold rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800 focus:ring-blue-500 ${
              activeAddSection === "coreDevice"
                ? "bg-blue-600 text-white shadow"
                : "bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600"
            }`}
          >
            Add Core Device
          </button>
          <button
            onClick={() => setActiveAddSection("netType")}
            className={`px-5 py-2 text-sm font-semibold rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800 focus:ring-blue-500 ${
              activeAddSection === "netType"
                ? "bg-blue-600 text-white shadow"
                : "bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600"
            }`}
          >
            Add Net Type
          </button>
        </div>
        {renderAddSectionForm()}
      </div>
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6">
        <h2 className="text-2xl font-bold text-red-700 dark:text-red-400 mb-4">
          Delete Entities
        </h2>
        <div className="flex flex-wrap gap-3">
          <button
            onClick={() => handleSetDeleteSection("deleteCoreSite")}
            className={`px-5 py-2 text-sm font-semibold rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800 focus:ring-red-500 ${
              activeDeleteSection === "deleteCoreSite"
                ? "bg-red-600 text-white shadow"
                : "bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600"
            }`}
          >
            Delete Core Site
          </button>
          <button
            onClick={() => handleSetDeleteSection("deleteDevice")}
            className={`px-5 py-2 text-sm font-semibold rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800 focus:ring-red-500 ${
              activeDeleteSection === "deleteDevice"
                ? "bg-red-600 text-white shadow"
                : "bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600"
            }`}
          >
            Delete Core Device
          </button>
          <button
            onClick={() => handleSetDeleteSection("deleteNetType")}
            className={`px-5 py-2 text-sm font-semibold rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800 focus:ring-red-500 ${
              activeDeleteSection === "deleteNetType"
                ? "bg-red-600 text-white shadow"
                : "bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600"
            }`}
          >
            Delete Net Type
          </button>
        </div>
        {renderDeleteSectionForm()}
      </div>
    </div>
  );
}

--- File: src\pages\AlertsPage.jsx ---
import React, { useState, useEffect, useMemo, useRef } from "react";
import { useVirtualizer } from "@tanstack/react-virtual";
import {
  MdErrorOutline,
  MdWarningAmber,
  MdInfoOutline,
  MdNotifications,
  MdClose,
  MdSearch,
  MdFilterListOff,
  MdAutorenew,
  MdRefresh,
  MdStar,
  MdStarBorder,
} from "react-icons/md";
import { useDispatch, useSelector } from "react-redux";
import {
  fetchAllAlerts,
  deleteAlert,
  favoriteAlert,
  selectAllAlerts,
  selectAlertsStatus,
} from "../redux/slices/alertsSlice";

// --- HELPER COMPONENTS ---

const AlertIcon = ({ type, size = 24 }) => {
  if (type === "error")
    return (
      <MdErrorOutline className="text-red-500 flex-shrink-0" size={size} />
    );
  if (type === "warning")
    return (
      <MdWarningAmber className="text-yellow-500 flex-shrink-0" size={size} />
    );
  return <MdInfoOutline className="text-blue-500 flex-shrink-0" size={size} />;
};

const AlertModal = ({ alert, onClose }) => {
  const dispatch = useDispatch();

  if (!alert) return null;

  const handleDelete = () => {
    if (
      window.confirm(
        "Are you sure you want to delete this alert? This action cannot be undone."
      )
    ) {
      dispatch(deleteAlert(alert.id));
      onClose(); // Close the modal after the action is dispatched
    }
  };

  const handleFavorite = () => {
    dispatch(favoriteAlert(alert.id));
  };

  return (
    <div
      className="fixed inset-0 bg-black bg-opacity-60 backdrop-blur-sm flex items-center justify-center p-4 z-50"
      onClick={onClose}
    >
      <div
        className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-2xl w-full max-w-xl max-h-[90vh] overflow-y-auto relative"
        onClick={(e) => e.stopPropagation()}
      >
        <button
          onClick={onClose}
          className="absolute top-3 right-3 text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-colors"
          aria-label="Close modal"
        >
          <MdClose size={24} />
        </button>
        <div className="flex items-start space-x-3 mb-4">
          <AlertIcon type={alert.type} size={32} />
          <div>
            <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
              Alert Details
            </h2>
            <p
              className={`text-sm font-medium ${
                alert.type === "error"
                  ? "text-red-600 dark:text-red-400"
                  : alert.type === "warning"
                  ? "text-yellow-600 dark:text-yellow-400"
                  : "text-blue-600 dark:text-blue-400"
              }`}
            >
              Type: {alert.type.charAt(0).toUpperCase() + alert.type.slice(1)}
            </p>
          </div>
        </div>
        <div className="space-y-3 text-sm">
          <p>
            <strong className="text-gray-700 dark:text-gray-300">
              Message:
            </strong>
            <span className="text-gray-600 dark:text-gray-400 ml-1">
              {alert.message}
            </span>
          </p>
          <p>
            <strong className="text-gray-700 dark:text-gray-300">
              Timestamp:
            </strong>
            <span className="text-gray-600 dark:text-gray-400 ml-1">
              {new Date(alert.timestamp).toLocaleString()}
            </span>
          </p>
          <p>
            <strong className="text-gray-700 dark:text-gray-300">
              Network Line:
            </strong>
            <span className="text-gray-600 dark:text-gray-400 ml-1">
              {alert.networkLine}
            </span>
          </p>
          <p>
            <strong className="text-gray-700 dark:text-gray-300">
              Source:
            </strong>
            <span className="text-gray-600 dark:text-gray-400 ml-1">
              {alert.source}
            </span>
          </p>
          <p>
            <strong className="text-gray-700 dark:text-gray-300">
              Severity Score:
            </strong>
            <span className="text-gray-600 dark:text-gray-400 ml-1">
              {alert.severityScore}/10
            </span>
          </p>
          <div className="pt-2">
            <strong className="text-gray-700 dark:text-gray-300 block mb-1">
              Details:
            </strong>
            <p className="text-gray-600 dark:text-gray-400 bg-gray-50 dark:bg-gray-700 p-3 rounded-md text-xs leading-relaxed">
              {alert.details}
            </p>
          </div>
          <p>
            <strong className="text-gray-700 dark:text-gray-300">ID:</strong>
            <span className="text-xs text-gray-500 dark:text-gray-500 ml-1">
              {alert.id}
            </span>
          </p>
        </div>
        <div className="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700 flex justify-between items-center">
          <button
            onClick={handleFavorite}
            title={
              alert.isFavorite ? "Remove from favorites" : "Add to favorites"
            }
            className="p-2 rounded-full text-gray-500 hover:bg-yellow-100 dark:hover:bg-yellow-900/40 transition-colors"
          >
            {alert.isFavorite ? (
              <MdStar size={24} className="text-yellow-500" />
            ) : (
              <MdStarBorder size={24} className="hover:text-yellow-600" />
            )}
          </button>

          <div className="space-x-3">
            <button
              onClick={handleDelete}
              className="px-4 py-2 bg-red-600 text-white font-semibold text-sm rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 transition-colors"
            >
              Delete Alert
            </button>
            <button
              onClick={onClose}
              className="px-4 py-2 bg-blue-600 text-white font-semibold text-sm rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-colors"
            >
              Close
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

const AlertCard = ({ alert, onClick }) => {
  return (
    <div
      onClick={onClick}
      className="relative bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md hover:shadow-xl hover:-translate-y-1 transition-all duration-200 cursor-pointer border border-transparent dark:hover:border-blue-500 hover:border-blue-400 flex flex-col h-full"
    >
      {/* NEW: Conditionally render the favorite star */}
      {alert.isFavorite && (
        <div
          className="absolute top-2 right-2 text-yellow-400"
          title="Favorited"
        >
          <MdStar size={20} />
        </div>
      )}
      <div className="flex items-start space-x-4 flex-grow">
        <AlertIcon type={alert.type} size={28} />
        <div className="flex-1 min-w-0">
          <p
            className="font-semibold text-gray-800 dark:text-white truncate"
            title={alert.message}
          >
            {alert.message}
          </p>
          <div className="mt-2 pt-2 border-t border-gray-200 dark:border-gray-700 text-xs space-y-1">
            <p className="text-gray-600 dark:text-gray-300">
              <strong>Network Line:</strong> {alert.networkLine}
            </p>
            <p className="text-gray-500 dark:text-gray-400">
              {new Date(alert.timestamp).toLocaleString()}
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

const timePeriods = [
  { label: "1 Hour", value: "1h" },
  { label: "10 Hours", value: "10h" },
  { label: "24 Hours", value: "24h" },
  { label: "1 Week", value: "1w" },
  { label: "All Time", value: "all" },
];
const alertTypes = [
  { value: "error", label: "Errors", color: "red" },
  { value: "warning", label: "Warnings", color: "yellow" },
  { value: "info", label: "Info", color: "blue" },
];
const initialTypeState = { error: true, warning: true, info: true };

const TypeFilterButton = ({ typeInfo, count, isActive, onClick }) => {
  const colors = {
    red: {
      active: "bg-red-500 text-white shadow-md",
      inactive:
        "bg-gray-100 dark:bg-gray-700/60 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700",
    },
    yellow: {
      active: "bg-yellow-500 text-white shadow-md",
      inactive:
        "bg-gray-100 dark:bg-gray-700/60 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700",
    },
    blue: {
      active: "bg-blue-500 text-white shadow-md",
      inactive:
        "bg-gray-100 dark:bg-gray-700/60 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700",
    },
  };
  const countColors = {
    red: { active: "bg-white/20", inactive: "bg-black/10 dark:bg-white/10" },
    yellow: { active: "bg-white/20", inactive: "bg-black/10 dark:bg-white/10" },
    blue: { active: "bg-white/20", inactive: "bg-black/10 dark:bg-white/10" },
  };
  return (
    <button
      onClick={onClick}
      className={`flex-1 text-center px-4 py-2 text-sm font-semibold transition-all duration-200 ease-in-out flex items-center justify-center gap-2 ${
        isActive
          ? colors[typeInfo.color].active
          : colors[typeInfo.color].inactive
      }`}
    >
      <span>{typeInfo.label}</span>
      <span
        className={`px-2 py-0.5 rounded-full text-xs font-mono transition-colors duration-200 ${
          isActive
            ? countColors[typeInfo.color].active
            : countColors[typeInfo.color].inactive
        }`}
      >
        {count}
      </span>
    </button>
  );
};

export function AlertsPage() {
  const dispatch = useDispatch();
  const allAlerts = useSelector(selectAllAlerts);
  const status = useSelector(selectAlertsStatus);

  const [selectedAlert, setSelectedAlert] = useState(null);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [selectedPeriod, setSelectedPeriod] = useState("1w");
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedTypes, setSelectedTypes] = useState(initialTypeState);
  const parentRef = useRef(null);
  const [columnCount, setColumnCount] = useState(3);

  useEffect(() => {
    if (status === "idle") {
      dispatch(fetchAllAlerts());
    }
  }, [status, dispatch]);

  useEffect(() => {
    const updateColumnCount = () => {
      if (window.innerWidth >= 1024) setColumnCount(3);
      else if (window.innerWidth >= 768) setColumnCount(2);
      else setColumnCount(1);
    };
    updateColumnCount();
    window.addEventListener("resize", updateColumnCount);
    return () => window.removeEventListener("resize", updateColumnCount);
  }, []);

  // --- CORRECTED EFFECT ---
  useEffect(() => {
    // Only run the logic if there is a selected alert
    if (selectedAlert) {
      // Find the latest version of this alert in the main Redux store list
      const updatedAlert = allAlerts.find((a) => a.id === selectedAlert.id);

      if (updatedAlert) {
        // If the alert still exists, update our local state to match it.
        // This is important for seeing the "favorite" star change instantly.
        setSelectedAlert(updatedAlert);
      } else {
        // If the alert is not found, it means it was deleted.
        // We should close the modal automatically.
        handleCloseModal();
      }
    }
  }, [allAlerts, selectedAlert]); // <-- The corrected dependency array

  // NEW: Step 1 - Sort the alerts first
  const sortedAlerts = useMemo(() => {
    if (!Array.isArray(allAlerts)) return [];
    // Create a shallow copy to avoid mutating the original state
    return [...allAlerts].sort((a, b) => {
      // Prioritize favorited items
      if (a.isFavorite && !b.isFavorite) return -1;
      if (!a.isFavorite && b.isFavorite) return 1;

      // For items with the same favorite status, sort by newest first
      return new Date(b.timestamp) - new Date(a.timestamp);
    });
  }, [allAlerts]);

  // MODIFIED: Step 2 - Filter the *sorted* list by time
  const timeFilteredAlerts = useMemo(() => {
    const now = new Date();
    // Use the newly created sortedAlerts list
    const alertsWithDate = sortedAlerts.map((a) => ({
      ...a,
      timestamp: new Date(a.timestamp),
    }));

    switch (selectedPeriod) {
      case "1h":
        return alertsWithDate.filter(
          (a) => a.timestamp >= new Date(now.getTime() - 1 * 60 * 60 * 1000)
        );
      case "10h":
        return alertsWithDate.filter(
          (a) => a.timestamp >= new Date(now.getTime() - 10 * 60 * 60 * 1000)
        );
      case "24h":
        return alertsWithDate.filter(
          (a) => a.timestamp >= new Date(now.getTime() - 24 * 60 * 60 * 1000)
        );
      case "1w":
        return alertsWithDate.filter(
          (a) =>
            a.timestamp >= new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
        );
      default:
        return alertsWithDate;
    }
  }, [sortedAlerts, selectedPeriod]); // Depends on the sorted list now

  const alertCountsByType = useMemo(() => {
    return timeFilteredAlerts.reduce(
      (acc, alert) => {
        acc[alert.type] = (acc[alert.type] || 0) + 1;
        return acc;
      },
      { error: 0, warning: 0, info: 0 }
    );
  }, [timeFilteredAlerts]);

  const filteredAlerts = useMemo(() => {
    const lowercasedTerm = searchTerm.toLowerCase();
    return timeFilteredAlerts.filter((alert) => {
      if (!selectedTypes[alert.type]) return false;
      if (
        lowercasedTerm &&
        !alert.message.toLowerCase().includes(lowercasedTerm) &&
        !alert.networkLine.toLowerCase().includes(lowercasedTerm)
      )
        return false;
      return true;
    });
  }, [timeFilteredAlerts, searchTerm, selectedTypes]);

  const rowVirtualizer = useVirtualizer({
    count: Math.ceil(filteredAlerts.length / columnCount),
    getScrollElement: () => parentRef.current,
    estimateSize: () => 140,
    overscan: 5,
  });

  const handleTypeChange = (type) =>
    setSelectedTypes((prev) => ({ ...prev, [type]: !prev[type] }));
  const handleResetFilters = () => {
    setSearchTerm("");
    setSelectedTypes(initialTypeState);
  };
  const handleAlertClick = (alert) => {
    setSelectedAlert(alert);
    setIsModalOpen(true);
  };
  const handleCloseModal = () => {
    setIsModalOpen(false);
    setSelectedAlert(null);
  };
  const handleRefresh = () => {
    dispatch(fetchAllAlerts());
  };

  const renderContent = () => {
    if (status === "loading" && allAlerts.length === 0) {
      return (
        <div className="flex-grow flex items-center justify-center text-center px-4">
          <div>
            <MdAutorenew
              size={56}
              className="mx-auto text-blue-500 animate-spin mb-4"
            />
            <p className="text-xl font-semibold text-gray-600 dark:text-gray-400">
              Loading Alerts...
            </p>
          </div>
        </div>
      );
    }
    if (filteredAlerts.length === 0) {
      return (
        <div className="flex-grow flex items-center justify-center text-center px-4">
          <div>
            <MdNotifications
              size={56}
              className="mx-auto text-gray-400 dark:text-gray-500 mb-4"
            />
            <p className="text-xl font-semibold text-gray-600 dark:text-gray-400">
              No Matching Alerts
            </p>
            <p className="text-md text-gray-500 dark:text-gray-500 mt-2">
              Try adjusting your time or type filters.
            </p>
          </div>
        </div>
      );
    }
    return (
      <div ref={parentRef} className="w-full h-full overflow-y-auto pr-2">
        <div
          key={columnCount}
          className="relative w-full"
          style={{ height: `${rowVirtualizer.getTotalSize()}px` }}
        >
          {rowVirtualizer.getVirtualItems().map((virtualRow) => {
            const cardsInRow = [];
            const startIndex = virtualRow.index * columnCount;
            const endIndex = Math.min(
              startIndex + columnCount,
              filteredAlerts.length
            );
            for (let i = startIndex; i < endIndex; i++) {
              const alert = filteredAlerts[i];
              cardsInRow.push(
                <AlertCard
                  key={alert.id}
                  alert={alert}
                  onClick={() => handleAlertClick(alert)}
                />
              );
            }
            return (
              <div
                key={virtualRow.key}
                className="absolute top-0 left-0 w-full grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-5 p-1"
                style={{
                  height: `${virtualRow.size}px`,
                  transform: `translateY(${virtualRow.start}px)`,
                }}
              >
                {cardsInRow}
              </div>
            );
          })}
        </div>
      </div>
    );
  };

  return (
    <>
      <div className="p-6 bg-gray-50 dark:bg-gray-900 h-full flex flex-col">
        <header className="mb-6 flex-shrink-0">
          <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-100">
            System Alerts
          </h1>
          <p className="text-md text-gray-600 dark:text-gray-400 mt-1">
            Review and filter real-time alerts from the network infrastructure.
          </p>
        </header>
        <div className="p-4 rounded-lg bg-white dark:bg-gray-800 shadow-sm border border-gray-200 dark:border-gray-700 mb-8 flex-shrink-0">
          <div className="mb-4">
            <label className="text-sm font-semibold text-gray-500 dark:text-gray-400 mb-2 block">
              Time Period
            </label>
            <div className="flex flex-wrap gap-2">
              {timePeriods.map((period) => (
                <button
                  key={period.value}
                  onClick={() => setSelectedPeriod(period.value)}
                  className={`px-3 py-1.5 text-sm font-medium rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-gray-800 focus:ring-blue-500 ${
                    selectedPeriod === period.value
                      ? "bg-blue-600 text-white shadow"
                      : "bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-600"
                  }`}
                >
                  {period.label}
                </button>
              ))}
            </div>
          </div>
          <div className="border-t border-gray-200 dark:border-gray-700 pt-4" />
          <div className="flex flex-wrap items-center gap-x-6 gap-y-4 pt-2">
            <div className="flex-shrink-0">
              <label className="text-sm font-semibold text-gray-500 dark:text-gray-400 block mb-2">
                Type
              </label>
              <div className="flex w-full sm:w-auto rounded-lg overflow-hidden border border-gray-200 dark:border-gray-600">
                {alertTypes.map((typeInfo) => (
                  <TypeFilterButton
                    key={typeInfo.value}
                    typeInfo={typeInfo}
                    count={alertCountsByType[typeInfo.value] || 0}
                    isActive={selectedTypes[typeInfo.value]}
                    onClick={() => handleTypeChange(typeInfo.value)}
                  />
                ))}
              </div>
            </div>
            <div className="flex-grow"></div>
            <div className="flex items-center gap-4 flex-wrap">
              <div className="relative">
                <MdSearch
                  className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"
                  size={20}
                />
                <input
                  id="search"
                  type="text"
                  placeholder="Search message or line..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="w-full sm:w-64 p-2 pl-10 border border-gray-300 dark:border-gray-600 rounded-lg bg-transparent focus:ring-2 focus:ring-blue-500 outline-none"
                />
              </div>
              <button
                onClick={handleRefresh}
                disabled={status === "loading"}
                title="Refresh Alerts"
                className="flex items-center gap-2 px-3 py-2 text-sm font-medium text-blue-600 dark:text-blue-400 bg-blue-50 dark:bg-blue-900/40 rounded-md hover:bg-blue-100 dark:hover:bg-blue-900/60 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <MdRefresh
                  className={status === "loading" ? "animate-spin" : ""}
                />
                <span>
                  {status === "loading" ? "Refreshing..." : "Refresh"}
                </span>
              </button>
              <button
                onClick={handleResetFilters}
                title="Reset filters"
                className="flex items-center gap-2 px-3 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
              >
                <MdFilterListOff />
              </button>
            </div>
          </div>
        </div>
        <div className="flex-grow min-h-0">{renderContent()}</div>
      </div>
      {isModalOpen && selectedAlert && (
        <AlertModal alert={selectedAlert} onClose={handleCloseModal} />
      )}
    </>
  );
}

--- File: src\pages\DashboardPage.jsx ---
import React from "react";
import { useSelector } from "react-redux";
import {
  Routes,
  Route,
  useParams,
  useLocation,
  Navigate,
} from "react-router-dom";
import { ArrowUp, ArrowDown, XCircle } from "lucide-react";

// Page Components for each tab
import FavoritesPage from "./dashboard/FavoritesPage";
import AllInterfacesPage from "./dashboard/AllInterfacesPage";

// Chart and Site specific components
import NetworkVisualizerWrapper from "./dashboard/NetworkVisualizerWrapper";
import NetworkVisualizer5Wrapper from "./dashboard/NetworkVisualizer5Wrapper";
import CoreSitePage from "../components/CoreSite/CoreSitePage";
import SiteDetailPage from "../components/end-site/SiteDetailPage";
import EndSiteIndexPage from "../components/end-site/EndSiteIndexPage";
import LinkTable from "../components/CoreDevice/LinkTable";

// Helper hooks and Redux selectors
import { useRelatedDevices } from "../hooks/useRelatedDevices";
import { selectAllDevices } from "../redux/slices/devicesSlice";
import { selectAllSites } from "../redux/slices/sitesSlice";
import { selectAllTenGigLinks } from "../redux/slices/tenGigLinksSlice";

// This helper component can be used by other pages like FavoritesPage
function StatusIndicator({ status }) {
  const statusConfig = {
    Up: { color: "text-green-500", Icon: ArrowUp, label: "Up" },
    Down: { color: "text-red-500", Icon: ArrowDown, label: "Down" },
    "Admin Down": {
      color: "text-gray-500",
      Icon: XCircle,
      label: "Admin Down",
    },
  };
  const config = statusConfig[status] || statusConfig["Admin Down"];
  return (
    <div className={`flex items-center gap-2 font-medium ${config.color}`}>
      <config.Icon className="h-4 w-4" />
      <span>{config.label}</span>
    </div>
  );
}

// This component now correctly receives the theme prop to pass down.
function NodeDetailView({ chartType, theme }) {
  const { nodeId: deviceHostname, zoneId } = useParams();
  const allDevices = useSelector(selectAllDevices);
  const allSites = useSelector(selectAllSites);
  const allLinks = useSelector(selectAllTenGigLinks);
  const otherDevicesInZone = useRelatedDevices(deviceHostname, zoneId);

  const linksForTable = React.useMemo(() => {
    if (
      !deviceHostname ||
      !chartType ||
      !allDevices.length ||
      !allLinks.length
    ) {
      return [];
    }
    const typeId = chartType === "P" ? 2 : 1;
    const allCoreLinksForChart = allLinks.filter(
      (link) => link.network_type_id === typeId
    );
    const currentDevice = allDevices.find((d) => d.hostname === deviceHostname);
    if (!currentDevice) return [];

    const deviceMapByHostname = new Map(allDevices.map((d) => [d.hostname, d]));

    const interCoreLinks = allCoreLinksForChart
      .filter(
        (link) =>
          link.source === deviceHostname || link.target === deviceHostname
      )
      .map((link) => {
        const otherDeviceHostname =
          link.source === deviceHostname ? link.target : link.source;
        const otherDevice = deviceMapByHostname.get(otherDeviceHostname);
        let linkType = "inter-core-different-site";
        if (
          otherDevice &&
          otherDevice.core_pikudim_site_id ===
            currentDevice.core_pikudim_site_id
        ) {
          linkType = "inter-core-same-site";
        }
        return {
          id: link.id,
          name: `Link to ${otherDeviceHostname}`,
          description: `Inter-Core Link (${
            linkType.includes("same") ? "Same Site" : "Different Site"
          })`,
          status: link.status,
          bandwidth: link.bandwidth,
          ospfStatus: "Enabled",
          mplsStatus: "Enabled",
          type: linkType,
        };
      });

    const coreToSiteLinks = allSites
      .filter((site) => site.device_id === currentDevice.id)
      .map((site) => ({
        id: `site-link-${site.id}`,
        name: site.site_name_english,
        description: "Connection to End-Site",
        status: "up",
        bandwidth: "1 Gbps",
        ospfStatus: "N/A",
        mplsStatus: "N/A",
        type: "core-to-site",
        additionalDetails: {
          mediaType: "Ethernet/Fiber",
          containerName: site.site_name_hebrew,
        },
      }));

    return [...interCoreLinks, ...coreToSiteLinks];
  }, [deviceHostname, chartType, allDevices, allSites, allLinks]);

  return (
    // The simple wrapper is correct. LinkTable will handle its own height.
    <div className="p-1">
      <LinkTable
        coreDeviceName={deviceHostname}
        coreSiteName={zoneId}
        linksData={linksForTable}
        otherDevicesInZone={otherDevicesInZone}
        theme={theme}
      />
    </div>
  );
}

export function DashboardPage({
  isAppFullscreen,
  theme,
  popupAnchorCoords,
  chartKeySuffix,
}) {
  return (
    <Routes>
      <Route path="/favorites" element={<FavoritesPage />} />
      <Route path="/all_interfaces" element={<AllInterfacesPage />} />

      {/* THE FIX: The chart routes are restructured to separate layouts for each sub-route. */}
      <Route
        path="/l-chart/*"
        element={
          <Routes>
            {/* The index route gets the non-scrolling, fixed-height layout */}
            <Route
              index
              element={
                <div
                  className={`relative w-full h-full ${
                    !isAppFullscreen && "rounded-lg shadow-sm"
                  } overflow-hidden bg-white dark:bg-gray-900`}
                >
                  <NetworkVisualizerWrapper
                    key={`l-visualizer-${chartKeySuffix}-${theme}`}
                    theme={theme}
                  />
                </div>
              }
            />
            {/* The node route is rendered directly, allowing it to use the main scrollbar */}
            <Route
              path="zone/:zoneId/node/:nodeId"
              element={<NodeDetailView chartType="L" theme={theme} />}
            />
            <Route
              path="zone/:zoneId"
              element={
                <CoreSitePage
                  theme={theme}
                  popupAnchor={popupAnchorCoords}
                  chartType="L"
                />
              }
            />
          </Routes>
        }
      />

      <Route
        path="/p-chart/*"
        element={
          <Routes>
            {/* The index route gets its own non-scrolling, fixed-height layout */}
            <Route
              index
              element={
                <div
                  className={`relative w-full h-full ${
                    !isAppFullscreen && "rounded-lg shadow-sm"
                  } overflow-hidden bg-white dark:bg-gray-900`}
                >
                  <NetworkVisualizer5Wrapper
                    key={`p-visualizer-${chartKeySuffix}-${theme}`}
                    theme={theme}
                  />
                </div>
              }
            />
            {/* The node route is rendered directly, allowing it to use the main scrollbar */}
            <Route
              path="zone/:zoneId/node/:nodeId"
              element={<NodeDetailView chartType="P" theme={theme} />}
            />
            <Route
              path="zone/:zoneId"
              element={
                <CoreSitePage
                  theme={theme}
                  popupAnchor={popupAnchorCoords}
                  chartType="P"
                />
              }
            />
          </Routes>
        }
      />

      <Route
        path="/sites/*"
        element={
          <Routes>
            <Route index element={<EndSiteIndexPage />} />
            <Route
              path="site/:siteNavId"
              element={<SiteDetailPageRouteElement />}
            />
          </Routes>
        }
      />

      {/* Default routes to redirect to the favorites tab */}
      <Route path="/" element={<Navigate to="/favorites" replace />} />
      <Route path="*" element={<Navigate to="/favorites" replace />} />
    </Routes>
  );
}

// This helper component for the sites route remains unchanged.
function SiteDetailPageRouteElement() {
  const location = useLocation();
  const siteGroupFromState = location.state?.siteGroupData;

  return siteGroupFromState ? (
    <SiteDetailPage
      siteGroup={siteGroupFromState}
      initialTheme={
        document.documentElement.classList.contains("dark") ? "dark" : "light"
      }
    />
  ) : (
    <Navigate to="/sites" replace />
  );
}

--- File: src\pages\LoginPage.jsx ---
// src/pages/LoginPage.jsx

import React, { useState, useEffect, useCallback } from "react";
import { useDispatch, useSelector } from "react-redux";
import { useNavigate } from "react-router-dom";
import Particles from "react-tsparticles";
import { loadSlim } from "tsparticles-slim";
import { User, Lock, Loader2, ArrowRight } from "lucide-react";

// Import the Redux actions and selectors from your auth slice
import {
  loginUser,
  selectAuthStatus,
  selectAuthError,
  selectAuthToken,
} from "../redux/slices/authSlice";

// particlesConfig object remains the same...
const particlesConfig = {
  background: {
    color: {
      value: "#0d1117",
    },
  },
  fpsLimit: 60,
  interactivity: {
    events: {
      onHover: {
        enable: true,
        mode: "repulse",
      },
      resize: true,
    },
    modes: {
      repulse: {
        distance: 80,
        duration: 0.4,
      },
    },
  },
  particles: {
    color: {
      value: "#3a7bd5",
    },
    links: {
      color: "#ffffff",
      distance: 150,
      enable: true,
      opacity: 0.1,
      width: 1,
    },
    move: {
      direction: "none",
      enable: true,
      outModes: {
        default: "bounce",
      },
      random: false,
      speed: 1,
      straight: false,
    },
    number: {
      density: {
        enable: true,
        area: 800,
      },
      value: 80,
    },
    opacity: {
      value: 0.5,
    },
    shape: {
      type: "circle",
    },
    size: {
      value: { min: 1, max: 3 },
    },
  },
  detectRetina: true,
};

function LoginPage() {
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");

  const dispatch = useDispatch();
  const navigate = useNavigate();

  const authStatus = useSelector(selectAuthStatus);
  const authError = useSelector(selectAuthError);
  const authToken = useSelector(selectAuthToken);

  const isLoading = authStatus === "loading";

  const particlesInit = useCallback(async (engine) => {
    await loadSlim(engine);
  }, []);

  useEffect(() => {
    if (authToken) {
      navigate("/", { replace: true });
    }
  }, [authToken, navigate]);

  const handleLogin = (e) => {
    e.preventDefault();
    if (!username || !password || isLoading) {
      return;
    }
    dispatch(loginUser({ username, password }));
  };

  return (
    <div className="relative min-h-screen w-full bg-gray-950 overflow-hidden">
      <Particles
        id="tsparticles"
        init={particlesInit}
        options={particlesConfig}
        className="absolute inset-0 z-0"
      />

      <div className="relative z-10 flex min-h-screen flex-col items-center justify-center p-4">
        <div className="w-full max-w-md rounded-2xl bg-slate-800/50 backdrop-blur-md border border-slate-700/50 shadow-2xl transition-all duration-300">
          <div className="p-8 md:p-10">
            <div className="text-center mb-8">
              <h1 className="text-4xl lg:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-cyan-300 tracking-wide">
                SPIDERWEB
              </h1>
              <div className="mt-4">
                <p className="text-xs uppercase tracking-widest text-slate-400">
                  Created by
                </p>
                <h2 className="text-4xl lg:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-pink-500 via-red-500 to-yellow-500 mt-1">
                  LIFeStyle
                </h2>
              </div>
            </div>

            {/* --- THIS IS THE FIX --- */}
            {/* Add the data-loading attribute to the form */}
            <form onSubmit={handleLogin} data-loading={isLoading} noValidate>
              <div className="mb-4 relative">
                <User
                  className="absolute left-4 top-1/2 -translate-y-1/2 h-5 w-5 text-slate-400"
                  aria-hidden="true"
                />
                <input
                  id="username"
                  type="text"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                  placeholder="User G"
                  // The disabled class from Tailwind will still apply visual styles (like opacity)
                  className="w-full pl-12 pr-4 py-3 bg-slate-900/70 border border-slate-700 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500/80 focus:border-blue-500 transition-colors disabled:opacity-70"
                  disabled={isLoading}
                  autoComplete="username"
                />
              </div>

              <div className="mb-6 relative">
                <Lock
                  className="absolute left-4 top-1/2 -translate-y-1/2 h-5 w-5 text-slate-400"
                  aria-hidden="true"
                />
                <input
                  id="password"
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="Password"
                  className="w-full pl-12 pr-4 py-3 bg-slate-900/70 border border-slate-700 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500/80 focus:border-blue-500 transition-colors disabled:opacity-70"
                  disabled={isLoading}
                  autoComplete="current-password"
                />
              </div>

              {authStatus === "failed" && authError && (
                <div className="bg-red-500/20 border border-red-500/30 text-red-300 text-sm rounded-lg p-3 text-center mb-6">
                  {authError}
                </div>
              )}

              <button
                type="submit"
                // The disabled class from Tailwind will handle the opacity change
                className="w-full font-bold py-3 px-4 rounded-lg text-white bg-gradient-to-r from-blue-600 to-cyan-500 hover:from-blue-700 hover:to-cyan-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-900 focus:ring-cyan-400 transition-all duration-300 ease-in-out flex items-center justify-center group disabled:opacity-60"
                disabled={isLoading}
              >
                {isLoading ? (
                  <>
                    <Loader2 className="animate-spin mr-2 h-5 w-5" />
                    Authenticating...
                  </>
                ) : (
                  <>
                    Log In
                    <ArrowRight className="ml-2 h-5 w-5 transform transition-transform group-hover:translate-x-1" />
                  </>
                )}
              </button>
            </form>
          </div>
        </div>
      </div>
    </div>
  );
}

export default LoginPage;

--- File: src\pages\SearchPage.jsx ---
// src/SearchPage.js
import React, { useState, useEffect } from "react";
import {
  MdSearch,
  MdOutlineManageSearch,
  MdErrorOutline,
} from "react-icons/md";

// Mock data remains the same
const allItems = [
  {
    id: 9,
    type: "Core Device",
    name: "Router-NYC-01",
    model: "ASR9K",
    location: "New York DC",
    ipAddress: "10.1.1.1",
  },
  {
    id: 10,
    type: "Core Device",
    name: "Switch-LDN-CORE-A",
    model: "NCS5500",
    location: "London Core",
    ipAddress: "10.2.2.1",
  },
  {
    id: 15,
    type: "Core Device",
    name: "Firewall-Global-Edge",
    model: "ASA5525",
    location: "DMZ",
    ipAddress: "192.168.100.1",
  },
  {
    id: 11,
    type: "Site",
    name: "Headquarters",
    address: "123 Main St, Anytown",
    country: "USA",
    siteId: "HQ-001",
  },
  {
    id: 12,
    type: "Site",
    name: "Branch Office Paris",
    address: "1 Rue de la Paix, Paris",
    country: "France",
    siteId: "PAR-BR-002",
  },
  {
    id: 13,
    type: "Link",
    name: "NYC-LDN-Primary",
    source: "Router-NYC-01",
    target: "Router-LDN-01",
    bandwidth: "100G",
    linkId: "LNK-NYC-LDN-001",
  },
  {
    id: 14,
    type: "Link",
    name: "HQ-Backbone-A",
    source: "HQ-Switch-01",
    target: "Backbone-Router-A",
    status: "Up",
    linkId: "LNK-HQ-BB-007",
  },
  {
    id: 3,
    type: "Document",
    title: "Project Alpha Report",
    category: "Reports",
  },
  {
    id: 4,
    type: "Document",
    title: "Quarterly Financials",
    category: "Finance",
  },
  {
    id: 8,
    type: "Document",
    title: "Marketing Plan Q3",
    category: "Marketing",
  },
  {
    id: 5,
    type: "Task",
    description: "Update core device Router-NYC-01 firmware",
    status: "In Progress",
  },
];

const itemTypes = [
  "All Types",
  "Core Device",
  "Site",
  "Link",
  "Document",
  "Task",
];

// --- NEW STYLED COMPONENT ---
const SearchResultCard = ({ item }) => {
  // Helper function to render details cleanly
  const renderDetail = (label, value) => {
    if (!value) return null;
    return (
      <p className="text-gray-600 dark:text-gray-400">
        <strong className="text-gray-700 dark:text-gray-300">{label}:</strong>{" "}
        {value}
      </p>
    );
  };

  return (
    <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow-md border border-gray-200 dark:border-gray-700/50">
      <div className="flex-grow">
        <h3 className="text-lg font-semibold text-blue-600 dark:text-blue-400 truncate">
          {item.name || item.title || `Item ${item.id}`}
        </h3>
        <p className="text-xs font-semibold uppercase tracking-wider text-gray-500 dark:text-gray-400 mb-2">
          {item.type}
        </p>
      </div>
      <div className="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700 text-sm space-y-1">
        {renderDetail("Description", item.description)}
        {renderDetail("IP Address", item.ipAddress)}
        {renderDetail("Location", item.location)}
        {renderDetail("Model", item.model)}
        {renderDetail("Site ID", item.siteId)}
        {renderDetail("Address", item.address)}
        {renderDetail("Country", item.country)}
        {renderDetail("Link ID", item.linkId)}
        {renderDetail("Source", item.source)}
        {renderDetail("Target", item.target)}
        {renderDetail("Bandwidth", item.bandwidth)}
        {renderDetail("Status", item.status)}
        {renderDetail("Category", item.category)}
      </div>
    </div>
  );
};

// --- STYLES UPDATED ---
function SearchPage() {
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedType, setSelectedType] = useState(itemTypes[0]);
  const [searchResults, setSearchResults] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [hasSearched, setHasSearched] = useState(false);

  const handleSearch = (e) => {
    if (e) e.preventDefault();
    if (!searchQuery.trim() && selectedType === "All Types") {
      setSearchResults([]);
      setHasSearched(true);
      return;
    }
    setIsLoading(true);
    setHasSearched(true);
    // Simulate API call
    setTimeout(() => {
      const queryLower = searchQuery.toLowerCase();
      const filteredResults = allItems.filter((item) => {
        if (selectedType !== "All Types" && item.type !== selectedType)
          return false;
        if (searchQuery.trim()) {
          return Object.values(item).some((val) =>
            String(val).toLowerCase().includes(queryLower)
          );
        }
        return true;
      });
      setSearchResults(filteredResults);
      setIsLoading(false);
    }, 500);
  };

  useEffect(() => {
    if (hasSearched || searchQuery.trim()) {
      const timer = setTimeout(() => handleSearch(), 300); // Debounce search
      return () => clearTimeout(timer);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedType, searchQuery]);

  const renderContent = () => {
    if (isLoading) {
      return (
        <div className="text-center py-16 px-4">
          <svg
            className="animate-spin h-12 w-12 text-blue-500 mx-auto"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
          >
            <circle
              className="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              strokeWidth="4"
            ></circle>
            <path
              className="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            ></path>
          </svg>
          <p className="text-xl font-semibold text-gray-600 dark:text-gray-400 mt-4">
            Searching...
          </p>
        </div>
      );
    }

    if (hasSearched && searchResults.length === 0) {
      return (
        <div className="text-center py-16 px-4 mt-6 border-2 border-dashed border-gray-300 dark:border-gray-700 rounded-lg">
          <MdErrorOutline
            size={56}
            className="mx-auto text-yellow-500 dark:text-yellow-400 mb-4"
          />
          <p className="text-xl font-semibold text-gray-700 dark:text-gray-300">
            No Results Found
          </p>
          <p className="text-md text-gray-500 dark:text-gray-500 mt-2 max-w-md mx-auto">
            Your search for "{searchQuery}" in "{selectedType}" did not return
            any matches. Please try a different query.
          </p>
        </div>
      );
    }

    if (searchResults.length > 0) {
      return (
        <div>
          <h2 className="text-2xl font-semibold text-gray-800 dark:text-gray-200 mb-4">
            Results ({searchResults.length})
          </h2>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-5">
            {searchResults.map((item) => (
              <SearchResultCard key={item.id} item={item} />
            ))}
          </div>
        </div>
      );
    }

    return (
      <div className="text-center py-16 px-4 mt-6 border-2 border-dashed border-gray-300 dark:border-gray-700 rounded-lg">
        <MdOutlineManageSearch
          size={56}
          className="mx-auto text-gray-400 dark:text-gray-500 mb-4"
        />
        <p className="text-xl font-semibold text-gray-600 dark:text-gray-400">
          Start a Global Search
        </p>
        <p className="text-md text-gray-500 dark:text-gray-500 mt-2">
          Use the filters above to find any entity in the system.
        </p>
      </div>
    );
  };

  return (
    <div className="p-6 bg-gray-50 dark:bg-gray-900 min-h-full">
      <header className="mb-6">
        <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-100">
          Global Search
        </h1>
        <p className="text-md text-gray-600 dark:text-gray-400 mt-1">
          Find devices, sites, links, and other assets across the entire system.
        </p>
      </header>

      <form
        onSubmit={handleSearch}
        className="bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-md mb-8"
      >
        <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-4 items-end">
          {/* Search Input */}
          <div className="md:col-span-2 lg:col-span-2">
            <label
              htmlFor="searchQueryInput"
              className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
            >
              Search Term
            </label>
            <input
              id="searchQueryInput"
              type="text"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              placeholder="e.g., Router-NYC, 'Project Alpha', 10.1.1.1"
              className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none"
            />
          </div>
          {/* Type Filter */}
          <div>
            <label
              htmlFor="itemTypeSelect"
              className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
            >
              Filter by Type
            </label>
            <select
              id="itemTypeSelect"
              value={selectedType}
              onChange={(e) => setSelectedType(e.target.value)}
              className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none"
            >
              {itemTypes.map((type) => (
                <option key={type} value={type}>
                  {type}
                </option>
              ))}
            </select>
          </div>
          {/* Submit Button */}
          <button
            type="submit"
            disabled={isLoading}
            className="w-full px-4 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-60 disabled:cursor-not-allowed flex items-center justify-center gap-2 transition-colors"
          >
            <MdSearch size={20} />
            <span>{isLoading ? "..." : "Search"}</span>
          </button>
        </div>
      </form>

      <div className="mt-8">{renderContent()}</div>
    </div>
  );
}

export default SearchPage;

--- File: src\pages\useDashboardLogic.jsx ---
import { useEffect, useState, useMemo } from "react";
import { useLocation, useNavigate } from "react-router-dom";

/**
 * A custom hook to manage the shared logic for the main dashboard UI,
 * including tab navigation and state synchronization with the URL.
 *
 * @param {object} props - Component props.
 * @param {boolean} props.isAppFullscreen - Whether the entire app is in fullscreen mode.
 * @param {boolean} props.isSidebarCollapsed - Whether the main sidebar is collapsed.
 * @returns {object} - An object containing state and handlers for the dashboard.
 */
export function useDashboardLogic({ isAppFullscreen, isSidebarCollapsed }) {
  const location = useLocation();
  const navigate = useNavigate();

  /**
   * Determines the active tab value based on the current URL path.
   * This is used to initialize the state and to synchronize the UI
   * when the user navigates using browser back/forward buttons.
   * @param {string} path - The current location.pathname.
   * @returns {string} The corresponding tab value.
   */
  const getTabValueFromPath = (path) => {
    if (path.startsWith("/l-chart")) return "l_network";
    if (path.startsWith("/p-chart")) return "p_network";
    if (path.startsWith("/sites")) return "site";
    if (path.startsWith("/all_interfaces")) return "all_interfaces";
    if (path.startsWith("/favorites")) return "favorites";
    return "favorites"; // Default to 'favorites' if no match is found
  };

  // State to keep track of the currently active tab.
  // It's initialized based on the current URL path.
  const [activeTabValue, setActiveTabValue] = useState(
    getTabValueFromPath(location.pathname)
  );

  // This effect listens for changes in the URL (e.g., from browser navigation)
  // and updates the active tab state to keep the UI in sync.
  useEffect(() => {
    const newTabValue = getTabValueFromPath(location.pathname);
    if (newTabValue !== activeTabValue) {
      setActiveTabValue(newTabValue);
    }
  }, [location.pathname, activeTabValue]);

  /**
   * Handles the click event on a tab. It determines the correct URL path
   * for the clicked tab's value and navigates to it.
   * @param {string} value - The value of the clicked shadcn/ui TabsTrigger.
   */
  const handleTabChangeForNavigation = (value) => {
    let path;
    switch (value) {
      case "l_network":
        path = "/l-chart";
        break;
      case "p_network":
        path = "/p-chart";
        break;
      case "site":
        path = "/sites";
        break;
      case "all_interfaces":
        path = "/all_interfaces"; // Correctly maps to the all_interfaces path
        break;
      case "favorites":
      default:
        path = "/favorites";
        break;
    }
    // Navigate to the new path if it's different from the current one
    if (path !== location.pathname) {
      navigate(path);
    }
  };

  // This memoized value creates a unique key suffix for the visualizer components.
  // This is useful for forcing a re-mount and re-render of the D3 charts
  // when certain UI states change (like entering fullscreen or collapsing the sidebar),
  // which might affect their container dimensions.
  const chartKeySuffix = useMemo(() => {
    return `${isAppFullscreen}-${isSidebarCollapsed}`;
  }, [isAppFullscreen, isSidebarCollapsed]);

  // The hook returns all the state and handlers that the DashboardPage component needs.
  return {
    theme: document.documentElement.classList.contains("dark")
      ? "dark"
      : "light",
    activeTabValue,
    handleTabChangeForNavigation,
    chartKeySuffix,
    // Note: popupAnchorCoords was in the original code but seems unused.
    // I'm keeping it here in case it's used by code not provided.
    popupAnchorCoords: null,
  };
}

--- File: src\pages\useInterfaceData.jsx ---
import { useMemo, useCallback } from "react";
import { useSelector, useDispatch } from "react-redux";
import { faker } from "@faker-js/faker";

// --- Redux Imports ---
// Selectors for raw data sources
import { selectAllSites } from "../redux/slices/sitesSlice";
import { selectAllTenGigLinks } from "../redux/slices/tenGigLinksSlice";
import { selectAllDevices } from "../redux/slices/devicesSlice";
// Selector and Action for the shared "favorites" state
import {
  selectFavoriteIds,
  toggleFavoriteLink, // <-- FIX #1: Use the correct name for the exported thunk
} from "../redux/slices/favoritesSlice"; // <-- Make sure the file extension is correct (.js or .jsx)

/**
 * The "Single Source of Truth" Hook for all network connections.
 * ... (rest of the JSDoc)
 */
export function useInterfaceData() {
  // Get the dispatch function to send actions to the Redux store
  const dispatch = useDispatch();

  // --- Step 1: Get all data from the global Redux store using selectors ---
  const allSites = useSelector(selectAllSites);
  const allTenGigLinks = useSelector(selectAllTenGigLinks);
  const allDevices = useSelector(selectAllDevices);

  // This gets the favorite IDs as a plain array, e.g., ['id-1', 'id-2']
  const favoriteIds = useSelector(selectFavoriteIds);

  // --- Step 2: Create efficient lookup maps (memoized for performance) ---
  const deviceMap = useMemo(
    () => new Map(allDevices.map((d) => [d.id, d])),
    [allDevices]
  );

  // --- NEW: Create a clean list of device names for the filter dropdown ---
  const deviceFilterOptions = useMemo(() => {
    // Get hostnames from the source of truth: allDevices
    const hostnames = allDevices.map((device) => device.hostname);
    // Add the "all" option and sort the list for a clean UI
    return ["all", ...hostnames.sort()];
  }, [allDevices]);

  // --- Step 3: Transform, combine, and merge all data (the core logic) ---
  const interfaces = useMemo(() => {
    // --- A. Transform Site Connections into the common format ---
    const siteConnections = allSites.map((site) => {
      const device = deviceMap.get(site.device_id);
      return {
        id: `site-${site.id}-${site.device_id}`,
        deviceName: device?.hostname || "Unknown Device",
        interfaceName: `Port ${site.interface_id}`,
        description: `Connection to site: ${site.site_name_english}`,
        status: "Up",
        trafficIn: `${faker.number.int({ min: 1, max: 800 })} Mbps`,
        trafficOut: `${faker.number.int({ min: 1, max: 800 })} Mbps`,
        errors: {
          in: faker.number.int({ max: 5 }),
          out: faker.number.int({ max: 2 }),
        },
      };
    });

    // B. Transform 10-Gigabit Core Links into the common format
    const tenGigCoreLinks = allTenGigLinks.map((link) => {
      const formattedStatus =
        link.status.charAt(0).toUpperCase() + link.status.slice(1);
      return {
        id: link.id,
        deviceName: `${link.source} <-> ${link.target}`,
        interfaceName: `10G Inter-Core Link`,
        description: `Inter-site trunk (${link.bandwidth})`,
        status: formattedStatus === "Issue" ? "Down" : formattedStatus,
        trafficIn: `${faker.number.float({
          min: 1,
          max: 9,
          precision: 0.1,
        })} Gbps`,
        trafficOut: `${faker.number.float({
          min: 1,
          max: 9,
          precision: 0.1,
        })} Gbps`,
        errors: {
          in: faker.number.int({ max: 20 }),
          out: faker.number.int({ max: 15 }),
        },
      };
    });

    // C. Combine all transformed data into one master array
    const allLinks = [...siteConnections, ...tenGigCoreLinks];

    // D. Add the `isFavorite` property to each item
    return allLinks.map((link) => ({
      ...link,
      isFavorite: favoriteIds.includes(link.id),
    }));
  }, [allSites, allTenGigLinks, deviceMap, favoriteIds]);

  // --- Step 4: Create a stable function to handle user actions ---
  const handleToggleFavorite = useCallback(
    (linkId) => {
      // FIX #2: Dispatch the async thunk with the correct name
      dispatch(toggleFavoriteLink(linkId));
    },
    [dispatch]
  );

  // --- Step 5: Return the final data and the action handler ---
  return { interfaces, handleToggleFavorite, deviceFilterOptions };
}

--- File: src\pages\dashboard\AllInterfacesPage.jsx ---
import React, { useState, useMemo } from "react";
import { useInterfaceData } from "../useInterfaceData";
import { Button } from "../../components/ui/button";
import { Star, ArrowUp, ArrowDown, XCircle, Search } from "lucide-react";
import { useSelector } from "react-redux";

// Import the virtualized table and feedback components
import { VirtualizedTable } from "../../components/ui/VirtualizedTable";
import { ErrorMessage } from "../../components/ui/feedback/ErrorMessage";

// Helper components (StatusIndicator, FavoriteButton) remain the same
const StatusIndicator = ({ status }) => {
  const config = {
    Up: { color: "text-green-500", Icon: ArrowUp, label: "Up" },
    Down: { color: "text-red-500", Icon: ArrowDown, label: "Down" },
    "Admin Down": {
      color: "text-gray-500",
      Icon: XCircle,
      label: "Admin Down",
    },
  }[status] || { color: "text-gray-500", Icon: XCircle, label: "Unknown" };
  return (
    <div className={`flex items-center gap-2 font-medium ${config.color}`}>
      <config.Icon className="h-4 w-4" />
      <span>{config.label}</span>
    </div>
  );
};

const FavoriteButton = ({ isFavorite, onClick }) => (
  <Button
    variant="ghost"
    size="icon"
    onClick={onClick}
    aria-label={isFavorite ? "Unfavorite" : "Favorite"}
  >
    <Star
      className={`h-5 w-5 transition-colors ${
        isFavorite
          ? "text-yellow-500 fill-yellow-400"
          : "text-gray-400 hover:text-yellow-500"
      }`}
    />
  </Button>
);

export default function AllInterfacesPage() {
  const { interfaces, handleToggleFavorite, deviceFilterOptions } =
    useInterfaceData();

  const sitesStatus = useSelector((state) => state.sites.status);
  const linksStatus = useSelector((state) => state.tenGigLinks.status);

  const isLoading = sitesStatus === "loading" || linksStatus === "loading";
  const hasError = sitesStatus === "failed" || linksStatus === "failed";

  const [searchTerm, setSearchTerm] = useState("");
  const [statusFilter, setStatusFilter] = useState("all");
  const [deviceFilter, setDeviceFilter] = useState("all");

  const filteredInterfaces = useMemo(() => {
    return interfaces.filter((iface) => {
      if (statusFilter !== "all" && iface.status !== statusFilter) return false;
      if (deviceFilter !== "all" && !iface.deviceName.includes(deviceFilter))
        return false;
      if (searchTerm) {
        const lowercasedTerm = searchTerm.toLowerCase();
        return (
          iface.interfaceName.toLowerCase().includes(lowercasedTerm) ||
          iface.description.toLowerCase().includes(lowercasedTerm) ||
          iface.deviceName.toLowerCase().includes(lowercasedTerm)
        );
      }
      return true;
    });
  }, [interfaces, searchTerm, statusFilter, deviceFilter]);

  const columns = useMemo(
    () => [
      {
        accessorKey: "interface",
        header: "Interface",
        size: 3,
        cell: ({ row }) => (
          <div>
            <div className="font-medium text-gray-800 dark:text-gray-100">
              {row.interfaceName}
            </div>
            <div className="text-sm text-gray-500 dark:text-gray-400 truncate">
              {row.description}
            </div>
          </div>
        ),
      },
      {
        accessorKey: "device",
        header: "Device(s)",
        size: 2,
        cell: ({ row }) => (
          <span className="text-gray-600 dark:text-gray-300">
            {row.deviceName}
          </span>
        ),
      },
      {
        accessorKey: "status",
        header: "Status",
        size: 1.5,
        cell: ({ row }) => <StatusIndicator status={row.status} />,
      },
      {
        accessorKey: "traffic",
        header: "Traffic (In/Out)",
        size: 1.5,
        cell: ({ row }) => (
          <span className="text-gray-600 dark:text-gray-300">{`${row.trafficIn} / ${row.trafficOut}`}</span>
        ),
      },
      {
        accessorKey: "errors",
        header: "Errors (In/Out)",
        size: 1.5,
        cell: ({ row }) => (
          <span
            className={
              row.errors.in > 0 || row.errors.out > 0
                ? "font-bold text-orange-600 dark:text-orange-400"
                : "text-gray-600 dark:text-gray-300"
            }
          >
            {`${row.errors.in} / ${row.errors.out}`}
          </span>
        ),
      },
      {
        accessorKey: "favorite",
        header: "Favorite",
        size: 1,
        cell: ({ row }) => (
          <div className="flex justify-end">
            <FavoriteButton
              isFavorite={row.isFavorite}
              onClick={() => handleToggleFavorite(row.id)}
            />
          </div>
        ),
      },
    ],
    [handleToggleFavorite]
  );

  const EmptyState = (
    <div className="text-center py-16 px-4 border-2 border-dashed border-gray-300 dark:border-gray-700 rounded-lg">
      <Search
        size={56}
        className="mx-auto text-gray-400 dark:text-gray-500 mb-4"
      />
      <p className="text-xl font-semibold text-gray-600 dark:text-gray-400">
        No Interfaces Found
      </p>
      <p className="text-md text-gray-500 dark:text-gray-500 mt-2">
        Your search or filters did not match any interfaces.
      </p>
    </div>
  );

  return (
    <div className="p-6 bg-gray-50 dark:bg-gray-900 h-full flex flex-col gap-6">
      <header className="flex-shrink-0">
        <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-100">
          All Network Interfaces
        </h1>
        <p className="text-md text-gray-600 dark:text-gray-400 mt-1">
          Search, filter, and manage all interfaces across the network.
        </p>
      </header>

      <div className="bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-md flex-shrink-0">
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          {/* Filter inputs... */}
          <div>
            <label
              htmlFor="search-interfaces"
              className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
            >
              Search by Keyword
            </label>
            <input
              id="search-interfaces"
              type="text"
              placeholder="Name, device, description..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none"
            />
          </div>
          <div>
            <label
              htmlFor="device-filter"
              className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
            >
              Filter by Device
            </label>
            <select
              id="device-filter"
              value={deviceFilter}
              onChange={(e) => setDeviceFilter(e.target.value)}
              className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none"
            >
              {deviceFilterOptions.map((name) => (
                <option key={name} value={name}>
                  {name === "all" ? "All Devices" : name}
                </option>
              ))}
            </select>
          </div>
          <div>
            <label
              htmlFor="status-filter"
              className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1"
            >
              Filter by Status
            </label>
            <select
              id="status-filter"
              value={statusFilter}
              onChange={(e) => setStatusFilter(e.target.value)}
              className="w-full p-3 border border-gray-300 dark:border-gray-600 rounded-lg shadow-sm bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none"
            >
              <option value="all">All Statuses</option>
              <option value="Up">Up</option>
              <option value="Down">Down</option>
              <option value="Admin Down">Admin Down</option>
            </select>
          </div>
        </div>
      </div>

      {/* This container grows to fill the rest of the space, and its child will take up 100% of its height. */}
      <div className="bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-md flex-grow min-h-0">
        <VirtualizedTable
          data={filteredInterfaces}
          columns={columns}
          isLoading={isLoading}
          emptyMessage={hasError ? <ErrorMessage /> : EmptyState}
        />
      </div>
    </div>
  );
}

--- File: src\pages\dashboard\FavoritesPage.jsx ---
// src/pages/FavoritesPage.jsx

import React, { useMemo } from "react";
import { useInterfaceData } from "../useInterfaceData"; // The shared "brain"
import { Button } from "../../components/ui/button";
import {
  Table,
  TableHead,
  TableHeader,
  TableBody,
  TableRow,
  TableCell,
} from "../../components/ui/table";
import { Star, ArrowUp, ArrowDown, XCircle } from "lucide-react";

// --- Reusable Helper Components (No changes needed, styles are consistent) ---

const StatusIndicator = ({ status }) => {
  const config = {
    Up: { color: "text-green-500", Icon: ArrowUp, label: "Up" },
    Down: { color: "text-red-500", Icon: ArrowDown, label: "Down" },
    "Admin Down": {
      color: "text-gray-500",
      Icon: XCircle,
      label: "Admin Down",
    },
  }[status] || { color: "text-gray-500", Icon: XCircle, label: "Unknown" };

  return (
    <div className={`flex items-center gap-2 font-medium ${config.color}`}>
      <config.Icon className="h-4 w-4" />
      <span>{config.label}</span>
    </div>
  );
};

const FavoriteButton = ({ isFavorite, onClick }) => (
  <Button
    variant="ghost"
    size="icon"
    onClick={onClick}
    aria-label={isFavorite ? "Unfavorite" : "Favorite"}
  >
    <Star
      className={`h-5 w-5 transition-colors ${
        isFavorite
          ? "text-yellow-500 fill-yellow-400"
          : "text-gray-400 hover:text-yellow-500"
      }`}
    />
  </Button>
);

// --- STYLES UPDATED ---
export default function FavoritesPage() {
  const { interfaces, handleToggleFavorite } = useInterfaceData();

  const favoriteInterfaces = useMemo(() => {
    return interfaces.filter((iface) => iface.isFavorite);
  }, [interfaces]);

  const renderContent = () => {
    if (favoriteInterfaces.length > 0) {
      return (
        <div className="overflow-x-auto border dark:border-gray-700/50 rounded-lg">
          <Table>
            <TableHeader className="bg-gray-100/50 dark:bg-gray-800/50">
              <TableRow>
                <TableHead className="font-semibold text-gray-600 dark:text-gray-300">
                  Interface / Link
                </TableHead>
                <TableHead className="font-semibold text-gray-600 dark:text-gray-300">
                  Device(s)
                </TableHead>
                <TableHead className="font-semibold text-gray-600 dark:text-gray-300">
                  Status
                </TableHead>
                <TableHead className="font-semibold text-gray-600 dark:text-gray-300">
                  Traffic (In / Out)
                </TableHead>
                <TableHead className="text-right font-semibold text-gray-600 dark:text-gray-300">
                  Actions
                </TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {favoriteInterfaces.map((iface) => (
                <TableRow
                  key={iface.id}
                  className="hover:bg-gray-50 dark:hover:bg-gray-800/50"
                >
                  <TableCell>
                    <div className="font-medium text-gray-800 dark:text-gray-100">
                      {iface.interfaceName}
                    </div>
                    <div className="text-sm text-gray-500 dark:text-gray-400 truncate max-w-xs">
                      {iface.description}
                    </div>
                  </TableCell>
                  <TableCell className="text-gray-600 dark:text-gray-300">
                    {iface.deviceName}
                  </TableCell>
                  <TableCell>
                    <StatusIndicator status={iface.status} />
                  </TableCell>
                  <TableCell className="text-gray-600 dark:text-gray-300">{`${iface.trafficIn} / ${iface.trafficOut}`}</TableCell>
                  <TableCell className="text-right">
                    <FavoriteButton
                      isFavorite={iface.isFavorite}
                      onClick={() => handleToggleFavorite(iface.id)}
                    />
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
      );
    }
    // Enhanced "Empty State"
    return (
      <div className="text-center py-16 px-4 border-2 border-dashed border-gray-300 dark:border-gray-700 rounded-lg">
        <Star
          size={56}
          className="mx-auto text-yellow-400 dark:text-yellow-500 mb-4"
        />
        <p className="text-xl font-semibold text-gray-600 dark:text-gray-400">
          No Favorite Connections Yet
        </p>
        <p className="text-md text-gray-500 dark:text-gray-500 mt-2">
          Click the star icon on any interface in the "All Interfaces" page to
          add it here.
        </p>
      </div>
    );
  };

  return (
    <div className="p-6 bg-gray-50 dark:bg-gray-900 min-h-full">
      <header className="mb-6">
        <h1 className="text-3xl font-bold text-gray-800 dark:text-gray-100">
          Favorite Connections
        </h1>
        <p className="text-md text-gray-600 dark:text-gray-400 mt-1">
          A quick overview of your most important network links and connections.
        </p>
      </header>

      {/* Main Content Card */}
      <div className="bg-white dark:bg-gray-800 p-4 sm:p-6 rounded-lg shadow-md">
        {renderContent()}
      </div>
    </div>
  );
}

--- File: src\pages\dashboard\NetworkVisualizer5Wrapper.jsx ---
import React, { useCallback, useState, useMemo } from "react";
import { useNavigate } from "react-router-dom";
import { useSelector, useDispatch } from "react-redux";
import NetworkVisualizer5 from "../../components/chart/NetworkVisualizer5";
import LinkDetailTabs from "../../components/shared/LinkDetailTabs";
import { selectPikudimByTypeId } from "../../redux/slices/corePikudimSlice";
import { selectDevicesByTypeId } from "../../redux/slices/devicesSlice";
import { selectLinksByTypeId } from "../../redux/slices/tenGigLinksSlice";
import ToggleDetailButton from "../../components/chart/ToggleDetailButton";
import { fetchInitialData } from "../../redux/slices/authSlice";

// Import reusable feedback components
import { LoadingSpinner } from "../../components/ui/feedback/LoadingSpinner";
import { ErrorMessage } from "../../components/ui/feedback/ErrorMessage";

// Helper function to select top devices (no changes)
function selectTopTwoDevices(devices) {
  if (devices.length <= 2) return devices;
  const priorityOrder = [4, 5, 1, 2, 7, 8];
  const sortedDevices = [...devices].sort((a, b) => {
    const a_ending = parseInt(a.hostname.split("-").pop(), 10);
    const b_ending = parseInt(b.hostname.split("-").pop(), 10);
    const a_priority = priorityOrder.indexOf(a_ending);
    const b_priority = priorityOrder.indexOf(b_ending);
    const final_a_priority = a_priority === -1 ? 99 : a_priority;
    const final_b_priority = b_priority === -1 ? 99 : b_priority;
    return final_a_priority - final_b_priority;
  });
  return sortedDevices.slice(0, 2);
}

const NetworkVisualizer5Wrapper = ({ theme }) => {
  const navigate = useNavigate();
  const dispatch = useDispatch();

  // Get data fetching status from Redux
  const pikudimStatus = useSelector((state) => state.corePikudim.status);
  const devicesStatus = useSelector((state) => state.devices.status);
  const linksStatus = useSelector((state) => state.tenGigLinks.status);

  // Local UI state
  const [openLinkTabs, setOpenLinkTabs] = useState([]);
  const [activeLinkTabId, setActiveLinkTabId] = useState(null);
  const [showDetailedLinks, setShowDetailedLinks] = useState(false);

  // Selectors for P-Chart data (typeId: 2)
  const pikudim = useSelector((state) => selectPikudimByTypeId(state, 2));
  const allDevicesForType = useSelector((state) =>
    selectDevicesByTypeId(state, 2)
  );
  const linksRaw = useSelector((state) => selectLinksByTypeId(state, 2));

  // Memoized data transformation for the graph
  const graphData = useMemo(() => {
    if (!pikudim.length || !allDevicesForType.length) {
      return { nodes: [], links: [] };
    }

    const devicesByPikudId = allDevicesForType.reduce((acc, device) => {
      const siteId = device.core_pikudim_site_id;
      if (!acc[siteId]) {
        acc[siteId] = [];
      }
      acc[siteId].push(device);
      return acc;
    }, {});

    const topDevicesPerPikud = Object.values(devicesByPikudId).flatMap(
      (deviceGroup) => selectTopTwoDevices(deviceGroup)
    );

    const visibleDeviceHostnames = new Set(
      topDevicesPerPikud.map((d) => d.hostname)
    );

    const pikudimMap = pikudim.reduce((acc, p) => {
      acc[p.id] = p;
      return acc;
    }, {});
    const transformedNodes = topDevicesPerPikud.map((device) => ({
      id: device.hostname,
      group: "node",
      zone:
        pikudimMap[device.core_pikudim_site_id]?.core_site_name ||
        "Unknown Zone",
    }));

    const transformedLinks = linksRaw
      .filter(
        (link) =>
          visibleDeviceHostnames.has(link.source) &&
          visibleDeviceHostnames.has(link.target)
      )
      .map((link) => ({
        id: link.id,
        source: link.source,
        target: link.target,
        category: link.status,
      }));

    return { nodes: transformedNodes, links: transformedLinks };
  }, [pikudim, allDevicesForType, linksRaw]);

  // All event handlers (unchanged)
  const handleZoneClick = useCallback(
    (zoneId) => {
      navigate(`zone/${zoneId}`);
    },
    [navigate]
  );

  const handleNodeClick = useCallback(
    (nodeData) => {
      if (nodeData && nodeData.id && nodeData.zone) {
        navigate(`zone/${nodeData.zone}/node/${nodeData.id}`);
      } else {
        console.warn("Node data incomplete for navigation:", nodeData);
      }
    },
    [navigate]
  );

  const handleLinkClick = useCallback(
    (linkDetailPayload) => {
      const { id, sourceNode, targetNode } = linkDetailPayload;
      const tabExists = openLinkTabs.some((tab) => tab.id === id);

      if (!tabExists) {
        const newTab = {
          id: id,
          title: `${sourceNode} - ${targetNode}`,
          type: "link",
          data: linkDetailPayload,
        };
        setOpenLinkTabs((prevTabs) => [...prevTabs, newTab]);
      }
      setActiveLinkTabId(id);
    },
    [openLinkTabs]
  );

  const handleCloseTab = useCallback(
    (tabIdToClose) => {
      setOpenLinkTabs((prevTabs) => {
        const remainingTabs = prevTabs.filter((tab) => tab.id !== tabIdToClose);
        if (activeLinkTabId === tabIdToClose) {
          if (remainingTabs.length > 0) {
            setActiveLinkTabId(remainingTabs[remainingTabs.length - 1].id);
          } else {
            setActiveLinkTabId(null);
          }
        }
        return remainingTabs;
      });
    },
    [activeLinkTabId]
  );

  const handleToggleDetailView = useCallback(() => {
    setShowDetailedLinks((prev) => !prev);
  }, []);

  const handleRetry = () => dispatch(fetchInitialData());

  // --- NEW: Loading, Error, and Empty State Rendering Logic ---
  const isLoading =
    pikudimStatus === "loading" ||
    devicesStatus === "loading" ||
    linksStatus === "loading";
  const hasError =
    pikudimStatus === "failed" ||
    devicesStatus === "failed" ||
    linksStatus === "failed";

  const isDataEmpty = !isLoading && !hasError && graphData.nodes.length === 0;

  if (isLoading) {
    return <LoadingSpinner text="Building P-Chart..." />;
  }

  if (hasError) {
    return <ErrorMessage onRetry={handleRetry} />;
  }

  if (isDataEmpty) {
    return (
      <div className="flex h-full w-full flex-col items-center justify-center p-4 text-center">
        <h3 className="text-xl font-semibold text-gray-700 dark:text-gray-300">
          No Data Available
        </h3>
        <p className="mt-2 text-gray-500 dark:text-gray-400">
          There is no network data available to build the P-Chart.
        </p>
      </div>
    );
  }

  // --- Original component return for successful data load ---
  return (
    <div className="w-full h-full flex flex-col">
      {openLinkTabs.length > 0 && (
        <div className="flex-shrink-0">
          <LinkDetailTabs
            tabs={openLinkTabs}
            activeTabId={activeLinkTabId}
            onSetActiveTab={setActiveLinkTabId}
            onCloseTab={handleCloseTab}
            theme={theme}
          />
        </div>
      )}

      <div className="flex-grow relative">
        <ToggleDetailButton
          isDetailed={showDetailedLinks}
          onToggle={handleToggleDetailView}
          theme={theme}
        />
        <NetworkVisualizer5
          key={theme}
          data={graphData}
          theme={theme}
          showDetailedLinks={showDetailedLinks}
          onZoneClick={handleZoneClick}
          onLinkClick={handleLinkClick}
          onNodeClick={handleNodeClick}
        />
      </div>
    </div>
  );
};

export default NetworkVisualizer5Wrapper;

--- File: src\pages\dashboard\NetworkVisualizerWrapper.jsx ---
// src/components/NetworkVisualizerWrapper.jsx

import React, { useCallback, useState, useMemo } from "react";
import { useNavigate } from "react-router-dom";
import { useSelector, useDispatch } from "react-redux";
import NetworkVisualizer from "../../components/chart/NetworkVisualizer";
import LinkDetailTabs from "../../components/shared/LinkDetailTabs";
import { selectPikudimByTypeId } from "../../redux/slices/corePikudimSlice";
import { selectDevicesByTypeId } from "../../redux/slices/devicesSlice";
import { selectLinksByTypeId } from "../../redux/slices/tenGigLinksSlice";
import ToggleDetailButton from "../../components/chart/ToggleDetailButton";
import { fetchInitialData } from "../../redux/slices/authSlice";

// Import feedback components
import { LoadingSpinner } from "../../components/ui/feedback/LoadingSpinner";
import { ErrorMessage } from "../../components/ui/feedback/ErrorMessage";

// Helper function to select top devices (no changes)
function selectTopTwoDevices(devices) {
  if (devices.length <= 2) return devices;
  const priorityOrder = [4, 5, 1, 2, 7, 8];
  const sortedDevices = [...devices].sort((a, b) => {
    const a_ending = parseInt(a.hostname.split("-").pop(), 10);
    const b_ending = parseInt(b.hostname.split("-").pop(), 10);
    const a_priority = priorityOrder.indexOf(a_ending);
    const b_priority = priorityOrder.indexOf(b_ending);
    const final_a_priority = a_priority === -1 ? 99 : a_priority;
    const final_b_priority = b_priority === -1 ? 99 : b_priority;
    return final_a_priority - final_b_priority;
  });
  return sortedDevices.slice(0, 2);
}

const NetworkVisualizerWrapper = ({ theme }) => {
  const navigate = useNavigate();
  const dispatch = useDispatch();

  // Get data fetching status from Redux
  const pikudimStatus = useSelector((state) => state.corePikudim.status);
  const devicesStatus = useSelector((state) => state.devices.status);
  const linksStatus = useSelector((state) => state.tenGigLinks.status);

  // Existing state and selectors...
  const [openLinkTabs, setOpenLinkTabs] = useState([]);
  const [activeLinkTabId, setActiveLinkTabId] = useState(null);
  const [showDetailedLinks, setShowDetailedLinks] = useState(false);

  // --- These selectors correctly get the filtered data ---
  const pikudim = useSelector((state) => selectPikudimByTypeId(state, 1));
  const allDevicesForType = useSelector((state) =>
    selectDevicesByTypeId(state, 1)
  );
  const linksRaw = useSelector((state) => selectLinksByTypeId(state, 1));

  // The `useMemo` for graphData is unchanged and correct
  const graphData = useMemo(() => {
    if (!pikudim.length || !allDevicesForType.length) {
      return { nodes: [], links: [] };
    }

    const devicesByPikudId = allDevicesForType.reduce((acc, device) => {
      const siteId = device.core_pikudim_site_id;
      if (!acc[siteId]) {
        acc[siteId] = [];
      }
      acc[siteId].push(device);
      return acc;
    }, {});

    const topDevicesPerPikud = Object.values(devicesByPikudId).flatMap(
      (deviceGroup) => selectTopTwoDevices(deviceGroup)
    );

    const visibleDeviceHostnames = new Set(
      topDevicesPerPikud.map((d) => d.hostname)
    );

    const pikudimMap = pikudim.reduce((acc, p) => {
      acc[p.id] = p;
      return acc;
    }, {});
    const transformedNodes = topDevicesPerPikud.map((device) => ({
      id: device.hostname,
      group: "node",
      zone:
        pikudimMap[device.core_pikudim_site_id]?.core_site_name ||
        "Unknown Zone",
    }));

    const transformedLinks = linksRaw
      .filter(
        (link) =>
          visibleDeviceHostnames.has(link.source) &&
          visibleDeviceHostnames.has(link.target)
      )
      .map((link) => ({
        id: link.id,
        source: link.source,
        target: link.target,
        category: link.status,
      }));

    return { nodes: transformedNodes, links: transformedLinks };
  }, [pikudim, allDevicesForType, linksRaw]);

  // All handlers are unchanged
  const handleZoneClick = useCallback(
    (zoneId) => {
      navigate(`zone/${zoneId}`);
    },
    [navigate]
  );

  const handleNodeClick = useCallback(
    (nodeData) => {
      if (nodeData && nodeData.id && nodeData.zone) {
        navigate(`zone/${nodeData.zone}/node/${nodeData.id}`);
      } else {
        console.warn("Node data incomplete for navigation:", nodeData);
      }
    },
    [navigate]
  );

  const handleLinkClick = useCallback(
    (linkDetailPayload) => {
      const { id, sourceNode, targetNode } = linkDetailPayload;
      const tabExists = openLinkTabs.some((tab) => tab.id === id);

      if (!tabExists) {
        const newTab = {
          id: id,
          title: `${sourceNode} - ${targetNode}`,
          type: "link",
          data: linkDetailPayload,
        };
        setOpenLinkTabs((prevTabs) => [...prevTabs, newTab]);
      }
      setActiveLinkTabId(id);
    },
    [openLinkTabs]
  );

  const handleCloseTab = useCallback(
    (tabIdToClose) => {
      setOpenLinkTabs((prevTabs) => {
        const remainingTabs = prevTabs.filter((tab) => tab.id !== tabIdToClose);
        if (activeLinkTabId === tabIdToClose) {
          setActiveLinkTabId(
            remainingTabs.length > 0
              ? remainingTabs[remainingTabs.length - 1].id
              : null
          );
        }
        return remainingTabs;
      });
    },
    [activeLinkTabId]
  );

  const handleToggleDetailView = useCallback(() => {
    setShowDetailedLinks((prev) => !prev);
  }, []);

  const handleRetry = () => dispatch(fetchInitialData());

  // --- Loading and Error Rendering Logic ---
  const isLoading =
    pikudimStatus === "loading" ||
    devicesStatus === "loading" ||
    linksStatus === "loading";
  const hasError =
    pikudimStatus === "failed" ||
    devicesStatus === "failed" ||
    linksStatus === "failed";

  // This state is derived after loading/errors are handled
  const isDataEmpty = !isLoading && !hasError && graphData.nodes.length === 0;

  if (isLoading) {
    return <LoadingSpinner text="Building L-Chart..." />;
  }

  if (hasError) {
    return <ErrorMessage onRetry={handleRetry} />;
  }

  if (isDataEmpty) {
    return (
      <div className="flex h-full w-full flex-col items-center justify-center p-4 text-center">
        <h3 className="text-xl font-semibold text-gray-700 dark:text-gray-300">
          No Data Available
        </h3>
        <p className="mt-2 text-gray-500 dark:text-gray-400">
          There is no network data available to build the L-Chart.
        </p>
      </div>
    );
  }

  // --- Original component return ---
  return (
    <div className="w-full h-full flex flex-col">
      {openLinkTabs.length > 0 && (
        <div className="flex-shrink-0">
          <LinkDetailTabs
            tabs={openLinkTabs}
            activeTabId={activeLinkTabId}
            onSetActiveTab={setActiveLinkTabId}
            onCloseTab={handleCloseTab}
            theme={theme}
          />
        </div>
      )}

      <div className="flex-grow relative">
        <ToggleDetailButton
          isDetailed={showDetailedLinks}
          onToggle={handleToggleDetailView}
          theme={theme}
        />
        <NetworkVisualizer
          key={theme}
          data={graphData}
          theme={theme}
          showDetailedLinks={showDetailedLinks}
          onZoneClick={handleZoneClick}
          onLinkClick={handleLinkClick}
          onNodeClick={handleNodeClick}
        />
      </div>
    </div>
  );
};

export default NetworkVisualizerWrapper;

--- File: src\redux\dummyData.jsx ---
import { faker } from "@faker-js/faker";

// --- NEW: Add the mock alert generator here ---
export const generateMockAlerts = () => {
  // ... (no changes in this function)
  const alerts = [];
  const now = new Date();
  const types = ["error", "warning", "info"];
  const messages = [
    "Network line Alpha-01 experiencing high latency.",
    "Router Gamma-03 offline.",
    "Firewall policy update successful on Delta-Cluster.",
    "Network segment Beta-West approaching capacity.",
    "Unusual traffic pattern detected from IP 192.168.1.100.",
    "VPN connection dropped for user 'johndoe'.",
    "Server Epsilon-db CPU utilization at 95%.",
    "New device connected: IOT-Sensor-7B on VLAN 10.",
    "Security scan completed: 0 vulnerabilities found.",
    "Backup job 'DailySystemBackup' finished successfully.",
  ];

  const alertCount = faker.number.int({ min: 1950, max: 2050 });

  for (let i = 0; i < alertCount; i++) {
    const randomMinutesAgo = Math.floor(Math.random() * 7 * 24 * 60 * 1.5);
    alerts.push({
      id: `alert-${i + 1}-${faker.string.uuid()}`,
      type: types[Math.floor(Math.random() * types.length)],
      message: messages[Math.floor(Math.random() * messages.length)],
      timestamp: new Date(now.getTime() - randomMinutesAgo * 60000),
      networkLine: `Line-${String.fromCharCode(65 + Math.floor(i / 10))}-${
        (i % 10) + 1
      }`,
      details: `This is a more detailed description for alert ${
        i + 1
      }. It might include diagnostic information, affected systems, or suggested actions.`,
      source: `SourceSystem-${Math.floor(Math.random() * 5) + 1}`,
      severityScore: Math.floor(Math.random() * 10) + 1,
    });
  }
  return alerts.sort((a, b) => b.timestamp - a.timestamp);
};

// --- 1. ADD DUMMY USERS ARRAY ---
const dummyUsers = [
  { username: "admin", password: "password123", role: "admin" },
  { username: "userg", password: "password123", role: "user" },
  { username: "viewer", password: "password", role: "viewer" },
];

// --- Helper to create a number of items ---
const createItems = (creator, count, ...args) => {
  return Array.from({ length: count }, () => creator(...args));
};

// --- Individual Data Generators ---

const createCorePikudim = (typeId) => ({
  id: faker.number.int({ min: 1000, max: 9999 }),
  core_site_name: `Pikud-${faker.location.city()}`,
  type_id: typeId,
  timestamp: faker.date.recent().toISOString(),
});

const createCoreDevice = (pikud, endingNumber) => ({
  id: faker.number.int({ min: 100, max: 999 }),
  hostname: `rtr-${faker.string.alphanumeric(4)}-${endingNumber}`,
  ip_address: faker.internet.ip(),
  network_type_id: pikud.type_id,
  core_pikudim_site_id: pikud.id,
  timestamp: faker.date.recent().toISOString(),
});

const createSite = (siteNames, device, interfaceData) => ({
  id: faker.number.int({ min: 10000, max: 99999 }),
  interface_id: interfaceData.name || "N/A",
  device_id: device.id,
  site_name_hebrew: siteNames.hebrew,
  site_name_english: siteNames.english,
  timestamp: faker.date.recent().toISOString(),
  physicalStatus: interfaceData.physical_status || "N/A",
  protocolStatus: interfaceData.protocol_status || "N/A",
  MPLS: interfaceData.mpls || "N/A",
  OSPF: interfaceData.ospf || "N/A",
  Bandwidth: interfaceData.bandwidth ?? "N/A",
  Description: interfaceData.description || "N/A",
  MediaType: interfaceData.media_type || "N/A",
  CDP: interfaceData.cdp || "N/A",
  TX: interfaceData.tx ?? "N/A",
  RX: interfaceData.rx ?? "N/A",
});

const createInterfaceInfo = (deviceId) => ({
  id: faker.number.int({ min: 5000, max: 9999 }),
  name: faker.helpers.arrayElement([
    "GigabitEthernet0/1",
    "TenGigabitEthernet1/0/1",
    "FastEthernet0/24",
  ]),
  core_pikudim_device_id: deviceId,
  media_type: "Fiber",
  description: faker.lorem.sentence(),
  physical_status: faker.helpers.arrayElement(["Up", "Down"]),
  protocol_status: faker.helpers.arrayElement(["Up", "Down"]),
  cdp: `neighbor-switch-${faker.string.alphanumeric(3)}`,
  bandwidth: 10000,
  mtu: 9000,
  ospf: "Enabled",
  mpls: "Enabled",
  crc: faker.number.int({ min: 0, max: 10 }),
  input_data: faker.number.int({ min: 100, max: 900 }),
  output_data: faker.number.int({ min: 100, max: 800 }),
  tx: -faker.number.float({ min: 1, max: 5, precision: 0.1 }),
  rx: -faker.number.float({ min: 1, max: 5, precision: 0.1 }),
  timestamp: faker.date.recent().toISOString(),
});

// --- MODIFIED & CORRECTED ---
// The `targetInterface` argument has been removed as it was unused.
const createTenGigLink = (sourceDevice, targetDevice, sourceInterface) => ({
  id: `link-10g-${faker.string.alphanumeric(8)}`,
  source: sourceDevice.hostname,
  target: targetDevice.hostname,
  network_type_id: sourceDevice.network_type_id,
  ip: faker.internet.ip(),
  status: faker.helpers.arrayElement(["up", "down", "issue"]),

  // --- NEW FIELDS ---
  // We'll use the source interface's data for the link's properties.
  // Using the nullish coalescing operator `??` for numbers to correctly handle 0.
  physicalStatus: sourceInterface.physical_status || "N/A",
  protocolStatus: sourceInterface.protocol_status || "N/A",
  MPLS: sourceInterface.mpls || "N/A",
  OSPF: sourceInterface.ospf || "N/A",
  Bandwidth: sourceInterface.bandwidth ?? "N/A",
  Description: sourceInterface.description || "N/A",
  MediaType: sourceInterface.media_type || "N/A",
  CDP: sourceInterface.cdp || "N/A",
  TX: sourceInterface.tx ?? "N/A",
  RX: sourceInterface.rx ?? "N/A",
});

// --- Main Export Function ---

export const generateAllDummyData = () => {
  // --- 1. Generate Pikudim (Core Sites) and Devices ---
  const lChartPikudim = createItems(createCorePikudim, 6, 1);
  const pChartPikudim = createItems(createCorePikudim, 5, 2);
  const corePikudim = [...lChartPikudim, ...pChartPikudim];

  const allowedEndings = [1, 2, 4, 5, 7, 8];
  const coreDevices = corePikudim.flatMap((pikud) => {
    const deviceCount = faker.number.int({ min: 2, max: 6 });
    const devicesForThisPikud = [];
    for (let i = 0; i < deviceCount && i < allowedEndings.length; i++) {
      const endingNumber = allowedEndings[i];
      devicesForThisPikud.push(createCoreDevice(pikud, endingNumber));
    }
    return devicesForThisPikud;
  });

  // --- Generate deviceInfo early, as it's needed for both links and sites ---
  const deviceInfo = coreDevices.reduce((acc, device) => {
    acc[device.id] = createItems(
      createInterfaceInfo,
      faker.number.int({ min: 3, max: 8 }),
      device.id
    );
    return acc;
  }, {});

  // --- 2. Group Devices by their Core Site ID ---
  const devicesBySite = new Map();
  for (const device of coreDevices) {
    if (!devicesBySite.has(device.core_pikudim_site_id)) {
      devicesBySite.set(device.core_pikudim_site_id, []);
    }
    devicesBySite.get(device.core_pikudim_site_id).push(device);
  }

  // --- 3. Generate Structured "Same Site" Links ---
  // --- MODIFIED & CORRECTED ---
  const sameSiteLinks = [];
  const sameSitePairs = [
    [1, 2],
    [1, 4],
    [1, 5],
    [2, 4],
    [2, 5],
    [4, 5],
    [4, 7],
    [4, 8],
    [5, 7],
    [5, 8],
    [7, 8],
  ];

  for (const siteDevices of devicesBySite.values()) {
    const deviceMapByEnding = new Map();
    for (const device of siteDevices) {
      const ending = parseInt(device.hostname.split("-").pop(), 10);
      deviceMapByEnding.set(ending, device);
    }
    for (const [end1, end2] of sameSitePairs) {
      if (deviceMapByEnding.has(end1) && deviceMapByEnding.has(end2)) {
        const sourceDevice = deviceMapByEnding.get(end1);
        const targetDevice = deviceMapByEnding.get(end2);

        // We only need an interface from the source device to enrich the link data
        const sourceInterfaces = deviceInfo[sourceDevice.id];

        // The check for targetInterfaces is removed as it's not needed for link creation
        if (sourceInterfaces?.length > 0) {
          const sourceInterface = faker.helpers.arrayElement(sourceInterfaces);
          sameSiteLinks.push(
            // The call to createTenGigLink now only passes the source interface
            createTenGigLink(sourceDevice, targetDevice, sourceInterface)
          );
        }
      }
    }
  }

  // --- 4. Generate Random "Different Site" Links ---
  // --- MODIFIED & CORRECTED ---
  const differentSiteLinks = [];
  const lChartDevices = coreDevices.filter((d) => d.network_type_id === 1);
  const pChartDevices = coreDevices.filter((d) => d.network_type_id === 2);

  const createRandomInterSiteLinks = (deviceList, count) => {
    const createdPairs = new Set();
    for (let i = 0; i < count; i++) {
      if (deviceList.length < 2) break;
      let sourceDevice, targetDevice, pairKey;
      do {
        sourceDevice = faker.helpers.arrayElement(deviceList);
        targetDevice = faker.helpers.arrayElement(deviceList);
        const sortedIds = [sourceDevice.id, targetDevice.id].sort();
        pairKey = `${sortedIds[0]}-${sortedIds[1]}`;
      } while (
        sourceDevice.core_pikudim_site_id ===
          targetDevice.core_pikudim_site_id ||
        createdPairs.has(pairKey)
      );

      // Only need the source interface
      const sourceInterfaces = deviceInfo[sourceDevice.id];

      if (sourceInterfaces?.length > 0) {
        const sourceInterface = faker.helpers.arrayElement(sourceInterfaces);
        differentSiteLinks.push(
          // The call to createTenGigLink now only passes the source interface
          createTenGigLink(sourceDevice, targetDevice, sourceInterface)
        );
        createdPairs.add(pairKey);
      }
    }
  };

  createRandomInterSiteLinks(lChartDevices, 50);
  createRandomInterSiteLinks(pChartDevices, 40);

  const tenGigLinks = [...sameSiteLinks, ...differentSiteLinks];

  // --- 5. Generate Paired Sites (Dual-Homed) ---
  const sites = [];
  const numberOfLogicalSites = 250;

  if (coreDevices.length >= 2) {
    for (let i = 0; i < numberOfLogicalSites; i++) {
      const city = faker.location.city();
      const siteNames = { hebrew: `אתר ${city}`, english: `Site ${city}` };

      let device1, device2;
      do {
        device1 = faker.helpers.arrayElement(coreDevices);
        device2 = faker.helpers.arrayElement(coreDevices);
      } while (device1.id === device2.id);

      const interfaces1 = deviceInfo[device1.id];
      if (interfaces1?.length > 0) {
        const interface1 = faker.helpers.arrayElement(interfaces1);
        sites.push(createSite(siteNames, device1, interface1));
      }

      const interfaces2 = deviceInfo[device2.id];
      if (interfaces2?.length > 0) {
        const interface2 = faker.helpers.arrayElement(interfaces2);
        sites.push(createSite(siteNames, device2, interface2));
      }
    }
  }

  // --- 6. Finalize Remaining Data ---
  const netTypes = [
    { id: 1, name: "L-Chart Network" },
    { id: 2, name: "P-Chart Network" },
  ];

  return {
    corePikudim,
    coreDevices,
    sites,
    deviceInfo,
    netTypes,
    tenGigLinks,
    dummyUsers,
  };
};

--- File: src\redux\initialData.jsx ---
import { generateAllDummyData } from "./dummyData";

// Generate the data ONCE and export it.
export const initialData = generateAllDummyData();

--- File: src\redux\store.jsx ---
// src/redux/store.js

import { configureStore, combineReducers } from "@reduxjs/toolkit";
import sitesReducer from "./slices/sitesSlice";
import devicesReducer from "./slices/devicesSlice";
import tenGigLinksReducer from "./slices/tenGigLinksSlice";
import corePikudimReducer from "./slices/corePikudimSlice";
import favoritesReducer from "./slices/favoritesSlice";
import netTypesReducer from "./slices/netTypesSlice";
import authReducer, { logout } from "./slices/authSlice";
import realtimeReducer from "./slices/realtimeSlice";
import alertsReducer from "./slices/alertsSlice";
import realtimeMiddleware from "./middleware/realtimeMiddleware";

// 1. Combine all your slice reducers into a single "app" reducer
const appReducer = combineReducers({
  sites: sitesReducer,
  devices: devicesReducer,
  tenGigLinks: tenGigLinksReducer,
  corePikudim: corePikudimReducer,
  favorites: favoritesReducer,
  netTypes: netTypesReducer,
  auth: authReducer,
  realtime: realtimeReducer,
  alerts: alertsReducer,
});

// 2. Create a "root" reducer that delegates to the appReducer, but handles the logout case
const rootReducer = (state, action) => {
  // When the logout action is dispatched, reset the state to its initial value
  if (action.type === logout.type) {
    // By passing `undefined` as the state, `appReducer` will return the initial state for all slices.
    // We keep the `auth` and `realtime` state to avoid a flash of a logged-out screen before redirecting.
    // Or, more simply, reset everything:
    state = undefined;
  }
  return appReducer(state, action);
};

export const store = configureStore({
  // 3. Use the new rootReducer
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: false,
    }).concat(realtimeMiddleware),
});

--- File: src\redux\middleware\realtimeMiddleware.jsx ---
import realtimeService from "../../services/realtimeService";
import { startConnecting, disconnect } from "../slices/realtimeSlice";

const realtimeMiddleware = (store) => (next) => (action) => {
  const { dispatch, getState } = store;

  // Let the action pass through to the reducers first
  next(action);

  // Intercept specific actions to manage the service
  switch (action.type) {
    case startConnecting.type:
      // When the app wants to connect, start the service.
      realtimeService.start(dispatch, getState);
      break;

    case disconnect.type:
      // When the app wants to disconnect, stop the service.
      realtimeService.stop();
      break;

    default:
      break;
  }
};

export default realtimeMiddleware;

--- File: src\redux\slices\alertsSlice.jsx ---
// src/redux/slices/alertsSlice.js  <-- Note the .js extension

import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import { generateMockAlerts } from "../dummyData";

//import { api } from "../../services/apiServices"; // <-- 1. Import the real api

// --- ASYNC THUNKS for Alerts ---
export const fetchAllAlerts = createAsyncThunk(
  "alerts/fetchAll",
  async (_, { rejectWithValue }) => {
    try {
      // MOCK IMPLEMENTATION
      console.log("Fetching new mock alerts...");
      await new Promise((resolve) => setTimeout(resolve, 750));
      const mockAlerts = generateMockAlerts();
      return mockAlerts;

      //const alerts = await api.getAllAlerts(); // <-- 2. Use the real api call
      //return alerts;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const deleteAlert = createAsyncThunk(
  "alerts/delete",
  async (alertId, { rejectWithValue }) => {
    try {
      // await api.deleteAlert(alertId); // This would be the real API call

      //await api.deleteAlert(alertId); // <-- 3. Use the real api call
      return alertId;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

export const favoriteAlert = createAsyncThunk(
  "alerts/favorite",
  async (alertId, { rejectWithValue }) => {
    try {
      // await api.favoriteAlert(alertId); // This would be the real API call
      //await api.favoriteAlert(alertId); // <-- 4. Use the real api call
      return alertId;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

const alertsSlice = createSlice({
  name: "alerts",
  initialState: {
    items: [],
    status: "idle", // 'idle' | 'loading' | 'succeeded' | 'failed'
    error: null,
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      // Fetching alerts
      .addCase(fetchAllAlerts.pending, (state) => {
        state.status = "loading";
      })
      .addCase(fetchAllAlerts.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.items = action.payload;
      })
      .addCase(fetchAllAlerts.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.payload;
      })
      // Deleting an alert
      .addCase(deleteAlert.fulfilled, (state, action) => {
        const alertIdToRemove = action.payload;
        state.items = state.items.filter(
          (alert) => alert.id !== alertIdToRemove
        );
      })
      // Favoriting an alert
      .addCase(favoriteAlert.fulfilled, (state, action) => {
        const alertIdToFavorite = action.payload;
        const alert = state.items.find((a) => a.id === alertIdToFavorite);
        if (alert) {
          alert.isFavorite = !alert.isFavorite;
        }
      });
  },
});

// --- FIX: ADD THE MISSING EXPORTS HERE ---
export const selectAllAlerts = (state) => state.alerts.items;
export const selectAlertsStatus = (state) => state.alerts.status; // This was missing
export const selectAlertsError = (state) => state.alerts.error; // Also good to have

export default alertsSlice.reducer;

--- File: src\redux\slices\authSlice.jsx ---
// src/redux/slices/authSlice.js

import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import Cookies from "js-cookie";
import { initialData } from "../initialData";

// --- 1. Import the individual data-fetching thunks from other slices ---
import { fetchCorePikudim } from "./corePikudimSlice";
import { fetchDevices } from "./devicesSlice";
import { fetchSites } from "./sitesSlice";
import { fetchTenGigLinks } from "./tenGigLinksSlice";

// Get dummy users for the mock login
const { dummyUsers } = initialData;

//import { api } from "../../services/apiServices"; // <-- 1. Import the real api

// --- MOCK API: This object simulates your backend's login endpoint ---
const mockApi = {
  login: async (username, password) => {
    // Simulate network delay
    await new Promise((resolve) => setTimeout(resolve, 1500));
    const user = dummyUsers.find(
      (u) => u.username === username && u.password === password
    );

    if (user) {
      // On success, create and return a mock token
      const mockToken = `fake-jwt-token-for-${user.username}`;
      return mockToken;
    } else {
      // On failure, throw an error, just like a real API would
      throw new Error("Invalid credentials. Please try again.");
    }
  },
};

// --- 2. The "Master" Data Fetching Thunk ---
// This thunk's only job is to dispatch all the other data-fetching actions in parallel.
export const fetchInitialData = createAsyncThunk(
  "auth/fetchInitialData",
  async (_, { dispatch }) => {
    // Dispatch all data fetches concurrently. Redux Toolkit handles this efficiently.
    // The status of each fetch is managed within its own respective slice.
    dispatch(fetchCorePikudim());
    dispatch(fetchDevices());
    dispatch(fetchSites());
    dispatch(fetchTenGigLinks());
    // This thunk doesn't need to return a value, as it's just a coordinator.
  }
);

// --- 3. The Login User Thunk (Updated) ---
// This is the primary thunk called by the LoginPage.
export const loginUser = createAsyncThunk(
  "auth/loginUser",
  async ({ username, password }, { dispatch, rejectWithValue }) => {
    try {
      // LATER: You will change this line to `await api.login(username, password);`
      const token = await mockApi.login(username, password);

      //const token = await api.login(username, password); // <-- 2. Use the real api call

      // Set the token in a cookie for session persistence
      Cookies.set("authToken", token, {
        expires: 1,
        secure: true,
        sameSite: "strict",
      });

      // **KEY STEP:** After a successful login, trigger the fetch for all initial app data.
      dispatch(fetchInitialData());

      // Return the token to be saved in the auth state
      return token;
    } catch (error) {
      // If login fails, pass the error message to the 'rejected' case
      return rejectWithValue(error.message);
    }
  }
);

// --- 4. The Auth Slice Definition ---
const authSlice = createSlice({
  name: "auth",
  initialState: {
    token: Cookies.get("authToken") || null,
    status: "idle", // 'idle' | 'loading' | 'succeeded' | 'failed'
    error: null,
  },
  reducers: {
    // Handles user-initiated logout
    logout: (state) => {
      state.token = null;
      state.status = "idle";
      state.error = null;
      Cookies.remove("authToken");
      // Note: You might want to also dispatch actions to clear the other data slices here
      // if you want the data to be gone immediately on logout.
    },
  },
  // Handles the lifecycle of the `loginUser` thunk
  extraReducers: (builder) => {
    builder
      .addCase(loginUser.pending, (state) => {
        state.status = "loading";
        state.error = null;
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.token = action.payload;
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.payload;
      });
  },
});

// --- Export Actions and Selectors ---
export const { logout } = authSlice.actions;

export const selectAuthToken = (state) => state.auth.token;
export const selectAuthStatus = (state) => state.auth.status;
export const selectAuthError = (state) => state.auth.error;

// --- Export Reducer ---
export default authSlice.reducer;

--- File: src\redux\slices\corePikudimSlice.jsx ---
import {
  createSlice,
  createSelector,
  createAsyncThunk,
} from "@reduxjs/toolkit";
// Assuming an apiService file exists to handle the actual HTTP requests
// import { apiService } from "../../services/apiService";
import { initialData } from "../initialData";

//import { api } from "../../services/apiServices"; // <-- 1. Import the real api

// --- MOCK API ---
const mockApi = {
  getCorePikudim: async () => {
    await new Promise((resolve) => setTimeout(resolve, 200));
    return initialData.corePikudim;
  },
  // Mocks for the new operations
  addCoreSite: async (siteData) => {
    await new Promise((resolve) => setTimeout(resolve, 500));
    console.log("Mock API: Adding site...", siteData);
    // In a real API, you'd get the newly created object back
    return { ...siteData, id: Date.now(), timestamp: new Date().toISOString() };
  },
  deleteCoreSite: async (siteId) => {
    await new Promise((resolve) => setTimeout(resolve, 500));
    console.log("Mock API: Deleting site with ID:", siteId);
    return { success: true };
  },
};

// --- ASYNC THUNKS ---

// 1. For FETCHING the initial list of Pikudim (Core Sites)
export const fetchCorePikudim = createAsyncThunk(
  "corePikudim/fetchCorePikudim",
  async (_, { rejectWithValue }) => {
    try {
      // const response = await apiService.getCorePikudim();
      const response = await mockApi.getCorePikudim();
      //const response = await api.getCorePikudim(); // <-- 2. Use real api
      return response;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// 2. For ADDING a new Core Site
export const addCoreSite = createAsyncThunk(
  "corePikudim/addCoreSite",
  async (siteData, { dispatch, rejectWithValue }) => {
    try {
      // This is where you call your real backend API
      // await apiService.addCorePikudim(siteData);
      await mockApi.addCoreSite(siteData);

      //await api.addCorePikudim(siteData); // <-- 3. Use real api

      // On success, re-fetch the entire list to ensure data consistency
      dispatch(fetchCorePikudim());

      return siteData; // Return the original data for potential UI feedback
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// 3. For DELETING a Core Site
export const deleteCoreSite = createAsyncThunk(
  "corePikudim/deleteCoreSite",
  async (siteId, { dispatch, rejectWithValue }) => {
    try {
      // This is where you call your real backend API
      // await apiService.deleteCorePikudim(siteId);
      await mockApi.deleteCoreSite(siteId);

      //await api.deleteCorePikudim(siteId); // <-- 4. Use real api

      // On success, re-fetch the list to reflect the deletion
      dispatch(fetchCorePikudim());

      return siteId; // Return the deleted ID for potential UI feedback
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// --- The Slice Definition ---
const corePikudimSlice = createSlice({
  name: "corePikudim",
  initialState: {
    items: [],
    status: "idle", // 'idle' | 'loading' | 'succeeded' | 'failed'
    error: null,
  },
  // Synchronous reducers are no longer needed for add/delete
  reducers: {},
  // This handles the state changes for the FETCH thunk.
  // We don't need to handle add/delete here because the re-fetch takes care of it.
  extraReducers: (builder) => {
    builder
      .addCase(fetchCorePikudim.pending, (state) => {
        state.status = "loading";
        state.error = null;
      })
      .addCase(fetchCorePikudim.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.items = action.payload;
      })
      .addCase(fetchCorePikudim.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.payload;
      });
  },
});

// --- Export Selectors (Unchanged) ---
export const selectAllPikudim = (state) => state.corePikudim.items;

export const selectPikudimById = (state, pikudimId) =>
  state.corePikudim.items.find((p) => p.id === pikudimId);

const selectPikudimItems = (state) => state.corePikudim.items;
const selectTypeId = (state, typeId) => typeId;

export const selectPikudimByTypeId = createSelector(
  [selectPikudimItems, selectTypeId],
  (pikudim, typeId) => {
    if (!typeId) return [];
    return pikudim.filter((p) => p.type_id === typeId);
  }
);

// --- Export Reducer ---
export default corePikudimSlice.reducer;

--- File: src\redux\slices\devicesSlice.jsx ---
import {
  createSlice,
  createSelector,
  createAsyncThunk,
} from "@reduxjs/toolkit";
import { initialData } from "../initialData";

//import { api } from "../../services/apiServices"; // <-- 1. Import the real api

// --- MOCK API: Mimics the real API call using dummy data ---
// This isolates the data source, preparing it for the real API.
const mockApi = {
  getCoreDevices: async () => {
    // Simulate a network delay
    await new Promise((resolve) => setTimeout(resolve, 250));

    // The real API might return devices and deviceInfo separately.
    // For this mock, we'll bundle them to populate the initial state easily.
    return {
      devices: initialData.coreDevices,
      deviceInfo: initialData.deviceInfo,
    };
  },
};

// --- ASYNC THUNK: For fetching the devices and their info ---
export const fetchDevices = createAsyncThunk(
  "devices/fetchDevices",
  async (_, { rejectWithValue }) => {
    try {
      // LATER: When you're ready for the real API, you will change this line to:
      // const response = await api.getCoreDevices();
      // And you might need another call for deviceInfo if it's a separate endpoint.
      const response = await mockApi.getCoreDevices();
      return response;

      // Step 1: Fetch the list of all core devices
      //const devices = await api.getCoreDevices();

      /*// Step 2: For each device, fetch its detailed interface info
      const deviceInfoPromises = devices.map(device =>
        api.getDeviceInfo(device.id)
      );
      const allDeviceInfoArrays = await Promise.all(deviceInfoPromises);
      
      // Step 3: Combine the device info arrays into a single map object
      const deviceInfo = allDeviceInfoArrays.reduce((acc, infoArray, index) => {
        const deviceId = devices[index].id;
        acc[deviceId] = infoArray;
        return acc;
      }, {});

      // Step 4: Return the combined payload, matching the slice's expected shape
      return { devices, deviceInfo };*/
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// --- The Slice Definition ---
const devicesSlice = createSlice({
  name: "devices",
  initialState: {
    items: [], // Start with an empty array for the device list
    deviceInfo: {}, // Start with an empty object for device info
    status: "idle", // 'idle' | 'loading' | 'succeeded' | 'failed'
    error: null,
  },
  // Reducers for synchronous, direct state mutations
  reducers: {
    addCoreDevice: (state, action) => {
      state.items.push(action.payload);
    },
    deleteCoreDevice: (state, action) => {
      const deviceIdToDelete = action.payload;
      state.items = state.items.filter((item) => item.id !== deviceIdToDelete);
    },
  },
  // extraReducers handle the lifecycle of the async thunk
  extraReducers: (builder) => {
    builder
      .addCase(fetchDevices.pending, (state) => {
        state.status = "loading";
        state.error = null;
      })
      .addCase(fetchDevices.fulfilled, (state, action) => {
        state.status = "succeeded";
        // Populate the state with the fetched data
        state.items = action.payload.devices;
        state.deviceInfo = action.payload.deviceInfo;
      })
      .addCase(fetchDevices.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.payload; // Get error message from rejectWithValue
      });
  },
});

// --- Export Actions ---
export const { addCoreDevice, deleteCoreDevice } = devicesSlice.actions;

// --- Export Selectors ---

export const selectAllDevices = (state) => state.devices.items;
export const selectDeviceInfo = (state) => state.devices.deviceInfo;

// --- MEMOIZED SELECTOR for filtering devices ---
const selectDeviceItems = (state) => state.devices.items;
const selectTypeIdFromDevice = (state, typeId) => typeId;

export const selectDevicesByTypeId = createSelector(
  [selectDeviceItems, selectTypeIdFromDevice],
  (devices, typeId) => {
    if (!typeId) return [];
    return devices.filter((d) => d.network_type_id === typeId);
  }
);

// --- MEMOIZED SELECTOR for the loading/error status ---
// This selector solves the "returned a different result" warning.
// It combines `status` and `error` into a single object, but only creates a
// new object if `status` or `error` themselves have actually changed.

// 1. Input selectors: These grab the raw data without creating new references.
const selectStatus = (state) => state.devices.status;
const selectError = (state) => state.devices.error;

// 2. Memoized Selector: This is the one to use in your components.
export const selectCoreDataStatus = createSelector(
  [selectStatus, selectError], // An array of the input selectors
  (status, error) => ({
    // The "result" function that creates the object
    status,
    error,
  })
);

// --- Export Reducer ---
export default devicesSlice.reducer;

--- File: src\redux\slices\favoritesSlice.jsx ---
// src/redux/slices/favoritesSlice.js

import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";

//import { api } from "../../services/apiServices"; // <-- 1. Import the real api

// --- MOCK API: Simulates fetching/updating favorites on the server ---
// This will be replaced by the real `api` calls.
const mockApi = {
  getFavoriteLinks: async () => {
    // Simulate a network delay
    await new Promise((resolve) => setTimeout(resolve, 400));
    // In a real scenario, the server would return the user's saved favorites.
    // For the mock, we'll start with a few predefined favorites.
    return ["link-10g-hYpWqRz2", "link-10g-aB3cVfG9", "link-10g-kLp0oXn4"];
  },
  updateFavoriteLinks: async (linkIds) => {
    // Simulate a network delay for the update operation
    await new Promise((resolve) => setTimeout(resolve, 600));
    console.log("[Mock API] Updated favorite links on server:", linkIds);
    // Real API would return a success message or the updated list.
    return { success: true, updatedIds: linkIds };
  },
};

// --- ASYNC THUNKS ---

/**
 * Thunk to fetch the user's initial list of favorite link IDs.
 * This should be dispatched after a successful login.
 */
export const fetchFavoriteLinks = createAsyncThunk(
  "favorites/fetchFavoriteLinks",
  async (_, { rejectWithValue }) => {
    try {
      // LATER: Change this to `const response = await api.getFavoriteLinks();`
      const response = await mockApi.getFavoriteLinks();
      //const response = await api.getFavoriteLinks(); // <-- 2. Import the real api
      return response;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

/**
 * Thunk to toggle a single favorite link.
 * It uses an "optimistic update" pattern for a fast and responsive UI.
 * 1. It immediately updates the local state (optimistic).
 * 2. It sends the update to the server.
 * 3. If the server fails, it reverts the local state change.
 */
export const toggleFavoriteLink = createAsyncThunk(
  "favorites/toggleFavoriteLink",
  async (linkId, { getState, rejectWithValue }) => {
    const { ids: currentIds } = getState().favorites;
    const isCurrentlyFavorite = currentIds.includes(linkId);

    // Create the new array of IDs that will be sent to the server.
    const newIds = isCurrentlyFavorite
      ? currentIds.filter((id) => id !== linkId)
      : [...currentIds, linkId];

    try {
      // LATER: Change this to `await api.updateFavoriteLinks(newIds);`
      await mockApi.updateFavoriteLinks(newIds);
      // Return the successfully updated array to the `fulfilled` reducer.
      //await api.updateFavoriteLinks(newIds); // <-- 3. Import the real api
      return newIds;
    } catch (error) {
      // If the API call fails, rejectWithValue will pass the error to the `rejected` reducer.
      return rejectWithValue(error.message);
    }
  }
);

// --- The Slice Definition ---
const favoritesSlice = createSlice({
  name: "favorites",
  initialState: {
    ids: [], // The array of favorite link IDs
    status: "idle", // 'idle' | 'loading' | 'succeeded' | 'failed'
    error: null,
  },
  // No synchronous reducers are needed anymore.
  reducers: {},
  extraReducers: (builder) => {
    builder
      // --- Reducers for fetching initial favorites ---
      .addCase(fetchFavoriteLinks.pending, (state) => {
        state.status = "loading";
        state.error = null;
      })
      .addCase(fetchFavoriteLinks.fulfilled, (state, action) => {
        state.status = "succeeded";
        state.ids = action.payload; // Populate with IDs from the server
      })
      .addCase(fetchFavoriteLinks.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.payload;
      })

      // --- Reducers for the optimistic toggle ---
      .addCase(toggleFavoriteLink.pending, (state, action) => {
        // OPTIMISTIC UPDATE: Update the state immediately for a responsive UI.
        const linkId = action.meta.arg; // The linkId passed to the thunk
        const index = state.ids.indexOf(linkId);
        if (index >= 0) {
          state.ids.splice(index, 1); // It exists, so remove it
        } else {
          state.ids.push(linkId); // It doesn't exist, so add it
        }
      })
      .addCase(toggleFavoriteLink.fulfilled, (state, action) => {
        // The API call was successful. The state is already correct from the
        // optimistic update, but we can sync it with the server response for safety.
        state.ids = action.payload;
      })
      .addCase(toggleFavoriteLink.rejected, (state, action) => {
        // ROLLBACK: The API call failed. We must revert the optimistic update.
        const linkId = action.meta.arg; // The linkId that failed
        const index = state.ids.indexOf(linkId);
        if (index >= 0) {
          // It's in the state, meaning we optimistically ADDED it. Rollback by REMOVING.
          state.ids.splice(index, 1);
        } else {
          // It's not in the state, meaning we optimistically REMOVED it. Rollback by ADDING.
          state.ids.push(linkId);
        }
        // You might want to show a toast notification to the user here.
        console.error("Failed to update favorite:", action.payload);
      });
  },
});

// --- Export Actions ---
// Note: We don't export actions from `reducers` anymore, only the thunks.

// --- Export Selectors ---
export const selectFavoriteIds = (state) => state.favorites.ids;
export const selectFavoritesStatus = (state) => state.favorites.status;

export default favoritesSlice.reducer;

--- File: src\redux\slices\netTypesSlice.jsx ---
import {
  createSlice,
  createAsyncThunk,
  createEntityAdapter,
} from "@reduxjs/toolkit";
// import { api } from "../../services/api"; // LATER: Uncomment for real API
import { initialData } from "../initialData";
//import { api } from "../../services/api"; // <-- 1. Import the real api
import { logout } from "./authSlice";

// --- MOCK API: Simulates the backend API calls for NetTypes ---
const mockApi = {
  // Simulates fetching all network types.
  getNetTypes: async () => {
    await new Promise((resolve) => setTimeout(resolve, 50)); // Fast fetch
    return initialData.netTypes;
  },
  // Simulates adding a new network type.
  addNetType: async (netTypeData) => {
    await new Promise((resolve) => setTimeout(resolve, 500));
    console.log("Mock API: Adding NetType...", netTypeData);
    // In a real API, the backend would assign and return the new ID.
    const newNetType = { ...netTypeData, id: Date.now() };
    return newNetType;
  },
  // Simulates deleting a network type.
  deleteNetType: async (netTypeId) => {
    await new Promise((resolve) => setTimeout(resolve, 500));
    console.log("Mock API: Deleting NetType with ID:", netTypeId);
    return { success: true };
  },
};

// --- ENTITY ADAPTER for efficient state management ---
const netTypesAdapter = createEntityAdapter({
  // We expect each netType to have a unique `id`
  selectId: (netType) => netType.id,
});

const initialState = netTypesAdapter.getInitialState({
  status: "idle", // 'idle' | 'loading' | 'succeeded' | 'failed'
  error: null,
});

// --- ASYNC THUNKS ---

// 1. THUNK for FETCHING all network types
export const fetchNetTypes = createAsyncThunk(
  "netTypes/fetchNetTypes",
  async (_, { rejectWithValue }) => {
    try {
      // LATER: Replace with real API call: const response = await api.getNetTypes();
      const response = await mockApi.getNetTypes();
      //const response = await api.getNetTypes(); // <-- 2. Import the real api
      return response;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// 2. THUNK for ADDING a new network type
export const addNetType = createAsyncThunk(
  "netTypes/addNetType",
  async (netTypeData, { rejectWithValue }) => {
    // `netTypeData` would be an object like { name: 'Guest Network' }
    try {
      // The API should return the newly created object, including its new ID.
      // LATER: Replace with: const newNetType = await api.addNetType(netTypeData);
      const newNetType = await mockApi.addNetType(netTypeData);
      //const newNetType = await api.addNetType(netTypeData); // <-- 3. Import the real api
      return newNetType;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// 3. THUNK for DELETING a network type
export const deleteNetType = createAsyncThunk(
  "netTypes/deleteNetType",
  async (netTypeId, { rejectWithValue }) => {
    try {
      // LATER: Replace with: await api.deleteNetType(netTypeId);
      await mockApi.deleteNetType(netTypeId);
      // On success, return the ID of the deleted item so the reducer can remove it.
      //await api.deleteNetType(netTypeId);  // <-- 4. Import the real api
      return netTypeId;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// --- THE SLICE DEFINITION ---
const netTypesSlice = createSlice({
  name: "netTypes",
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      // --- Reducers for Fetching ---
      .addCase(fetchNetTypes.pending, (state) => {
        state.status = "loading";
        state.error = null;
      })
      .addCase(fetchNetTypes.fulfilled, (state, action) => {
        state.status = "succeeded";
        // Use the adapter to efficiently set all items
        netTypesAdapter.setAll(state, action.payload);
      })
      .addCase(fetchNetTypes.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.payload;
      })

      // --- Reducers for Adding (Pessimistic Update) ---
      .addCase(addNetType.fulfilled, (state, action) => {
        // Add the new item to the state after the API call succeeds
        netTypesAdapter.addOne(state, action.payload);
      })
      // You can add .pending and .rejected cases for addNetType if you need to show specific UI feedback

      // --- Reducers for Deleting (Pessimistic Update) ---
      .addCase(deleteNetType.fulfilled, (state, action) => {
        // Remove the item from the state after the API call succeeds
        netTypesAdapter.removeOne(state, action.payload); // payload is the netTypeId
      })
      // You can add .pending and .rejected cases for deleteNetType for UI feedback

      // --- Reducer for Logout ---
      .addCase(logout, () => {
        // Reset the slice to its initial empty state on logout
        return initialState;
      });
  },
});

// --- EXPORT ACTIONS ---
// The async thunks `fetchNetTypes`, `addNetType`, and `deleteNetType` are the primary actions to be dispatched from the UI.

// --- EXPORT SELECTORS ---
// The adapter provides memoized selectors for free!
export const {
  selectAll: selectAllNetTypes,
  selectById: selectNetTypeById,
  selectIds: selectNetTypeIds,
} = netTypesAdapter.getSelectors((state) => state.netTypes);

// Also export status and error selectors for the UI to use
export const selectNetTypesStatus = (state) => state.netTypes.status;
export const selectNetTypesError = (state) => state.netTypes.error;

// --- EXPORT REDUCER ---
export default netTypesSlice.reducer;

--- File: src\redux\slices\realtimeSlice.jsx ---
import { createSlice } from "@reduxjs/toolkit";

const initialState = {
  status: "disconnected", // 'disconnected' | 'connecting' | 'connected'
};

const realtimeSlice = createSlice({
  name: "realtime",
  initialState,
  reducers: {
    // Action to be dispatched by the UI to initiate the connection.
    // The middleware will intercept this.
    startConnecting: (state) => {
      state.status = "connecting";
    },
    // Action dispatched by the middleware once the connection is established.
    connectionEstablished: (state) => {
      state.status = "connected";
    },
    // Action dispatched by the UI to terminate the connection (e.g., on logout).
    disconnect: (state) => {
      state.status = "disconnected";
    },
  },
});

export const { startConnecting, connectionEstablished, disconnect } =
  realtimeSlice.actions;

export const selectRealtimeStatus = (state) => state.realtime.status;

export default realtimeSlice.reducer;

--- File: src\redux\slices\sitesSlice.jsx ---
// src/redux/slices/sitesSlice.js

import {
  createSlice,
  createSelector,
  createAsyncThunk,
} from "@reduxjs/toolkit";
import { initialData } from "../initialData";

//import { api } from "../../services/apiServices"; // <-- 1. Import the real api

// --- MOCK API: Mimics the real API call using dummy data ---
// This isolates the data source, making it easy to swap for the real API later.
const mockApi = {
  getSites: async () => {
    // Simulate a network delay for a realistic loading experience
    await new Promise((resolve) => setTimeout(resolve, 300));
    // The data from initialData.sites is now enriched with more fields.
    return initialData.sites;
  },
};

// --- ASYNC THUNK: For fetching the sites ---
export const fetchSites = createAsyncThunk(
  "sites/fetchSites",
  async (_, { rejectWithValue }) => {
    try {
      const response = await mockApi.getSites();
      //const response = await api.getSites(); // <-- 2. Import the real api
      return response;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// --- The Slice Definition ---
// Shape of a Site object in the state:
// {
//   id: 56789,
//   interface_id: "TenGigabitEthernet1/0/1", // Note: This is now the interface name
//   device_id: 456,
//   site_name_english: 'Site SomeCity',
//   timestamp: "...",
//
//   // --- NEW ENRICHED FIELDS ---
//   physicalStatus: "Up" | "Down" | "N/A",
//   protocolStatus: "Up" | "Down" | "N/A",
//   MPLS: "Enabled" | "N/A",
//   OSPF: "Enabled" | "N/A",
//   Bandwidth: 10000 | "N/A",
//   Description: "Some description text..." | "N/A",
//   MediaType: "Fiber" | "N/A",
//   CDP: "neighbor-switch-xyz" | "N/A",
//   TX: -3.4 | "N/A",
//   RX: -4.1 | "N/A"
// }
const sitesSlice = createSlice({
  name: "sites",
  initialState: {
    items: [], // Start with an empty array for the sites
    status: "idle", // 'idle' | 'loading' | 'succeeded' | 'failed'
    error: null,
  },
  // Reducers for synchronous, direct state mutations
  reducers: {
    addSite: (state, action) => {
      const existingSite = state.items.find(
        (site) => site.id === action.payload.id
      );
      if (!existingSite) {
        state.items.push(action.payload);
      }
    },
    deleteSite: (state, action) => {
      const siteIdToRemove = action.payload;
      state.items = state.items.filter((site) => site.id !== siteIdToRemove);
    },
    updateSite: (state, action) => {
      const { id, ...updatedFields } = action.payload;
      const siteIndex = state.items.findIndex((site) => site.id === id);
      if (siteIndex !== -1) {
        state.items[siteIndex] = {
          ...state.items[siteIndex],
          ...updatedFields,
        };
      }
    },
  },
  // extraReducers handle the lifecycle of the `fetchSites` async thunk
  extraReducers: (builder) => {
    builder
      .addCase(fetchSites.pending, (state) => {
        state.status = "loading";
        state.error = null;
      })
      .addCase(fetchSites.fulfilled, (state, action) => {
        state.status = "succeeded";
        // Populate the state with the fetched site data
        state.items = action.payload;
      })
      .addCase(fetchSites.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.payload;
      });
  },
});

// --- Export Actions ---
export const { addSite, deleteSite, updateSite } = sitesSlice.actions;

// --- Export Selectors ---
export const selectAllSites = (state) => state.sites.items;

export const selectSiteById = (state, siteId) =>
  state.sites.items.find((site) => site.id === siteId);

// --- MEMOIZED SELECTOR ---
const selectSites = (state) => state.sites.items;
const selectDeviceId = (state, deviceId) => deviceId;

export const selectSitesByDeviceId = createSelector(
  [selectSites, selectDeviceId],
  (allSites, deviceId) => {
    if (!deviceId) return [];
    return allSites.filter((site) => site.device_id === deviceId);
  }
);

// --- Export Reducer ---
export default sitesSlice.reducer;

--- File: src\redux\slices\tenGigLinksSlice.jsx ---
// src/redux/slices/tenGigLinksSlice.js

import {
  createSlice,
  createSelector,
  createAsyncThunk,
} from "@reduxjs/toolkit";
import { initialData } from "../initialData";

//import { api } from "../../services/apiServices"; // <-- 1. Import the real api

// --- MOCK API: Mimics the real API call using dummy data ---
const mockApi = {
  getTenGigLinks: async () => {
    // Simulate a network delay for a realistic loading experience
    await new Promise((resolve) => setTimeout(resolve, 350));
    // The data from initialData.tenGigLinks is now enriched
    return initialData.tenGigLinks;
  },
};

// --- ASYNC THUNK: For fetching the 10-Gigabit links ---
export const fetchTenGigLinks = createAsyncThunk(
  "tenGigLinks/fetchTenGigLinks",
  async (_, { rejectWithValue }) => {
    try {
      const response = await mockApi.getTenGigLinks();
      // Note: Using 'getTenGigLines' to match the function name in api.js
      //const response = await api.getTenGigLines(); // <-- 2. Import the real api
      return response;
    } catch (error) {
      return rejectWithValue(error.message);
    }
  }
);

// --- The Slice Definition ---
// Shape of a Link object in the state:
// {
//   id: "link-10g-xyz",
//   source: "rtr-abcd-1",
//   target: "rtr-efgh-2",
//   status: "up" | "down" | "issue",
//   network_type_id: 1,
//   ip: "...",
//
//   // --- NEW ENRICHED FIELDS ---
//   physicalStatus: "Up" | "Down" | "N/A",
//   protocolStatus: "Up" | "Down" | "N/A",
//   MPLS: "Enabled" | "N/A",
//   OSPF: "Enabled" | "N/A",
//   Bandwidth: 10000 | "N/A",
//   Description: "Some description text..." | "N/A",
//   MediaType: "Fiber" | "N/A",
//   CDP: "neighbor-switch-xyz" | "N/A",
//   TX: -3.4 | "N/A",
//   RX: -4.1 | "N/A"
// }
const tenGigLinksSlice = createSlice({
  name: "tenGigLinks",
  initialState: {
    items: [], // Start with an empty array for the links
    status: "idle", // 'idle' | 'loading' | 'succeeded' | 'failed'
    error: null,
  },
  // Reducers for synchronous actions
  reducers: {
    addTenGigLink: (state, action) => {
      state.items.push(action.payload);
    },
    deleteTenGigLink: (state, action) => {
      const linkIdToRemove = action.payload;
      state.items = state.items.filter((link) => link.id !== linkIdToRemove);
    },
    updateTenGigLink: (state, action) => {
      const { id, ...updatedFields } = action.payload;
      const linkIndex = state.items.findIndex((link) => link.id === id);
      if (linkIndex !== -1) {
        state.items[linkIndex] = {
          ...state.items[linkIndex],
          ...updatedFields,
        };
      }
    },
  },
  // extraReducers handle the lifecycle of the `fetchTenGigLinks` async thunk
  extraReducers: (builder) => {
    builder
      .addCase(fetchTenGigLinks.pending, (state) => {
        state.status = "loading";
        state.error = null;
      })
      .addCase(fetchTenGigLinks.fulfilled, (state, action) => {
        state.status = "succeeded";
        // Populate the state with the fetched link data
        state.items = action.payload;
      })
      .addCase(fetchTenGigLinks.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.payload;
      });
  },
});

// --- Export Actions ---
export const { addTenGigLink, deleteTenGigLink, updateTenGigLink } =
  tenGigLinksSlice.actions;

// --- Export Selectors ---
export const selectAllTenGigLinks = (state) => state.tenGigLinks.items;

// --- MEMOIZED SELECTOR ---
const selectLinkItems = (state) => state.tenGigLinks.items;
const selectTypeIdFromLink = (state, typeId) => typeId;

export const selectLinksByTypeId = createSelector(
  [selectLinkItems, selectTypeIdFromLink],
  (links, typeId) => {
    if (!typeId) return [];
    return links.filter((l) => l.network_type_id === typeId);
  }
);

// --- Export Reducer ---
export default tenGigLinksSlice.reducer;

--- File: src\services\apiServices.jsx ---
import axios from "axios";
import Cookies from "js-cookie";

// --- Configuration ---
const API_BASE_URL =
  import.meta.env.VITE_API_URL || "http://localhost:8000/api";

//REACT_APP_API_URL=http://your-backend-api.com/api (instead of VITE_API_URL || "http://localhost:8000/api";)

// --- Create a Centralized Axios Instance ---
const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    "Content-Type": "application/json",
  },
});

// --- Axios Interceptor for Authentication ---
apiClient.interceptors.request.use(
  (config) => {
    // The name of the cookie must match where you store it after login
    const token = Cookies.get("authToken");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// --- API Helper Function ---
/**
 * A helper function to handle API calls and potential errors.
 * It assumes the backend returns data directly (not wrapped in a "response" key).
 * @param {Promise} request - The axios request promise.
 * @returns {Promise<any>} A promise that resolves to the response data.
 */
const handleApiCall = async (request) => {
  try {
    const response = await request;
    return response.data;
  } catch (error) {
    console.error("API call failed:", error.response || error.message);
    // Re-throw the error so the calling component/thunk can handle it (e.g., show a UI message)
    throw error;
  }
};

export const api = {
  // --- AUTHENTICATION ---
  /**
   * Logs in a user and returns the access token.
   * @param {string} username - The user's username.
   * @param {string} password - The user's password.
   * @returns {Promise<string>} The authentication token.
   */
  login: async (username, password) => {
    const response = await apiClient.post("/login", { username, password });
    return response.data.access_token;
  },

  // --- GET Endpoints ---
  getTenGigLines: () => handleApiCall(apiClient.get("/get_ten_gig_lines")),
  getNetTypes: () => handleApiCall(apiClient.get("/get_net_types")),
  getCorePikudim: () => handleApiCall(apiClient.get("/get_core_pikudim")),
  getCoreDevices: () => handleApiCall(apiClient.get("/get_core_devices")),
  getSites: () => handleApiCall(apiClient.get("/get_sites")),
  getDeviceInfo: (deviceId) =>
    handleApiCall(apiClient.get(`/get_device_info/${deviceId}`)),
  getDevicesByCorePikudim: (corePikudimId) =>
    handleApiCall(
      apiClient.get(`/get_devices_by_core_pikudim/${corePikudimId}`)
    ),
  getSiteBandwidth: (siteName) =>
    handleApiCall(apiClient.get(`/get_site_bw/${siteName}`)),
  getInterfacesUp: (siteName) =>
    handleApiCall(apiClient.get(`/get_interfaces_up/${siteName}`)),

  // --- POST (Create/Add) Endpoints ---
  addCorePikudim: (pikudData) =>
    handleApiCall(apiClient.post("/add_core_pikudim", pikudData)),
  addCoreDevice: (deviceData) =>
    handleApiCall(apiClient.post("/add_core_device", deviceData)),
  addNetType: (netTypeData) =>
    handleApiCall(apiClient.post("/add_net_type", netTypeData)),
  /**
   * Triggers a WAN connection check for a specific segment and site.
   * @param {object} networkData - Object with management_segment and sda_site_id.
   * @returns {Promise<any>} A promise that resolves to the connection check result.
   */
  getWanConnection: (networkData) =>
    handleApiCall(apiClient.post("/get_wan_connection", networkData)),

  // --- PUT (Update/Action) Endpoints ---
  /**
   * Triggers a refresh of all interfaces for a specific device.
   * @param {string|number} deviceId - The ID of the device to refresh.
   * @returns {Promise<object>} A promise that resolves to the confirmation/status response.
   */
  refreshInterfacesPerDevice: (deviceId) =>
    handleApiCall(apiClient.put(`/refresh_interfaces_per_device/${deviceId}`)),

  /**
   * Triggers a refresh for a single, specific interface.
   * @param {object} refreshData - The data for the refresh (e.g., { device_id: 1, interface: 'Gig0/1' }).
   * @returns {Promise<object>} A promise that resolves to the confirmation/status response.
   */
  refreshInterface: (refreshData) =>
    handleApiCall(apiClient.put(`/refresh_interface`, refreshData)),

  /**
   * Marks a specific alert as a favorite.
   * @param {string|number} alertId - The ID of the alert to favorite.
   * @returns {Promise<object>} A promise that resolves to the confirmation response.
   */
  favoriteAlert: (alertId) =>
    handleApiCall(apiClient.put(`/favorite_alert/${alertId}`)),

  // --- DELETE Endpoints ---
  deleteCorePikudim: (corePikudimId) =>
    handleApiCall(apiClient.delete(`/delete_core_pikudim/${corePikudimId}`)),
  deleteDevice: (deviceId) =>
    handleApiCall(apiClient.delete(`/delete_device/${deviceId}`)),
  deleteNetType: (netTypeId) =>
    handleApiCall(apiClient.delete(`/delete_net_type/${netTypeId}`)),
  /**
   * Deletes a specific alert by its ID.
   * @param {string|number} alertId - The ID of the alert to delete.
   * @returns {Promise<object>} A promise that resolves to the confirmation response.
   */
  deleteAlert: (alertId) =>
    handleApiCall(apiClient.delete(`/delete_alert/${alertId}`)),

  // --- ALERTS Endpoints ---
  /**
   * Fetches all alerts from the database.
   * @returns {Promise<Array<object>>} A promise that resolves to a list of alert objects.
   */
  getAllAlerts: () => handleApiCall(apiClient.get("/get_all_alerts")),

  /**
   * Fetches the status of all alerts.
   * @returns {Promise<any>} A promise that resolves to the alert status data.
   */
  getAllAlertsStatus: () =>
    handleApiCall(apiClient.get("/get_all_alerts_status")),

  /**
   * Fetches the severity of all alerts.
   * @returns {Promise<any>} A promise that resolves to the alert severity data.
   */
  getAllAlertsSeverity: () =>
    handleApiCall(apiClient.get("/get_all_alerts_severity")),

  /**
   * Fetches the favorite link IDs for the currently authenticated user.
   * @returns {Promise<Array<string>>} A promise that resolves to an array of link IDs.
   */
  getFavoriteLinks: () =>
    handleApiCall(apiClient.get("/users/me/favorites/links")),

  /**
   * Replaces the user's list of favorite links on the server.
   * @param {Array<string>} linkIds - The complete new array of favorite link IDs.
   * @returns {Promise<object>} A promise that resolves to the server's confirmation response.
   */
  updateFavoriteLinks: (linkIds) =>
    handleApiCall(
      apiClient.put("/users/me/favorites/links", { link_ids: linkIds })
    ),
};

--- File: src\services\realtimeService.jsx ---
import { updateTenGigLink } from "../redux/slices/tenGigLinksSlice";
import { connectionEstablished } from "../redux/slices/realtimeSlice";

// This service simulates a persistent connection to a server.
const realtimeService = {
  intervalId: null,

  /**
   * Starts the mock real-time update service.
   * @param {function} dispatch - The Redux store's dispatch function.
   * @param {function} getState - The Redux store's getState function.
   */
  start(dispatch, getState) {
    // Prevent multiple intervals from running
    if (this.intervalId) {
      this.stop();
    }

    // Immediately dispatch that the connection is live.
    dispatch(connectionEstablished());

    this.intervalId = setInterval(() => {
      const { items: allLinks } = getState().tenGigLinks;

      if (allLinks && allLinks.length > 0) {
        // 1. Pick a random link to update
        const randomLink =
          allLinks[Math.floor(Math.random() * allLinks.length)];

        // 2. Determine a new status for it
        const statuses = ["up", "down", "issue"];
        const currentStatusIndex = statuses.indexOf(randomLink.status);
        const nextStatus = statuses[(currentStatusIndex + 1) % statuses.length]; // Cycle through statuses

        // 3. Create the payload for the update action
        const updatePayload = {
          id: randomLink.id,
          status: nextStatus,
        };

        // 4. Dispatch a standard Redux action, as if this came from a WebSocket.
        // The middleware has passed the store's dispatch function to this service.
        console.log(
          `[RealtimeService] Firing update for Link ${randomLink.id}: status -> ${nextStatus}`
        );
        dispatch(updateTenGigLink(updatePayload));
      }
    }, 3500); // Fire an update every 3.5 seconds
  },

  /**
   * Stops the real-time update service.
   */
  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
      console.log("[RealtimeService] Stopped.");
    }
  },
};

export default realtimeService;

/*
const realtimeService = {
  socket: null,
  reconnectInterval: 5000, // Try to reconnect every 5 seconds


   //Starts the real-time WebSocket connection.
   //@param {function} dispatch - The Redux store's dispatch function.
   //@param {function} getState - The Redux store's getState function.
   
  start(dispatch, getState) {
    // Prevent multiple connections
    if (this.socket && this.socket.readyState < 2) {
      console.log("[RealtimeService] Connection already open or connecting.");
      return;
    }

    // Configure the WebSocket URL. Use wss for secure connections.
    const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    const API_BASE_URL = import.meta.env.VITE_API_URL || "localhost:8000";
    const wsUrl = `${protocol}//${API_BASE_URL.replace(/https?:\/\//, '')}/ws/updates`;
    
    console.log(`[RealtimeService] Connecting to ${wsUrl}...`);
    this.socket = new WebSocket(wsUrl);

    // --- Event Listeners for the WebSocket ---

    // 1. On successfully opening a connection
    this.socket.onopen = () => {
      console.log("[RealtimeService] WebSocket connection established.");
      // Dispatch the action to update the slice's status to 'connected'
      dispatch(connectionEstablished());
    };

    // 2. On receiving a message from the server
    this.socket.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        console.log("[RealtimeService] Received message:", message);

        // Here, you would check the message type and dispatch the correct action.
        // For this example, we assume all messages are link status updates.
        // A real implementation might have a switch statement: switch(message.type)
        if (message.type === 'link_update' && message.payload) {
          // The payload should match the expected format for the updateTenGigLink action
          // e.g., { id: 'link-10g-xyz', status: 'down' }
          dispatch(updateTenGigLink(message.payload));
        } else if (message.type === 'new_alert' && message.payload) {
          // You could even have real-time alerts!
          // dispatch(addNewAlert(message.payload));
        }

      } catch (error) {
        console.error("[RealtimeService] Error parsing message:", error);
      }
    };

    // 3. On the connection closing
    this.socket.onclose = () => {
      console.log("[RealtimeService] WebSocket connection closed.");
      // Update the slice's status to 'disconnected'
      dispatch(disconnect());

      // Optional: Attempt to reconnect after a delay
      setTimeout(() => {
          console.log("[RealtimeService] Attempting to reconnect...");
          this.start(dispatch, getState); // Recursively call start to reconnect
      }, this.reconnectInterval);
    };

    // 4. On a connection error
    this.socket.onerror = (error) => {
      console.error("[RealtimeService] WebSocket error:", error);
      // The `onclose` event will usually fire immediately after an error.
      this.socket.close();
    };
  },


   //Gracefully closes the WebSocket connection.
   
  stop() {
    if (this.socket) {
      // Set reconnect interval to a very high number to prevent auto-reconnect on manual stop
      this.reconnectInterval = 1e9;
      this.socket.close();
      this.socket = null;
      console.log("[RealtimeService] Stopped and closed WebSocket connection.");
    }
  },
};*/
